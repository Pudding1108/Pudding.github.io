<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构（基础）笔记</title>
      <link href="/2025/06/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/06/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章：绪论"><a href="#第一章：绪论" class="headerlink" title="第一章：绪论"></a>第一章：绪论</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><p><strong>数据</strong>是信息的载体是对客观事物的符号表示，在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称。</p><p><strong>数据元素</strong>是数据的基本单位，一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。</p><p><strong>数据对象</strong>是性质相同的数据元素的集合，是数据的一个子集。</p><p><strong>数据结构</strong>是相互之间存在一种或多种特定关系的数据元素的集合。（没有官方统一定义）</p><p>数据结构三要素：逻辑结构；数据的运算；物理结构（存储结构）</p><p><strong>数据类型</strong>是一个值的集合和定义在此集合上的一组操作的总称。</p><ol><li>原子类型。其值不可再分的数据类型。 </li><li>结构类型。其值可以再分解为若干成分（分量）的数据类型。</li></ol><p><strong>抽象数据类型</strong>描述了数据的逻辑结构和抽象运算，通常用【数据对象、数据关系、基本操作集】这样的三元组来表示，从而构成一个完整的数据结构定义</p><p><strong>算法</strong>是对特定问题求解步骤的一种描述。</p><p><strong>算法的特性</strong>：</p><p>①<strong>有穷性</strong>。一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。</p><p>②<strong>确定性</strong>。算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。</p><p>③<strong>可行性</strong>。算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。 </p><p>④<strong>输入</strong>。一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。 </p><p>⑤<strong>输出</strong>。一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。</p><p><strong>“好“算法的特质</strong>：</p><p>①<strong>正确性</strong>。算法应能够正确地解决求解问题。</p><p>②<strong>可读性</strong>。算法应具有良好的可读性，以帮助人们理解。</p><p>③<strong>健壮性</strong>。输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。</p><p>④<strong>高效率与低存储量需求</strong>。</p><h2 id="2-算法的时间复杂度"><a href="#2-算法的时间复杂度" class="headerlink" title="2.算法的时间复杂度"></a>2.算法的<strong>时间复杂度</strong></h2><p>定义：在计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。一个算法执行所耗费的时间，从理论上说，是不能算出来的，只有你把你的程序放在机器上跑起来，才能知道。但是我们需要每个算法都上机测试吗？是可以都上机测试，但是这很麻烦，所以才有了时间复杂度这个分析方式。一个算法所花费的时间与其中语句的执行次数成正比例，<strong>算法中的基本操作的执行次数，为算法的时间复杂度</strong>。</p><h2 id="3-算法的空间复杂度"><a href="#3-算法的空间复杂度" class="headerlink" title="3.算法的空间复杂度"></a>3.算法的<strong>空间复杂度</strong></h2><p>定义：空间复杂度是对一个算法在运行过程中<strong>临时占用存储空间大小的量度</strong> 。空间复杂度不是程序占用了多少bytes的空间，因为这个也没太大意义，所以空间复杂度算的是变量的个数。空间复杂度计算规则基本跟实践复杂度类似，也使用<strong>大O渐进表示法</strong>。</p><h1 id="第二章：线性表"><a href="#第二章：线性表" class="headerlink" title="第二章：线性表"></a>第二章：线性表</h1><h2 id="1-线性表"><a href="#1-线性表" class="headerlink" title="1.线性表"></a>1.线性表</h2><h3 id="1-1-线性表的定义"><a href="#1-1-线性表的定义" class="headerlink" title="1.1 线性表的定义"></a>1.1 线性表的定义</h3><p>线性表—具有<strong>相同数据类型</strong>的n（n≥0）个<strong>数据元素</strong>的<strong>有限序列</strong>，其中n为表长，n为0时线性表是一个空表。</p><h3 id="1-2-基本操作"><a href="#1-2-基本操作" class="headerlink" title="1.2 基本操作"></a>1.2 基本操作</h3><h4 id="1-2-1-InitList-L"><a href="#1-2-1-InitList-L" class="headerlink" title="1.2.1 InitList(&amp;L)"></a>1.2.1 InitList(&amp;L)</h4><p>初始化表。构造一个空的线性表L，分配内存空间。 </p><h4 id="1-2-2-DestroyList-L"><a href="#1-2-2-DestroyList-L" class="headerlink" title="1.2.2 DestroyList(&amp;L)"></a>1.2.2 DestroyList(&amp;L)</h4><p>销毁操作。销毁线性表，并释放线性表L所占用的内存空间。</p><h4 id="1-2-3-ListInsert-L-i-e"><a href="#1-2-3-ListInsert-L-i-e" class="headerlink" title="1.2.3 ListInsert(&amp;L,i,e)"></a>1.2.3 ListInsert(&amp;L,i,e)</h4><p>插入操作。在表L中的第i个位置上插入指定元素e。 </p><h4 id="1-2-4-ListDelete-L-i-e"><a href="#1-2-4-ListDelete-L-i-e" class="headerlink" title="1.2.4 ListDelete(&amp;L,i,&amp;e)"></a>1.2.4 ListDelete(&amp;L,i,&amp;e)</h4><p>删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。</p><h4 id="1-2-5-LocateElem-L-e"><a href="#1-2-5-LocateElem-L-e" class="headerlink" title="1.2.5 LocateElem(L,e)"></a>1.2.5 LocateElem(L,e)</h4><p>按值查找操作。在表L中查找具有给定关键字值的元素。 </p><h4 id="1-2-6-GetElem-L-i"><a href="#1-2-6-GetElem-L-i" class="headerlink" title="1.2.6 GetElem(L,i)"></a>1.2.6 GetElem(L,i)</h4><p>按位查找操作。获取表L中第i个位置的元素的值。</p><h4 id="1-2-7-其他常用操作"><a href="#1-2-7-其他常用操作" class="headerlink" title="1.2.7 其他常用操作"></a>1.2.7 其他常用操作</h4><p>Length(L)：求表长。返回线性表L的长度，即L中数据元素的个数。 </p><p>PrintList(L)：输出操作。按前后顺序输出线性表L的所有元素值。 </p><p>Empty(L)：判空操作。若L为空表，则返回true，否则返回false。<br>从无到有 从有到无</p><p>Tips： </p><p>①对数据的操作（记忆思路）——创销、增删改查 </p><p>②C语言函数的定义—— &lt;返回值类型&gt; 函数名(&lt;参数1类型&gt;参数1，&lt;参数2类型&gt;参数2，……) </p><p>③实际开发中，可根据实际需求定义其他的基本操作</p><p>④函数名和参数的形式、命名都可改变（Reference：严蔚敏版《数据结构》）</p><p>⑤什么时候要传入引用“&amp;”——对参数的修改结果需要“带回来”</p><h2 id="2-顺序表"><a href="#2-顺序表" class="headerlink" title="2.顺序表"></a>2.顺序表</h2><h3 id="2-1-顺序表的定义"><a href="#2-1-顺序表的定义" class="headerlink" title="2.1 顺序表的定义"></a>2.1 顺序表的定义</h3><p>用<strong>顺序存储</strong>的方式实现<strong>线性表</strong>。</p><p>顺序存储—把逻辑上相邻的元素存储在物理 位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。</p><h3 id="2-2-顺序表的实现"><a href="#2-2-顺序表的实现" class="headerlink" title="2.2 顺序表的实现"></a>2.2 顺序表的实现</h3><p>静态分配   &amp;&amp;  动态分配</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态分配</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data[<span class="number">10</span>];  <span class="comment">//用静态的数组存放数据元素</span></span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SqList &amp;L)</span>&#123;  <span class="comment">//初始化一个顺序表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        L.data[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L.length=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态分配</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line">    <span class="type">int</span> MaxSize;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SeqList;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IncreaseSize</span><span class="params">(SeqList &amp;L,<span class="type">int</span> len)</span>&#123;  <span class="comment">//增加动态数组的长度</span></span><br><span class="line">    <span class="type">int</span> *p = L.data;</span><br><span class="line">    <span class="comment">//动态申请内存空间</span></span><br><span class="line">    <span class="comment">//malloc函数返回一个指针，需要强制转型为你定义的数据元素类型指针</span></span><br><span class="line">    <span class="comment">//malloc函数头文件&lt;stdlib.h&gt;</span></span><br><span class="line">    L.data = (<span class="type">int</span> *)<span class="built_in">malloc</span>((L.Maxsize+len)*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">        L.data[i] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    L.MaxSize = L.MaxSize+len;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-顺序表的特点"><a href="#2-3-顺序表的特点" class="headerlink" title="2.3 顺序表的特点"></a>2.3 顺序表的特点</h3><p>① <strong>随机访问</strong> ，即可以在O(1)时间内找到第i个元素。</p><p>②存储密度高，每个节点只存储数据元素 </p><p>③拓展容量不方便（即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高）</p><p>④插入、删除操作不方便，需要移动大量元素 </p><h3 id="2-4-顺序表的基本操作"><a href="#2-4-顺序表的基本操作" class="headerlink" title="2.4 顺序表的基本操作"></a>2.4 顺序表的基本操作</h3><h4 id="2-4-1-插入"><a href="#2-4-1-插入" class="headerlink" title="2.4.1 插入"></a>2.4.1 插入</h4><p>ListInsert(&amp;L,i,e)—在表L中的第i个位置上插入指定元素e。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ListInsert</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,<span class="type">int</span> e)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=L.length;j&gt;=i;j--)&#123;</span><br><span class="line">        L.data[j] = L.data[j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    L.data[i<span class="number">-1</span>] = e;</span><br><span class="line">    L.length++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间复杂度:O(n)</span></span><br></pre></td></tr></table></figure><h4 id="2-4-2-删除"><a href="#2-4-2-删除" class="headerlink" title="2.4.2 删除"></a>2.4.2 删除</h4><p>ListDelete(&amp;L,i,&amp;e)—删除表L中第i个位置的元素，并用e返回删除元素的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ListDelete</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,<span class="type">int</span> &amp;e)</span>&#123;</span><br><span class="line">e = L.data[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;L.length;j++)&#123;</span><br><span class="line">L.dara[j<span class="number">-1</span>] = L.data[j];</span><br><span class="line">&#125;</span><br><span class="line">L.length--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间复杂度:O(n)</span></span><br></pre></td></tr></table></figure><h4 id="2-4-3-按值查找"><a href="#2-4-3-按值查找" class="headerlink" title="2.4.3 按值查找"></a>2.4.3 按值查找</h4><p>LocateElem(L,e)—在表L中查找具有给定关键字值的元素。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在顺序表L中查找第一个元素值等于e的元素，并返回其位序</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(SqList L,<span class="type">int</span> e)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L.data[i]==e)&#123;</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;  <span class="comment">//返回位序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间复杂度:O(n)</span></span><br></pre></td></tr></table></figure><h4 id="2-4-4-按位查找"><a href="#2-4-4-按位查找" class="headerlink" title="2.4.4 按位查找"></a>2.4.4 按位查找</h4><p>GetElem(L,i)—获取表L中第i个位置的元素的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GetElem</span><span class="params">(SqList L,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L.data[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间复杂度:O(1)</span></span><br></pre></td></tr></table></figure><h2 id="3-单链表"><a href="#3-单链表" class="headerlink" title="3.单链表"></a>3.单链表</h2><h3 id="3-1单链表的定义"><a href="#3-1单链表的定义" class="headerlink" title="3.1单链表的定义"></a>3.1单链表的定义</h3><p>单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的数据元素。链表中的数据是以结点来表示的，每个结点的构成：<strong>元素</strong>(数据元素的映象) + <strong>指针</strong>(指示后继元素存储位置)，元素就是存储数据的存储单元，指针就是连接每个结点的地址数据。</p><p>优点：不要求大片连续空间，改变容量方便 </p><p>缺点：不可随机存取，要耗费一定空间存放指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>            <span class="comment">//定义单链表结点类型</span></span><br><span class="line">    <span class="type">int</span> data;            <span class="comment">//每个节点存放一个数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>  <span class="comment">//指针指向下一个结点</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">p</span> =</span> (<span class="keyword">struct</span> LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Lnode));</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了方便增加结点，可以用typedef来重命名</span></span><br><span class="line"><span class="comment">//把struct LNode重命名为LNode，用LinkList来表示指向struct LNode的指针</span></span><br><span class="line"><span class="comment">//LNode *L; 和 LinkList L；效果一样，但前者强调这是个结点，后者强调这是个单链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化一个空的单链表（不带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(Linklist &amp;L)</span>&#123;</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个空的单链表（带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(Linklist &amp;L)</span>&#123;</span><br><span class="line">    L = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2单链表的基本操作"><a href="#3-2单链表的基本操作" class="headerlink" title="3.2单链表的基本操作"></a>3.2单链表的基本操作</h3><h4 id="3-2-1-插入"><a href="#3-2-1-插入" class="headerlink" title="3.2.1 插入"></a>3.2.1 插入</h4><p>ListInsert(&amp;L,i,e)—在表L中的第i个位置上插入指定元素e。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按位序插入（带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,<span class="type">int</span> e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p;    <span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;   <span class="comment">//当前p指向的第几个结点</span></span><br><span class="line">    p = L;       <span class="comment">//L指向头结点，头结点为第0个结点（不存放数据）</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;   <span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123; <span class="comment">//i值不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////按位序插入（不带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,<span class="type">int</span> e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;   <span class="comment">//插入第1个结点的操作与其他结点操作不同</span></span><br><span class="line">        LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = e;</span><br><span class="line">        s-&gt;next = L;</span><br><span class="line">        L = s;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定结点的后插操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertNextNode</span><span class="params">(LNode *p,<span class="type">int</span> e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Lnode));</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>)&#123;    <span class="comment">//某些情况可能会导致内存分配失败，例如内存不足</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定结点的前插操作</span></span><br><span class="line"> <span class="type">bool</span> <span class="title function_">InsertPriorNode</span><span class="params">(LinkList L,LNode *p,<span class="type">int</span> e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Lnode));</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>)&#123;    <span class="comment">//某些情况可能会导致内存分配失败，例如内存不足</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    s-&gt;data = p-&gt;data;</span><br><span class="line">    p-&gt;data = e;    <span class="comment">//后插操作后交换数值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-删除"><a href="#3-2-2-删除" class="headerlink" title="3.2.2 删除"></a>3.2.2 删除</h4><p>ListDelete(&amp;L,i,&amp;e)—删除表L中第i个位置的元素，并用e返回删除元素的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////按位序删除（带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,<span class="type">int</span> &amp;e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *q = p-&gt;next;  <span class="comment">//q指向被删除结点</span></span><br><span class="line">    e = q-&gt;data;         <span class="comment">//e返回删除元素的值</span></span><br><span class="line">    p-&gt;next = q-&gt;next;   <span class="comment">//将*q结点从链中断开</span></span><br><span class="line">    <span class="built_in">free</span>(q);             <span class="comment">//释放结点存储空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除指定结点</span></span><br><span class="line"><span class="comment">//如果p是最后一个结点，就只能从表头开始依次寻找p的前驱</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeleteNode</span><span class="params">(LNode *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *q = p-&gt;next;       <span class="comment">//让q指向*p的后继结点</span></span><br><span class="line">    p-&gt;data = p-&gt;next-&gt;data;  <span class="comment">//和后继结点交换数据域</span></span><br><span class="line">    p-&gt;next = q-&gt;next;        <span class="comment">//将*q结点从链中断开</span></span><br><span class="line">    <span class="built_in">free</span>(q);                  <span class="comment">//释放后继结点存储空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-3-查找"><a href="#3-2-3-查找" class="headerlink" title="3.2.3 查找"></a>3.2.3 查找</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按位查找，返回第i个元素（带头结点）</span></span><br><span class="line">LNode *<span class="title function_">GetElem</span><span class="params">(LinkList L,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按值查找，找到数据域==e的结点</span></span><br><span class="line">LNode *<span class="title function_">LocateElem</span><span class="params">(LinkList L,<span class="type">int</span> e)</span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next;  <span class="comment">//从第1个结点开始查找数据域为e的结点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;p-&gt;data!=e)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-单链表的建立"><a href="#3-3-单链表的建立" class="headerlink" title="3.3 单链表的建立"></a>3.3 单链表的建立</h3><p>核心就是<strong>初始化</strong>操作、<strong>指定结点</strong>的后插操作</p><h4 id="3-3-1-尾插法"><a href="#3-3-1-尾插法" class="headerlink" title="3.3.1 尾插法"></a>3.3.1 尾插法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(Linklist &amp;L)</span>&#123;</span><br><span class="line">    L = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(L=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">LinkList <span class="title function_">List_TailInsert</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));   <span class="comment">//建立头结点</span></span><br><span class="line">    LNode *s,*r = L;                       <span class="comment">//r为表尾指针</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);                        <span class="comment">//输入结点的值</span></span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;                        <span class="comment">//输入9999表示结束</span></span><br><span class="line">        s = (LNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = x; </span><br><span class="line">        r-&gt;next = s; </span><br><span class="line">        r = s;                             <span class="comment">//r指向新的表尾结点</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;                        <span class="comment">//尾结点指针置空</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-头插法"><a href="#3-3-2-头插法" class="headerlink" title="3.3.2 头插法"></a>3.3.2 头插法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(Linklist &amp;L)</span>&#123;</span><br><span class="line">    L = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(L=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">LinkList <span class="title function_">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    LNode *s;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));   <span class="comment">//建立头结点</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;                        <span class="comment">//初始为空链表</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);                        <span class="comment">//输入结点的值</span></span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;                        <span class="comment">//输入9999表示结束</span></span><br><span class="line">        s = (LNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = x; </span><br><span class="line">        s-&gt;next = L-&gt;next; </span><br><span class="line">        L-&gt;next = s;                       <span class="comment">//将新结点插入表中，L为头指针</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-双链表"><a href="#4-双链表" class="headerlink" title="4.双链表"></a>4.双链表</h2><p>双链表就是在单链表的基础上再增加一个指针域。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span>   <span class="comment">//前驱和后继指针</span></span><br><span class="line">&#125;LNode,*DinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双链表的初始化</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(Dinklist &amp;L)</span>&#123;</span><br><span class="line">    L = (DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode)); <span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;prior = <span class="literal">NULL</span>;                    <span class="comment">//头结点的prioe永远指向NULL</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;                     <span class="comment">//头结点之后暂时没有结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双链表的插入</span></span><br><span class="line"><span class="comment">//在p结点后插入s节点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertNextNode</span><span class="params">(DNode *p,DNode *s)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||s==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        p-&gt;next-&gt;prior = s;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双链表的删除</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeleteNextNode</span><span class="params">(DNode *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(P==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DNode *q = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(q==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        q-&gt;next-&gt;prior=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-循环链表"><a href="#5-循环链表" class="headerlink" title="5.循环链表"></a>5.循环链表</h2><h3 id="5-1-循环单链表"><a href="#5-1-循环单链表" class="headerlink" title="5.1 循环单链表"></a>5.1 循环单链表</h3><p><strong>循环单链表</strong>：表尾结点的next指针指向头结点。</p><p>普通单链表无法找到前驱结点，循环单链表可以找到其他任何一个结点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个空的循环单链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(Linklist &amp;L)</span>&#123;</span><br><span class="line">    L = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(L=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = L;   <span class="comment">//头结点next指向头结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-循环双链表"><a href="#5-2-循环双链表" class="headerlink" title="5.2 循环双链表"></a>5.2 循环双链表</h3><p><strong>循环双链表</strong>：表头结点的prior指向表尾结点，表尾结点的next指向头结点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*DinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环双链表的初始化</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(Dinklist &amp;L)</span>&#123;</span><br><span class="line">    L = (DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">    <span class="keyword">if</span>(L=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;prior = L;</span><br><span class="line">    L-&gt;next = L;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-静态链表"><a href="#6-静态链表" class="headerlink" title="6.静态链表"></a>6.静态链表</h2><p>单链表：各个结点在内存中星罗棋布、散落天涯。</p><p>静态链表：分配一整片连续的内存空间，各个结点集中安置。相当于用数组的方式实现的链表。</p><p>优点：增、删操作不需要大量移动元素</p><p>缺点：不能随机存取，只能从头结点开始依次往后查找；容量固定不可变</p><p>适用场景：</p><p>①不支持指针的低级语言；</p><p>②数据元素数量固定不变的场景（如操作系统的文件分配表FAT）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10  <span class="comment">//静态链表最大长度</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span>             <span class="comment">//静态链表结构类型的定义</span></span><br><span class="line">    <span class="type">int</span> data;       <span class="comment">//存储数据元素</span></span><br><span class="line">    <span class="type">int</span> next;       <span class="comment">//下一个元素的数组下标</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">testLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">a</span>[<span class="title">MaxSize</span>];</span></span><br><span class="line">    <span class="comment">//......后续代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-顺序表和链表的比较"><a href="#7-顺序表和链表的比较" class="headerlink" title="7.顺序表和链表的比较"></a>7.顺序表和链表的比较</h2><blockquote><p><strong>逻辑结构</strong></p></blockquote><p>都属于线性表，都是线性结构。</p><blockquote><p><strong>存储结构</strong></p></blockquote><p>顺序表（顺序存储）：</p><p>优点：支持随机存取、存储密度高</p><p>缺点：大片连续空间分配不方便，改变容量不方便</p><p>链表（链式存储）：</p><p>优点：离散的小空间分配方便，改变容量方便</p><p>缺点：不可随机存取，存储密度低 </p><blockquote><p><strong>使用场景</strong></p></blockquote><p>链表——表长难以预估、经常要增加&#x2F;删除元素 </p><p>顺序表 ——表长可预估、查询（搜索）操作较多</p><h1 id="第三章：栈和队列"><a href="#第三章：栈和队列" class="headerlink" title="第三章：栈和队列"></a>第三章：栈和队列</h1><h2 id="1-栈"><a href="#1-栈" class="headerlink" title="1.栈"></a>1.栈</h2><h3 id="1-1-栈的定义"><a href="#1-1-栈的定义" class="headerlink" title="1.1 栈的定义"></a>1.1 栈的定义</h3><p>栈（Stack）—是<strong>只允许在一端进行插入或删除操作</strong>的线性表。 </p><p>（特性：<strong>后进先出</strong>）</p><p>空栈—栈中没有任何数据元素。</p><p>栈顶—<strong>允许</strong>插入和删除的一端。</p><p>栈底—<strong>不允许</strong>插入和删除的一端。</p><h3 id="1-2-栈的基本操作"><a href="#1-2-栈的基本操作" class="headerlink" title="1.2 栈的基本操作"></a>1.2 栈的基本操作</h3><p>栈的基本操作和线性表基本操作类似。（创、销、增、删、查）</p><p><strong>InitStack(&amp;S)</strong>：初始化栈。构造一个空栈S，分配内存空间。 </p><p><strong>DestroyStack(&amp;S)</strong>：销毁栈。销毁并释放栈S所占用的内存空间。</p><p><strong>Push(&amp;S,x)</strong>：进栈，若栈S未满，则将x加入使之成为新栈顶。 </p><p><strong>Pop(&amp;S,&amp;x)</strong>：出栈，若栈S非空，则弹出栈顶元素，并用x返回。</p><p><strong>GetTop(S,&amp;x)</strong>：读栈顶元素。若栈S非空，则用x返回栈顶元素</p><p>其他常用操作： </p><p><strong>StackEmpty(S)</strong>：判断一个栈S是否为空。若S为空，则返回true，否则返回false。</p><p>注： <strong>卡特兰数</strong><br>$$<br>n个不同元素进栈，出栈元素不同排列的个数为 \frac{1}{n+1}C_{2n}^{n}<br>$$</p><h3 id="1-3-栈的顺序存储实现"><a href="#1-3-栈的顺序存储实现" class="headerlink" title="1.3 栈的顺序存储实现"></a>1.3 栈的顺序存储实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10       <span class="comment">//定义栈中元素的最t大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>          </span><br><span class="line">    <span class="type">int</span> data[MaxSize];   <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top;             <span class="comment">//栈顶指针</span></span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SqStack &amp;S)</span>&#123;</span><br><span class="line">    S.top = <span class="number">-1</span>;          <span class="comment">//初始化栈顶指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(SqStack S)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新元素入栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(SqStack &amp;S,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==Maxsize<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">//栈满，报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    S.top = S.top+<span class="number">1</span>;     <span class="comment">//指针先加1</span></span><br><span class="line">    S.data[S.top] = x;   <span class="comment">//新元素入栈</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(SqStack &amp;S,<span class="type">int</span> &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">//栈空，报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    x =  S.data[S.top]   <span class="comment">//栈顶元素出栈</span></span><br><span class="line">    S.top = S.top<span class="number">-1</span>;     <span class="comment">//指针再减1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序栈大大小不可变，可以用共享栈的方式来提高空间的利用率</span></span><br><span class="line"><span class="comment">//共享栈会定义两个栈顶指针，一个初始为-1，另一个初始为MaxSize</span></span><br></pre></td></tr></table></figure><h3 id="1-4-栈的链式存储实现"><a href="#1-4-栈的链式存储实现" class="headerlink" title="1.4 栈的链式存储实现"></a>1.4 栈的链式存储实现</h3><p>链式存储实现的栈本质上就是一个单链表，只不过我们规定只允许在“单链表”的一端进行操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Struct Linknode *next;</span><br><span class="line">&#125;*Listack;</span><br></pre></td></tr></table></figure><h2 id="2-队列"><a href="#2-队列" class="headerlink" title="2.队列"></a>2.队列</h2><h3 id="2-1-队列的定义"><a href="#2-1-队列的定义" class="headerlink" title="2.1 队列的定义"></a>2.1 队列的定义</h3><p>队列（Queue）—是只允许在<strong>一端进行插入</strong>，<strong>另一端删除</strong>的线性表</p><p>（特性：<strong>先进先出</strong>）</p><p>空队列—队列中没有任何数据元素。</p><p>队头—<strong>允许删除</strong>的一端。</p><p>队尾—<strong>允许插入</strong>的一端。</p><h3 id="2-2-队列的基本操作"><a href="#2-2-队列的基本操作" class="headerlink" title="2.2 队列的基本操作"></a>2.2 队列的基本操作</h3><p><strong>InitQueue(&amp;Q)</strong>：初始化队列，构造一个空队列Q。</p><p><strong>DestroyQueue(&amp;Q)</strong>：销毁队列。销毁并释放队列Q所占用的内存空间。</p><p><strong>EnQueue(&amp;Q,x)</strong>：入队，若队列Q未满，将x加入，使之成为新的队尾。 </p><p><strong>DeQueue(&amp;Q,&amp;x)</strong>：出队，若队列Q非空，删除队头元素，并用x返回。</p><p><strong>GetHead(Q,&amp;x)</strong>：读队头元素，若队列Q非空，则将队头元素赋值给x。</p><p>其他常用操作： </p><p><strong>QueueEmpty(Q)</strong>：判队列空，若队列Q为空返回true，否则返回false。</p><h3 id="2-3-队列的顺序存储实现"><a href="#2-3-队列的顺序存储实现" class="headerlink" title="2.3 队列的顺序存储实现"></a>2.3 队列的顺序存储实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10       <span class="comment">//定义队列中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>          </span><br><span class="line">    <span class="type">int</span> dara[MaxSize];   <span class="comment">//静态数组存放队列元素</span></span><br><span class="line">    <span class="type">int</span> front,rear;      <span class="comment">//队头指针和队尾指针</span></span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue &amp;Q)</span>&#123;</span><br><span class="line">    Q.rear = <span class="number">0</span>;</span><br><span class="line">    Q.front = <span class="number">0</span>;         <span class="comment">//初始时，队头、队尾指针指向0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断对列是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">QueueEmpty</span><span class="params">(SqStack S)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(SqStack &amp;S,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MaxSize == Q.front)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;                 <span class="comment">//队满，报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    Q.data[Q.rear] = x;               <span class="comment">//将x插入队尾</span></span><br><span class="line">    Q.rear = (Q.rear+<span class="number">1</span>)%MaxSize;      <span class="comment">//队尾指针后移</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(SqStack &amp;S,<span class="type">int</span> &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">//队列空，报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    x = x.data[Q.front];</span><br><span class="line">    Q.front = (Q.front+<span class="number">1</span>)%MaxSize;    <span class="comment">//队头指针后移</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用“Q.front = (Q.front+1)%MaxSize”判断队列是否已满会牺牲一个存储空间</span></span><br><span class="line"><span class="comment">//解决办法：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种方法：在队列结构中定义size（初始为0，每次进队size++，出队size--）</span></span><br><span class="line"><span class="comment">//队满条件：size==MaxSize；队空条件：size==0; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方法：在队列结构中定义tag（每次删除操作成功时，都令tag=0； 每次插入操作成功时，都令tag=1）</span></span><br><span class="line"><span class="comment">//队满条件：front==rear&amp;&amp;tag==1；队空条件：front==rear&amp;&amp;tag==0 </span></span><br></pre></td></tr></table></figure><h3 id="2-4-队列的链式存储实现"><a href="#2-4-队列的链式存储实现" class="headerlink" title="2.4 队列的链式存储实现"></a>2.4 队列的链式存储实现</h3><p>队列和单链表相比，无非是在插入和删除操作中，它只能分别在队尾和队头进行，单链表的插入和删除却是可以在任何一个位置进行的，队列就相当于一个单链表的“阉割”版。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span>&#123;</span>     <span class="comment">//链式队列结点</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Struct Linknode *next;</span><br><span class="line">&#125;*LinkNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>              <span class="comment">//链式队列</span></span><br><span class="line">    LinkNode *front,*rear;   <span class="comment">//队列的队头和队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列（带头节点）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line">    <span class="comment">//初始时，front、rear都指向头节点 </span></span><br><span class="line">    Q.front=Q.rear=(LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断队列是否为空（带头节点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列（不带头节点）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line">    <span class="comment">//初始时，front、rear都指向NULL</span></span><br><span class="line">    Q.front=<span class="literal">NULL</span>；</span><br><span class="line">    Q.rear=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断队列是否为空（不带头节点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==<span class="literal">NULL</span>)&#123;   <span class="comment">//也可以判断Q.rear==NULL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新元素入队（带头节点）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    LinkNode *s=(LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next=s;   <span class="comment">//新结点插入到rear之后</span></span><br><span class="line">    Q.rear=s;         <span class="comment">//修改表尾指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新元素入队（不带头节点）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    LinkNode *s=(LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//不带头结点的队列，第一个元素入队需要特别处理</span></span><br><span class="line">    <span class="keyword">if</span>(Q.front==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        Q.front=s;</span><br><span class="line">        Q.rear=s;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Q.rear-&gt;next=s;</span><br><span class="line">    Q.rear=s;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队头元素出队（带头节点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q,<span class="type">int</span> &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;          <span class="comment">//判空</span></span><br><span class="line">    &#125;</span><br><span class="line">    LinkNode *p=Q.front-&gt;next;</span><br><span class="line">    x=p-&gt;data;                 <span class="comment">//用x返回队头元素</span></span><br><span class="line">    Q.front-&gt;next=p-&gt;next;     <span class="comment">//修改头结点的next指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear==p)&#123;             <span class="comment">//此次是最后一个结点出队</span></span><br><span class="line">        Q.rear=Q.front;        <span class="comment">//修改rear指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);                   <span class="comment">//释放结点空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//队头元素出队（不带头节点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q,<span class="type">int</span> &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;          <span class="comment">//判空</span></span><br><span class="line">    &#125;</span><br><span class="line">    LinkNode *p=Q.front;       <span class="comment">//p指向这次出队的结点</span></span><br><span class="line">    x=p-&gt;data;                 <span class="comment">//用x返回队头元素</span></span><br><span class="line">    Q.front=p-&gt;next;           <span class="comment">//修改front指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear==p)&#123;             <span class="comment">//此次是最后一个结点出队</span></span><br><span class="line">        Q.front=<span class="literal">NULL</span>;</span><br><span class="line">        Q.rear=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);                   <span class="comment">//释放结点空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-双端队列"><a href="#2-5-双端队列" class="headerlink" title="2.5 双端队列"></a>2.5 双端队列</h3><p>栈：只允许从<strong>一端插入和删除</strong>的线性表。</p><p>队列：只允许从<strong>一端插入</strong>、<strong>另一端删除</strong>的线性表。</p><p>双端队列：只允许从<strong>两端插入</strong>、<strong>两端删除</strong>的线性表。</p><p>另一方面，双端队列也可以衍生出其他变种</p><p><strong>输入受限</strong>的双端队列：只允许从<strong>一端插入</strong>、<strong>两端删除</strong>的线性表</p><p><strong>输出受限</strong>的双端队列：只允许从<strong>两端插入</strong>、<strong>一端删除</strong>的线性表</p><h2 id="3-栈的应用"><a href="#3-栈的应用" class="headerlink" title="3.栈的应用"></a>3.栈的应用</h2><h3 id="3-1-栈在括号匹配中的应用"><a href="#3-1-栈在括号匹配中的应用" class="headerlink" title="3.1 栈在括号匹配中的应用"></a>3.1 栈在括号匹配中的应用</h3><p>在写代码的过程中，代码中的()、[]、{}都是成双成对出现的，这就是所谓的括号匹配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(((((  )))))</span><br></pre></td></tr></table></figure><p>最后出现的左括号最先被匹配（与栈的先进后出异曲同工）</p><p> 思路：遇到左括号就入栈，遇到右括号就出栈（“消耗”一个左括号）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line">typrdef <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> data[MaxSize];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SqStack &amp;S)</span></span><br><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(SqStack S)</span></span><br><span class="line"><span class="comment">//新元素入栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(SqStack &amp;S,<span class="type">char</span> x)</span></span><br><span class="line"><span class="comment">//栈顶元素出栈，用x返回</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(SqStack &amp;S,<span class="type">char</span> &amp;x)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//括号匹配</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">bracketCheck</span><span class="params">(<span class="type">char</span> str[],<span class="type">int</span> length)</span>&#123;</span><br><span class="line">    SqStack S;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">&quot;(&quot;</span>||str[i]==<span class="string">&quot;[&quot;</span>||str[i]==<span class="string">&quot;&#123;&quot;</span>)&#123;</span><br><span class="line">            Push(S,str[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(StackEmpty(S))&#123;   <span class="comment">//扫描到右括号，且当前栈空</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">//匹配失败</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">char</span> topElem;</span><br><span class="line">            Pop(S,topElem);</span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">&#x27;)&#x27;</span> &amp;&amp; topElem!=<span class="string">&quot;(&quot;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">&#x27;]&#x27;</span> &amp;&amp; topElem!=<span class="string">&quot;[&quot;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; topElem!=<span class="string">&quot;&#123;&quot;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> StackEmpty(S);       <span class="comment">//检索完全部括号后，栈空说明匹配成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-栈在表达式求值中的应用"><a href="#3-2-栈在表达式求值中的应用" class="headerlink" title="3.2 栈在表达式求值中的应用"></a>3.2 栈在表达式求值中的应用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="number">15</span>/(<span class="number">7</span>-(<span class="number">1</span>+<span class="number">1</span>)))*<span class="number">3</span>)-(<span class="number">2</span>+(<span class="number">1</span>+<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>算术表达式由三个部分组成：操作数、运算符、界限符（必不可少）。</p><p>1924年，一个波兰的数学家突发奇想，可以不用界限符也能无歧义地表达运算顺序。</p><p>也就是 Reverse Polish notation（逆波兰表达式&#x3D;后缀表达式）和 Polish notation（波兰表达式&#x3D;前缀表达式）。</p><p><strong>中缀</strong>表达式：运算符在两个操作数中间，例如：a+b</p><p><strong>后缀</strong>表达式：运算符在两个操作数的后面，例如：ab+</p><p><strong>前缀</strong>表达式：运算符在两个操作数的前面，例如：+ab</p><h4 id="3-2-1-后缀表达式"><a href="#3-2-1-后缀表达式" class="headerlink" title="3.2.1 后缀表达式"></a>3.2.1 后缀表达式</h4><h5 id="（1）中缀转后缀"><a href="#（1）中缀转后缀" class="headerlink" title="（1）中缀转后缀"></a>（1）中缀转后缀</h5><ul><li>中缀转后缀的<strong>手算</strong>方法：</li></ul><p>① 确定中缀表达式中各个运算符的运算顺序</p><p>② 选择下一个运算符，按照「左操作数 右操作数 运算符」的方式组合成一个新的操作数</p><p>③ 如果还有运算符没被处理，就继续 ②</p><p>【为保证运算顺序唯一，建议采用**“左优先”原则**—只要左边的运算符能先计算，就优先算左边的】 </p><ul><li>中缀转后缀的<strong>机算</strong>方法：</li></ul><p>初始化一个栈，用于保存暂时还不能确定运算顺序的运算符。 </p><p>从左到右处理各个元素，直到末尾。</p><p>可能遇到三种情况：</p><p>① 遇到操作数。直接加入后缀表达式。</p><p>② 遇到界限符。遇到“(”直接入栈；</p><p>遇到“)”则依次弹出栈内运算符并加入后缀表达式，直到 弹出“(”为止。</p><p>注意：“(”和”)“不加入后缀表达式。</p><p>③ 遇到运算符。依次弹出栈中优先级<strong>高于或等于</strong>当前运算符的所有运算符，并加入后缀表达式， 若碰到“(” 或栈空则停止。之后再把当前运算符入栈。</p><p>按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。</p><h5 id="（2）后缀表达式的计算"><a href="#（2）后缀表达式的计算" class="headerlink" title="（2）后缀表达式的计算"></a>（2）后缀表达式的计算</h5><ul><li>后缀表达式的<strong>手算</strong>方法：</li></ul><p>从左往右扫描，每遇到一个运算符，就让<strong>运算符前面最近的两个操作数</strong>执行对应运算， 合体为一个操作数</p><p>【注意两个操作数的左右顺序】</p><ul><li>后缀表达式的<strong>机算</strong>方法</li></ul><p>最后出现的操作数先被运算，与栈的后进先出的特性吻合。</p><p>用<strong>栈</strong>实现后缀表达式的计算：</p><p>①从左往右扫描下一个元素，直到处理完所有元素</p><p>②若扫描到操作数则压入栈，并回到①；否则执行③</p><p>③若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到①</p><p>【注意先出栈的是“右操作数”】</p><h4 id="3-2-2-前缀表达式"><a href="#3-2-2-前缀表达式" class="headerlink" title="3.2.2 前缀表达式"></a>3.2.2 前缀表达式</h4><h5 id="（1）-中缀转前缀"><a href="#（1）-中缀转前缀" class="headerlink" title="（1） 中缀转前缀"></a>（1） 中缀转前缀</h5><ul><li>中缀转前缀的<strong>手算</strong>方法：</li></ul><p>① 确定中缀表达式中各个运算符的运算顺序</p><p>② 选择下一个运算符，按照「运算符 左操作数 右操作数」的方式组合成一个新的操作数</p><p>③ 如果还有运算符没被处理，就继续 ②</p><p>【<strong>“右优先”原则</strong>：只要右边的运算符能先计算，就优先算右边的】</p><ul><li>中缀转前缀的<strong>机算</strong>方法：</li></ul><p>初始化两个栈，分别用于保存暂时还不能确定运算顺序的运算符S1和中间结果S2。 </p><p>从右往左处理各个元素，直到末尾。</p><p>可能遇到三种情况：</p><p>① 遇到操作数。直接入S2栈。</p><p>② 遇到界限符。遇到“)”直接入S1栈；</p><p>遇到“(”则依次弹出S1栈顶运算符并加入S2栈，直到遇到“)”为止。</p><p>注意：“(”和”)“不加入前缀表达式。</p><p>③ 遇到运算符。依次弹出S1栈中优先级<strong>高于</strong>当前运算符的所有运算符，并加入S2栈， 若碰到“)” 或栈S1空则停止。之后再把当前运算符入栈S1。</p><p>按上述方法处理完所有字符后，将S1栈中剩余运算符依次弹出，并加入S2栈，最后在依次弹出S2栈的元素并输出，加入前缀表达式。</p><h5 id="（2）-前缀表达式的计算"><a href="#（2）-前缀表达式的计算" class="headerlink" title="（2） 前缀表达式的计算"></a>（2） 前缀表达式的计算</h5><ul><li>前缀表达式的<strong>手算</strong>方法</li></ul><p><strong>从右往左</strong>扫描，每遇到一个运算符，就让<strong>运算符后面最近的两个操作数</strong>执行对应运算， 合体为一个操作数</p><p>【注意两个操作数的左右顺序】</p><ul><li>前缀表达式的<strong>机算</strong>方法</li></ul><p>用<strong>栈</strong>实现前缀表达式的计算： </p><p>①<strong>从右往左</strong>扫描下一个元素，直到处理完所有元素</p><p>②若扫描到操作数则压入栈，并回到①；否则执行③</p><p>③若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到①</p><p>【注意先出栈的 是“左操作数“】</p><h4 id="3-2-3-中缀表达式"><a href="#3-2-3-中缀表达式" class="headerlink" title="3.2.3 中缀表达式"></a>3.2.3 中缀表达式</h4><h5 id="（1）-中缀表达式的计算"><a href="#（1）-中缀表达式的计算" class="headerlink" title="（1） 中缀表达式的计算"></a>（1） 中缀表达式的计算</h5><ul><li>中缀表达式的<strong>手算</strong></li></ul><p>中缀表达式是人们常用的算术表示方法，手算方法不再赘述。</p><ul><li>中缀表达式的<strong>机算</strong></li></ul><p>初始化两个栈，操作数栈和运算符栈。</p><p>从左往右依次处理各个元素，直到末尾。</p><p>①若扫描到操作数，压入操作数栈</p><p>②若扫描到运算符或界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈</p><p>（期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈）</p><h3 id="3-3-栈在递归中的应用"><a href="#3-3-栈在递归中的应用" class="headerlink" title="3.3 栈在递归中的应用"></a>3.3 栈在递归中的应用</h3><p>递归算法就是递归函数调用自身的过程。在递归过程中，<strong>最后被调用的函数最先执行结束</strong>，和栈的后进先出类似。</p><p>适合用”递归“算法解决：可以把原始问题转换为<strong>属性相同，但规模较小</strong>的问题，例如阶乘、斐波那契数列······</p><p>函数调用时，需要用<strong>一个栈</strong>存储： </p><p>① 调用返回地址</p><p>② 实参</p><p>③ 局部变量</p><p>递归调用时，<strong>函数调用栈</strong>可称为“递归工作栈”</p><p>每进入一层递归，就将递归调用所需信息压入栈顶</p><p>每退出一层递归，就从栈顶弹出相应信息</p><p>缺点：效率低，太多层递归可能会导致栈溢出；可能包含很多重复计算</p><h2 id="4-队列的应用"><a href="#4-队列的应用" class="headerlink" title="4.队列的应用"></a>4.队列的应用</h2><p>队列应用——<strong>树的层次遍历</strong></p><p>在后面”树“的笔记里会详细介绍</p><p>队列应用——<strong>图的广度优先遍历</strong></p><p>在后面”图“的笔记里会详细介绍</p><p>队列在<strong>操作系统</strong>中的应用</p><p>多个进程争抢着使用有限的系统资源时，FCFS（FirstComeFirstService，先来先服务—可用队列实现）是一种常用策略。</p><p>例如：CPU资源的分配，打印数据缓冲区</p><h2 id="5-特殊矩阵的压缩存储"><a href="#5-特殊矩阵的压缩存储" class="headerlink" title="5.特殊矩阵的压缩存储"></a>5.特殊矩阵的压缩存储</h2><h3 id="5-1-数据的存储结构"><a href="#5-1-数据的存储结构" class="headerlink" title="5.1 数据的存储结构"></a>5.1 数据的存储结构</h3><p>一维数组——各数组元素大小相同，且物理上连续存放。</p><p>二维数组——”行优先“存储和”列优先“存储 </p><h3 id="5-2-特殊矩阵"><a href="#5-2-特殊矩阵" class="headerlink" title="5.2 特殊矩阵"></a>5.2 特殊矩阵</h3><p>普通矩阵的存储——可以用二维数组存储。</p><p>某些特殊矩可以压缩存储空间。</p><h4 id="5-2-1-对称矩阵"><a href="#5-2-1-对称矩阵" class="headerlink" title="5.2.1 对称矩阵"></a>5.2.1 对称矩阵</h4><p>对阵矩阵：n阶<strong>方阵</strong>中任意一个元素a(i,j)&#x3D;a(j,i)</p><p>压缩存储策略：只存储主对角线+下三角区 （或主对角线+上三角区），按行优先（或列优先）原则将各元素存入一维数组中。</p><p>站在程序员的角度，为了方便使用，可以实现一个**“映射”函数**。</p><p>（矩阵下标—&gt;一维数组下标）</p><h4 id="5-2-2-三角矩阵"><a href="#5-2-2-三角矩阵" class="headerlink" title="5.2.2 三角矩阵"></a>5.2.2 三角矩阵</h4><p>下三角矩阵：除了主对角线和下三角区，其余的元素都相同</p><p>上三角矩阵：除了主对角线和上三角区，其余的元素都相同</p><p>压缩存储策略：与对称矩阵类似，行优先（或列优先）原则将主对角线和下（上）三角区存入一维数组中，并在最后一个位置存储常量c</p><h4 id="5-2-3-三对角矩阵"><a href="#5-2-3-三对角矩阵" class="headerlink" title="5.2.3 三对角矩阵"></a>5.2.3 三对角矩阵</h4><p>三对角矩阵，又称带状矩阵： 当|i-j|&gt;1时，有a(i,j)&#x3D;0 （1≤i,j≤n）</p><p>压缩存储策略： 按行优先（或列优先）原则，只存储带状部分</p><h4 id="5-2-4-稀疏矩阵"><a href="#5-2-4-稀疏矩阵" class="headerlink" title="5.2.4 稀疏矩阵"></a>5.2.4 稀疏矩阵</h4><p>稀疏矩阵：非零元素远远少于矩阵元素的个数</p><p>压缩存储策略：</p><p>①顺序存储——三元组&lt;行，列，值&gt;</p><p>②链式存储——十字链表法</p><h1 id="第四章：串"><a href="#第四章：串" class="headerlink" title="第四章：串"></a>第四章：串</h1><h2 id="1-串的定义和基本操作"><a href="#1-串的定义和基本操作" class="headerlink" title="1.串的定义和基本操作"></a>1.串的定义和基本操作</h2><h3 id="1-1-串的定义"><a href="#1-1-串的定义" class="headerlink" title="1.1 串的定义"></a>1.1 串的定义</h3><p><strong>串</strong>，即<strong>字符串</strong>（String）是由零个或多个<strong>字符</strong>组成的有限序列。</p><p>一些术语：</p><p>子串： 串中任意个连续的字符组成的子序列。 </p><p>主串： 包含子串的串。</p><p>字符在主串中的位置： 字符在串中的序号（从1开始计数）。</p><p>子串在主串中的位置： 子串的第一个字符在主串中的位置 。 </p><h3 id="1-2-串的基本操作"><a href="#1-2-串的基本操作" class="headerlink" title="1.2 串的基本操作"></a>1.2 串的基本操作</h3><p>串是一种特殊的线性表，数据元素之间呈线性关系。</p><p>串的数据对象限定为字符集（如中文字符、英文字符、数字字符、标点字符等）。</p><p>串的基本操作，如增删改查等<strong>通常以子串为操作对象</strong>。</p><p>StrAssign(&amp;T,chars)：赋值操作。把串T赋值为chars。 </p><p>StrCopy(&amp;T,S)：复制操作。由串S复制得到串T。</p><p>StrEmpty(S)：判空操作。若S为空串，则返回TRUE，否则返回FALSE。 </p><p>StrLength(S)：求串长。返回串S的元素个数。</p><p>ClearString(&amp;S)：清空操作。将S清为空串。 </p><p>DestroyString(&amp;S)：销毁串。将串S销毁（回收存储空间）。 </p><p>Concat(&amp;T,S1,S2)：串联接。用T返回由S1和S2联接而成的新串 </p><p>SubString(&amp;Sub,S,pos,len)：求子串。用Sub返回串S的第pos个字符起长度为len的子串。</p><p>StrCompare(S,T)：比较操作。若S&gt;T，则返回值&gt;0；若S&#x3D;T，则返回值&#x3D;0；若S&lt;T，则返回值&lt;0。 </p><p>Index(S,T)：定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的 位置；否则函数值为0。 </p><h2 id="2-串的存储结构"><a href="#2-串的存储结构" class="headerlink" title="2.串的存储结构"></a>2.串的存储结构</h2><h3 id="2-1-串的顺序存储"><a href="#2-1-串的顺序存储" class="headerlink" title="2.1 串的顺序存储"></a>2.1 串的顺序存储</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch[MAXSIZE];   <span class="comment">//静态数组实现（定长顺序存储）</span></span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *ch;           <span class="comment">//动态数组实现（堆分配存储）</span></span><br><span class="line">    <span class="type">int</span> length; </span><br><span class="line">&#125;HString;</span><br><span class="line">Hstring s;</span><br><span class="line">S.ch = (<span class="type">char</span> *)<span class="built_in">malloc</span>(MAXSIZE * <span class="keyword">sizeof</span>(<span class="type">char</span>));  <span class="comment">//用完需要手动free</span></span><br><span class="line">S.length = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="2-2-串的链式存储"><a href="#2-2-串的链式存储" class="headerlink" title="2.2 串的链式存储"></a>2.2 串的链式存储</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">typedef struct StringNode&#123;</span></span><br><span class="line"><span class="comment">    char ch;</span></span><br><span class="line"><span class="comment">    int StringNode *next;</span></span><br><span class="line"><span class="comment">&#125;StringNode,*String;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">char一个字符只占1个字节，在32位电脑中，指针占4个字节。</span></span><br><span class="line"><span class="comment">这意味着你用1个字节存储你想要的信息，用4个字节来存储辅助信息，这种情况称之为存储密度低，所以不太建议采用这种方式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//每个结点存储多个字节，为了避免存储密度低</span></span><br><span class="line">    <span class="comment">//如果某些结点填不满，可以用特殊字符填充，例如&#x27;#&#x27;，&#x27;\0&#x27;</span></span><br><span class="line">    <span class="type">char</span> ch[<span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> StringNode *next;</span><br><span class="line">&#125;StringNode,*String;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-3-基本操作的实现"><a href="#2-3-基本操作的实现" class="headerlink" title="2.3 基本操作的实现"></a>2.3 基本操作的实现</h3><p>以<strong>顺序存储</strong>的<strong>动态数组</strong>实现的串为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *ch;   <span class="comment">//动态数组实现（堆分配存储）</span></span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;HString;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值操作。把串T赋值为chars。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">StrAssign</span><span class="params">(HString &amp;T, <span class="type">char</span> chars[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;*(chars+i);i++);</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">        T.ch = <span class="literal">NULL</span>;</span><br><span class="line">        T.length = <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        T.ch = (<span class="type">char</span> *)<span class="built_in">malloc</span>(i*<span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        <span class="keyword">if</span>(!T.ch)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; i;j++)&#123;</span><br><span class="line">                *(T.ch+j) = *(chars+j);</span><br><span class="line">            &#125;</span><br><span class="line">            T.length = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制操作。由串S复制得到串T。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StringCopy</span><span class="params">(HString &amp;T, HString &amp;S)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T.ch)&#123;</span><br><span class="line">        <span class="built_in">free</span>(T.ch);</span><br><span class="line">        T.ch = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T.length = <span class="number">0</span>;</span><br><span class="line">    T.ch = (<span class="type">char</span> *)<span class="built_in">malloc</span>(S.length*<span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S.length; i++)&#123;</span><br><span class="line">T.ch[i] = S.ch[i];</span><br><span class="line">&#125;</span><br><span class="line">T.length = S.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空操作。若S为空串，则返回TRUE，否则返回FALSE。</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StrEmpty</span><span class="params">(HString &amp;S)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!S.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求串长。返回串S的元素个数。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">StrLength</span><span class="params">(HString &amp;S)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空操作。将S清为空串。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ClearString</span><span class="params">(HString &amp;S)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.ch)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(s.ch);</span><br><span class="line">        s.ch = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s.length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁串。将串S销毁（回收存储空间）。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyString</span><span class="params">(HString &amp;S)</span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(s.ch);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//串联接。用T返回由S1和S2联接而成的新串</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Concat</span><span class="params">(HString &amp;T,HString s1,HString s2)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">if</span>(T.ch)&#123;</span><br><span class="line"><span class="built_in">free</span>(T.ch); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!(T.ch = (<span class="type">char</span>*)<span class="built_in">malloc</span>((s1.length + s2.length)*<span class="keyword">sizeof</span>(<span class="type">char</span>))))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T.length = s1.length + s2.length;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; s1.length;i++)&#123;</span><br><span class="line">        *(T.ch+i) = *(s1.ch+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; s2.length;j++)&#123;</span><br><span class="line">           *(T.ch+s1.length+j) = *(s2.ch + j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//求子串。用Sub返回串S的第pos个字符起长度为len的子串。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">SubString</span><span class="params">(HString &amp;Sub,HString S,<span class="type">int</span> pos,<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">0</span> || len &gt; S.length ||pos &lt; <span class="number">1</span>  || pos &gt; S.length-pos+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">        Sub.ch = <span class="literal">NULL</span>;</span><br><span class="line">        Sub.length = <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Sub.ch = (<span class="type">char</span> *)<span class="built_in">malloc</span>(len *<span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            *(Sub.ch+i) = *(S.ch+pos+i<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Sub.length = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较操作。若S&gt;T，则返回值&gt;0；若S=T，则返回值=0；若S&lt;T，则返回值&lt;0。 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">StrCompare</span><span class="params">(HString S,HString T)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; S.length &amp;&amp; i &lt; T.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i]!=T.ch[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> S.ch[i]-T.ch[i];</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;       </span><br><span class="line">    <span class="keyword">return</span> S.length-T.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为-1。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(HString S,HString T)</span>&#123;</span><br><span class="line">    HString a;</span><br><span class="line">    <span class="type">int</span> m = S.length;</span><br><span class="line">    <span class="type">int</span> n = T.length;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=m-n+<span class="number">1</span>)&#123;</span><br><span class="line">        SubString(sub,S,i,n);</span><br><span class="line">        <span class="keyword">if</span>(StrCompare(sub,T)!=<span class="number">0</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-字符串模式匹配"><a href="#3-字符串模式匹配" class="headerlink" title="3.字符串模式匹配"></a>3.字符串模式匹配</h2><p>⼦串——主串的⼀部分，⼀定存在</p><p>模式串——不⼀定能在主串中找到</p><p><strong>字符串模式匹配</strong>：在主串中找到与模式串相同的⼦串，并返回其所在位置。</p><h3 id="3-1-朴素模式匹配算法"><a href="#3-1-朴素模式匹配算法" class="headerlink" title="3.1 朴素模式匹配算法"></a>3.1 朴素模式匹配算法</h3><p>主串⻓度为n，模式串⻓度为 m </p><p>朴素模式匹配算法：将主串中<strong>所有⻓度为m的⼦串</strong>依次与模式串对⽐，直到找到⼀个完全匹配的⼦串， 或所有的⼦串都不匹配为⽌。 </p><p>【最多对⽐ n-m+1 个⼦串】</p><p>之前介绍过的<strong>串的定位操作</strong>其实已经实现了朴素模式的算法匹配，不过我们使用了两个字符串的基本操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为-1。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(HString S,HString T)</span>&#123;</span><br><span class="line">    HString a;</span><br><span class="line">    <span class="type">int</span> n = S.length;</span><br><span class="line">    <span class="type">int</span> m = T.length;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n-m+<span class="number">1</span>)&#123;   <span class="comment">//最多对⽐ n-m+1 个⼦串</span></span><br><span class="line">        <span class="comment">//取出从位置i开始，⻓度为m的⼦串</span></span><br><span class="line">        SubString(sub,S,i,n);</span><br><span class="line">        <span class="comment">//⼦串和模式串对⽐，若不匹配，则匹配下⼀个⼦串 </span></span><br><span class="line">        <span class="keyword">if</span>(StrCompare(sub,T)!=<span class="number">0</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们不使⽤字符串的基本操作，直接通过数组下标实现朴素模式匹配算法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(HString S,HString T)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;S.length &amp;&amp; j&lt;T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i]==T.ch[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i=i-j+<span class="number">1</span>;</span><br><span class="line">            j=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;=T.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> i-T.length+<span class="number">1</span>;     <span class="comment">//+1是因为返回的是位置而不是下标</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-KMP算法"><a href="#3-2-KMP算法" class="headerlink" title="3.2.KMP算法"></a>3.2.KMP算法</h3><p>KMP算法是由朴素模式匹配算法优化而来的。</p><p>由D.E.<strong>K</strong>nuth，J.H.<strong>M</strong>orris和V.R.<strong>P</strong>ratt提出，因此称为<strong>KMP</strong>算法。</p><p>根据模式串T，求出 next 数组，然后利⽤next数组进⾏匹配 （主串指针不回溯）。</p><p>【当模式串T(j)字符匹配失败时，令模式串的指针j&#x3D;next(j)，继续往后匹配】</p><h4 id="3-2-1-手算next数组"><a href="#3-2-1-手算next数组" class="headerlink" title="3.2.1 手算next数组"></a>3.2.1 手算next数组</h4><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模式串T（第一行数组下标j，第二行内容T(j)）</span></span><br><span class="line"><span class="number">0</span><span class="number">1</span><span class="number">2</span><span class="number">3</span><span class="number">4</span><span class="number">5</span><span class="number">6</span><span class="number">7</span></span><br><span class="line">ABABAAAB</span><br></pre></td></tr></table></figure><p>如果模式串T(0)不匹配，找前面公共前后缀（无字符），将模式串T(0)与主串的下一位进行匹配</p><p>如果模式串T(1)不匹配，找前面公共前后缀（A，长度0），将模式串T(0)与主串当前位置进行匹配</p><p>如果模式串T(2)不匹配，找前面公共前后缀（AB，长度0），将模式串T(0)与主串当前位置进行匹配</p><p>如果模式串T(3)不匹配，找前面公共前后缀（ABA，长度1），将模式串T(1)与主串当前位置进行匹配</p><p>如果模式串T(4)不匹配，找前面公共前后缀（ABAB，长度1），将模式串T(2)与主串当前位置进行匹配</p><p>如果模式串T(5)不匹配，找前面公共前后缀（ABABA，长度3），将模式串T(3)与主串当前位置进行匹配</p><p>如果模式串T(6)不匹配，找前面公共前后缀（ABABAA，长度1），将模式串T(1)与主串当前位置进行匹配</p><p>如果模式串T(7)不匹配，找前面公共前后缀（ABABAAA，长度1），将模式串T(1)与主串当前位置进行匹配</p><p>所以求出next数组的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//next[]数组（第一行数组下标，第二行内容）</span></span><br><span class="line"><span class="number">0</span><span class="number">1</span><span class="number">2</span><span class="number">3</span><span class="number">4</span><span class="number">5</span><span class="number">6</span><span class="number">7</span></span><br><span class="line"><span class="number">-1</span><span class="number">0</span><span class="number">0</span><span class="number">1</span><span class="number">2</span><span class="number">3</span><span class="number">1</span><span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="3-2-2-完整代码"><a href="#3-2-2-完整代码" class="headerlink" title="3.2.2 完整代码"></a>3.2.2 完整代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由模式串t求出next值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetNext</span><span class="params">(HString t,<span class="type">int</span> next[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">-1</span>;</span><br><span class="line">next[<span class="number">0</span>]=<span class="number">-1</span>;   <span class="comment">//第一个字符前无字符串，给值-1</span></span><br><span class="line"><span class="keyword">while</span> (j&lt;t.length<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="comment">//因为next数组中j最大为t.length-1,而每一步next数组赋值都是在j++之后</span></span><br><span class="line"><span class="comment">//所以最后一次经过while循环时j为t.length-2</span></span><br><span class="line"><span class="keyword">if</span> (k==<span class="number">-1</span> || t.ch[j]==t.ch[k])&#123;   <span class="comment">////k为-1或比较的字符相等时</span></span><br><span class="line">j++;k++;</span><br><span class="line">next[j]=k;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">k=next[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index_KMP</span><span class="params">(HString S,HString T,<span class="type">int</span> next[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;S.length &amp;&amp; j&lt;T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">-1</span>||S.ch[i]==T.ch[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];           <span class="comment">//匹配失败时，主串指针i不回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;=T.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> i-T.length+<span class="number">1</span>;     <span class="comment">//+1是因为返回的是位置而不是下标</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第五章：树"><a href="#第五章：树" class="headerlink" title="第五章：树"></a>第五章：树</h1><h2 id="1-树"><a href="#1-树" class="headerlink" title="1.树"></a>1.树</h2><h3 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h3><p>树是n（n≥0）个<strong>结点</strong>的有限集合，n&#x3D; 0时，称为<strong>空树</strong>，这是一种特殊情况。</p><p>在任意一棵非空树中应满足：</p><p>①有且仅有一个特定的称为<strong>根</strong>的结点。</p><p>②当n&gt; 1时，其余结点可分为m（m&gt; 0）个<strong>互不相交的有限集合</strong>T1, T2,…, Tm，其中每个集合本身又是一棵树，并且称为根结点的<strong>子树</strong>。</p><h3 id="1-2-基本术语"><a href="#1-2-基本术语" class="headerlink" title="1.2 基本术语"></a>1.2 基本术语</h3><ul><li>结点之间的<strong>关系描述</strong></li></ul><p>祖先结点：从一个结点出发，一直往上走，直至根节点，这条路上所有的结点都是该结点的祖先结点。</p><p>子孙结点：从一个结点出发，它的所有分支都是该结点的子孙结点。</p><p>双亲结点（父节点）：一个结点的直接前驱就是双亲结点（父节点）。</p><p>孩子结点：一个结点的直接后继就是孩子结点。</p><p>兄弟结点：双亲结点（父节点）相同的结点互为兄弟结点。</p><p>堂兄弟结点：<strong>同一层</strong>的不是兄弟结点的结点。</p><p>两个结点之间的路径：路径是单向（自上往下）的。</p><p>路径长度：经过了几条边。</p><ul><li>结点、树的<strong>属性描述</strong></li></ul><p>结点的层次（深度）：从上往下数（默认从1开始，但也有些教材是从0开始）</p><p>结点的高度：从下往上数</p><p>树的高度（深度）：总共多少层</p><p><strong>结点的度</strong>：有几个孩子（分支）</p><p><strong>树的度</strong>：各结点的度的最大值</p><ul><li><strong>有序树</strong>、<strong>无序树</strong></li></ul><p>有序树：逻辑上看，树中结点的各子树从左至右是<strong>有次序</strong>的，<strong>不能互换</strong>。</p><p>无序树：逻辑上看，树中结点的各子树从左至右是<strong>无次序</strong>的，<strong>可以互换</strong>。</p><ul><li><strong>森林</strong></li></ul><p>森林：森林是m（m≥0）棵互不相交的树的集合</p><h3 id="1-3-树的性质"><a href="#1-3-树的性质" class="headerlink" title="1.3 树的性质"></a>1.3 树的性质</h3><p>①结点数&#x3D;总度数+1</p><p>结点的度：结点有几个孩子（分支）</p><p>②度为m的树、m叉树的区别</p><p>树的度：各结点的度的最大值</p><p>m叉树：每个结点最多只能有m个孩子的树</p><table><thead><tr><th align="center">度为m的树</th><th align="center">m叉树</th></tr></thead><tbody><tr><td align="center">任意结点的度≤m（最多m个孩子）</td><td align="center">任意结点的度≤m（最多m个孩子）</td></tr><tr><td align="center">至少有一个结点度&#x3D;m（有m个孩子）</td><td align="center">允许所有结点的度都 ＜m</td></tr><tr><td align="center">一定是非空树，至少有m+1个结点</td><td align="center">可以是空树</td></tr></tbody></table><p>③度为m的树第i层至多有m^(i-1)个结点（i≥1）;</p><p>​m叉树第i层至多有m^(i-1)个结点（i≥1）。</p><p>④高度为h的m叉树至多有(m^h-1)&#x2F;(m-1)个结点</p><p>⑤高度为h的m叉树至少有h个结点；</p><p>​高度为h、度为m的树至少有h+m-1个结点。</p><p>⑥具有n个结点的m叉树的最小高度为<br>$$<br>[log_m(n(m-1)+1)]<br>$$<br>​高度最小的情况——所有结点都有m个孩子 </p><h2 id="2-二叉树"><a href="#2-二叉树" class="headerlink" title="2.二叉树"></a>2.二叉树</h2><h3 id="2-1-定义和基本术语"><a href="#2-1-定义和基本术语" class="headerlink" title="2.1 定义和基本术语"></a>2.1 定义和基本术语</h3><p>二叉树是n（n≥0）个结点的有限集合： </p><p>① 或者为空二叉树，即n&#x3D; 0。</p><p>② 或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树。 </p><p>特点：每个结点<strong>至多</strong>只有两棵子树；左右子树不能颠倒（二叉树是有序树）</p><p>二叉树的<strong>五种状态</strong>：空二叉树；只有左子树；只有右子树；左右子树都有；只有根结点。</p><p><strong>特殊的二叉树</strong>：</p><p><strong>满二叉树</strong>：一棵高度为h，且含有2^h - 1个结点的二叉树</p><blockquote><p>特点： </p><p>①只有最后一层有叶子结点</p><p>②不存在度为1的结点</p><p>③按层序从1开始编号，结点i的左孩子为2i，右孩 子为2i+1；结点i的父节点为𝑖&#x2F;2（如果有的话）</p></blockquote><p><strong>完全二叉树</strong>：当且仅当其每个结点都与高度为h的 满二叉树中编号为1～n的结点一一对应时，称为 完全二叉树</p><blockquote><p>特点： </p><p>①只有最后两层可能有叶子结点</p><p>②最多只有一个度为1的结点</p><p>③按层序从1开始编号，结点i的左孩子为2i，右孩 子为2i+1；结点i的父节点为𝑖&#x2F;2（如果有的话）</p><p>④i≤ 𝑛&#x2F;2为分支结点，i&gt;𝑛&#x2F;2为叶子结点</p></blockquote><p><strong>二叉排序树</strong>：一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树</p><blockquote><p>左子树上所有结点的关键字均小于根结点的关键字； </p><p>右子树上所有结点的关键字均大于根结点的关键字。 </p><p>左子树和右子树又各是一棵二叉排序树。</p></blockquote><p><strong>平衡二叉树</strong>：树上任一结点的左子树和右子树的深度之差不超过1。</p><blockquote><p>平衡二叉树能有更高的搜索效率</p></blockquote><h3 id="2-2-性质"><a href="#2-2-性质" class="headerlink" title="2.2 性质"></a>2.2 性质</h3><p><strong>二叉树</strong>：</p><p>①设非空二叉树中度为0、1和2的结点个数分别为n0、n1和n2， 则 n0 &#x3D; n2 + 1 </p><p>（叶子结点比二分支结点多一个）</p><p>②二叉树第i层至多有2^(i-1)个结点（i≥1）</p><p>​m叉树第i层至多有m^(i-1)个结点（i≥1）</p><p>③高度为h的二叉树至多有2^h−1个结点（满二叉树）</p><p>​高度为h的m叉树至多有(m^h-1)&#x2F;(m-1)个结点</p><p><strong>完全二叉树</strong>：</p><p>①具有n个（n &gt; 0）结点的完全二叉树的高度h为<br>$$<br>[log_2(n+1)] 或 [log_2n]+1<br>$$<br>②对于完全二叉树，可以由的结点数n推出度为0、1和2的结点个数为n0、n1和n2</p><p>【突破点：完全二叉树最多只会有一个度为1的结点】</p><p>若完全二叉树有2k个（偶数）个结点，则必有n1&#x3D;1，n0&#x3D;k，n2&#x3D;k-1</p><p>若完全二叉树有2k-1个（奇数）个结点，则必有n1&#x3D;0，n0&#x3D;k，n2&#x3D;k-1</p><h3 id="2-3-存储结构"><a href="#2-3-存储结构" class="headerlink" title="2.3 存储结构"></a>2.3 存储结构</h3><h4 id="2-3-1-顺序存储"><a href="#2-3-1-顺序存储" class="headerlink" title="2.3.1 顺序存储"></a>2.3.1 顺序存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> value;     <span class="comment">//结点的数据元素</span></span><br><span class="line">    <span class="type">bool</span> isEmpty;  <span class="comment">//结点是否为空</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode t[MaxSize];</span><br><span class="line"><span class="comment">//定义一个长度为MaxSize的数组t</span></span><br><span class="line"><span class="comment">//按照从上至下、从左至右的顺序依次存储完全二叉树中的各个结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MaxSize;i++)&#123;</span><br><span class="line">    t[i].isEmpty = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化时所有 结点标记为空</span></span><br></pre></td></tr></table></figure><h4 id="2-3-2-链式存储"><a href="#2-3-2-链式存储" class="headerlink" title="2.3.2 链式存储"></a>2.3.2 链式存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;                            <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>      <span class="comment">//左、右孩子指针</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一棵空树</span></span><br><span class="line">BiTree root = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入根节点</span></span><br><span class="line">root = (BiTree)<span class="built_in">malloc</span>(sizzeof(BiTNode))</span><br><span class="line">root-&gt;data=&#123;<span class="number">1</span>&#125;;</span><br><span class="line">root-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">root-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入新结点</span></span><br><span class="line">BiTNode *p=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">p-&gt;data=&#123;<span class="number">2</span>&#125;;</span><br><span class="line">p-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">root-&gt;lchild = p;  <span class="comment">//作为根节点的左孩子</span></span><br></pre></td></tr></table></figure><p>在这个链表中，找到指定结点的左&#x2F;右孩子很简单，但要找到指定结点的父结点就只能从根节点开始遍历。</p><p>为了方便查找父亲结点，我们可以在结构体中定义一个父节点指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BitNode</span> *<span class="title">parent</span>;</span>              <span class="comment">//父节点指针</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure><p>这个就被称为三叉链表。</p><h3 id="2-4-二叉树的先中后序遍历"><a href="#2-4-二叉树的先中后序遍历" class="headerlink" title="2.4 二叉树的先中后序遍历"></a>2.4 二叉树的先中后序遍历</h3><p><strong>先</strong>序遍历：<strong>根</strong> 左 右</p><p><strong>中</strong>序遍历：左 <strong>根</strong> 右</p><p><strong>后</strong>序遍历：左 右 <strong>根</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        visit(T);<span class="comment">//访问根节点</span></span><br><span class="line">        PreOrder(T-&gt;lchild);</span><br><span class="line">        PreOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        visit(T);</span><br><span class="line">        InOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        PostOrder(T-&gt;lchild);</span><br><span class="line">        PostOrder(T-&gt;rchild);</span><br><span class="line">        visit(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小应用</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求树的深度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">treeDepth</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> l = treeDepth(T-&gt;lchild);</span><br><span class="line">        <span class="type">int</span> r = treeDepth(T-&gt;rchild);</span><br><span class="line">        <span class="keyword">return</span> l&gt;r ? l+<span class="number">1</span> : r+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-二叉树的层次遍历"><a href="#2-5-二叉树的层次遍历" class="headerlink" title="2.5 二叉树的层次遍历"></a>2.5 二叉树的层次遍历</h3><p>算法思想：</p><ul><li><p>初始化一个辅助队列</p></li><li><p>根节点入队</p></li><li><p>若队列非空，则对头结点出队，访问该结点，并将其左、右孩子插入队尾（如果有）</p></li><li><p>重复上一步，直至队列为空</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式队列结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    BiTNode* data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    LinkNode *front,*rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层次遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    BiTree p;</span><br><span class="line">    EnQueue(Q,T);</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">        DeQueue(Q,P);</span><br><span class="line">        visit(p);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild!=<span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(Q,p-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(Q,p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-线索二叉树"><a href="#3-线索二叉树" class="headerlink" title="3.线索二叉树"></a>3.线索二叉树</h2><h3 id="3-1-二叉树的线索化"><a href="#3-1-二叉树的线索化" class="headerlink" title="3.1 二叉树的线索化"></a>3.1 二叉树的线索化</h3><p><strong>在二叉树的结点上加上线索</strong>的<strong>二叉树</strong>称为<strong>线索二叉树</strong>.</p><p>对二叉树以某种遍历方式（如先序、中序、后序或层次等）进行遍历，使其变为线索二叉树的过程称为对二叉树进行线索化。</p><p>线索链表解决了无法直接找到该结点在某种遍历序列中的前驱和后继结点的问题，解决了二叉链表找左、右孩子困难的问题。</p><p><strong>用土办法找到中序前驱</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//辅助全局变量，用于查找结点p的前驱</span></span><br><span class="line">BiTNode* p;                <span class="comment">//p指向目标结点</span></span><br><span class="line">BiTNode* pre = <span class="literal">NULL</span>;       <span class="comment">//pre指向当前访问结点的前驱</span></span><br><span class="line">BiTNode final = <span class="literal">NULL</span>;      <span class="comment">//用于记录最终结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        visit(T);</span><br><span class="line">        InOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问结点q</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(BiTNode* q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q==p)</span><br><span class="line">        final = pre;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pre = q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以<strong>中序线索化</strong>为例，先序后序过程类似，不一一赘述。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量pre，指向当前访问结点的前驱</span></span><br><span class="line">ThreadNode* pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线索二叉树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="type">int</span> ltag,rtag;   <span class="comment">//左、右线索标志</span></span><br><span class="line">&#125;ThreadNode,*ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历二叉树，一边遍历，一边线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;lchild == <span class="literal">NULL</span>)&#123;   <span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">        q-&gt;lchild = pre;</span><br><span class="line">        q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        pre-&gt;child = q;   <span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InThread</span><span class="params">(Thread T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        InThread(T-&gt;lchild);</span><br><span class="line">        visit(T);    <span class="comment">//在visit()中完成线索化</span></span><br><span class="line">        InThread(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序线索化二叉树T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    pre = <span class="literal">NULL</span>;                  <span class="comment">//pre初始为NULL</span></span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;               <span class="comment">//非空二叉树才能线索化</span></span><br><span class="line">        InThread(T);             <span class="comment">//中序线索化二叉树</span></span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">            pre-&gt;rtag=<span class="number">1</span>;         <span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-在线索二叉树中找前驱后继"><a href="#3-2-在线索二叉树中找前驱后继" class="headerlink" title="3.2 在线索二叉树中找前驱后继"></a>3.2 在线索二叉树中找前驱后继</h3><h4 id="3-2-1-中序线索二叉树"><a href="#3-2-1-中序线索二叉树" class="headerlink" title="3.2.1 中序线索二叉树"></a>3.2.1 中序线索二叉树</h4><ul><li>中序<strong>后继</strong></li></ul><p>在中序线索二叉树中找到指定结点 *p 的中序后继 next</p><p>①若 p-&gt;rtag &#x3D;&#x3D; 1，则 next &#x3D; p-&gt;rchild</p><p>②若 p-&gt;rtag &#x3D;&#x3D; 0，则 next &#x3D; p的右子树中最左下角结点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到以P为根的子树中，第一个被中序遍历的结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Firstnode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">   <span class="comment">//循环找到最左下的结点（不一定是叶结点）</span></span><br><span class="line">   <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">      p=p-&gt;lchild;</span><br><span class="line">   <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在中序线索二叉树中找到结点p的后继结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Nextnode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">   <span class="comment">//右子树最左下结点</span></span><br><span class="line">   <span class="keyword">if</span>(p-&gt;rtag==<span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> Firstnode(p-&gt;rchild);</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> p-&gt;rchild; <span class="comment">//rtag==1，直接返回后继线索</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对中序线索二叉树进行中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Inorder</span><span class="params">(ThreadNode *T)</span>&#123;            <span class="comment">//T为根节点指针</span></span><br><span class="line">   <span class="keyword">for</span>(ThreadNode *p = Firstnode(T); p!=<span class="literal">NULL</span>; p = Nextnode(p))</span><br><span class="line">      visit(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>中序<strong>前驱</strong></li></ul><p>在中序线索二叉树中找到指定结点 *p 的中序前驱 pre</p><p>①若 p-&gt;ltag &#x3D;&#x3D; 1，则 pre &#x3D; p-&gt;lchild</p><p>②若 p-&gt;ltag &#x3D;&#x3D; 0，则 next &#x3D; p的左子树中最右下角结点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到以P为根的子树中，最后一个被中序遍历的结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Lastnode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">   <span class="comment">//循环找到最右下的结点（不一定是叶结点）</span></span><br><span class="line">   <span class="keyword">while</span>(p-&gt;rtag == <span class="number">0</span>)</span><br><span class="line">      p=p-&gt;rchild;</span><br><span class="line">   <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在中序线索二叉树中找到结点p的前驱结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Prenode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">   <span class="comment">//左子树最右下结点</span></span><br><span class="line">   <span class="keyword">if</span>(p-&gt;ltag==<span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> Lastnode(p-&gt;lchild);</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> p-&gt;lchild; <span class="comment">//ltag==1，直接返回前驱线索</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对中序线索二叉树进行逆向中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Revorder</span><span class="params">(ThreadNode *T)</span>&#123;            <span class="comment">//T为根节点指针</span></span><br><span class="line">   <span class="keyword">for</span>(ThreadNode *p = Lastnode(T); p!=<span class="literal">NULL</span>; p = Prenode(p))</span><br><span class="line">      visit(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-先序线索二叉树"><a href="#3-2-2-先序线索二叉树" class="headerlink" title="3.2.2 先序线索二叉树"></a>3.2.2 先序线索二叉树</h4><ul><li>先序<strong>后继</strong></li></ul><p>在先序线索二叉树中找到指定结点 *p 的先序后继 next</p><p>①若 p-&gt;rtag &#x3D;&#x3D; 1，则 next &#x3D; p-&gt;rchild</p><p>②若 p-&gt;rtag &#x3D;&#x3D; 0，则 next &#x3D; 左孩子(有左孩子) &#x2F; 右孩子(没有左孩子)</p><ul><li>先驱<strong>前驱</strong></li></ul><p>在先序线索二叉树中找到指定结点 *p 的先序前驱 pre</p><p>①若 p-&gt;ltag &#x3D;&#x3D; 1, 则 next &#x3D; p-&gt;lchild;</p><p>②若 p-&gt;ltag &#x3D;&#x3D; 0, 则 p必有左孩子，但是先序遍历中，左右子树的结点只可能是根的后继，不可能是前驱，所以不能从左右孩子里寻找p的先序前驱，（除非<strong>从头开始遍历 &#x2F; 三叉链表</strong>）</p><p>case1: 如果能够找到p的父节点，且p是左孩子 —— p的父节点就是p的前驱；</p><p>case2: 如果能够找到p的父节点，且p是右孩子，且其左兄弟为空 —— p的父节点就是p的前驱；</p><p>case3: 如果能够找到p的父节点，且p是右孩子，且其左兄弟非空 ——p的前驱为左兄弟子树中最后一个被先序遍历到的结点（根节点出发，先往右，右没有往左，找到最下一层的结点）；</p><p>case4: p没有父节点，即p为根节点，则p没有先序前驱</p><h4 id="3-2-3-后序线索二叉树"><a href="#3-2-3-后序线索二叉树" class="headerlink" title="3.2.3 后序线索二叉树"></a>3.2.3 后序线索二叉树</h4><ul><li>后序<strong>前驱</strong></li></ul><p>在后序线索二叉树中找到指定节点 *p 的后序前驱 pre</p><p>①若 p-&gt;ltag &#x3D;&#x3D; 1, 则 next &#x3D; p-&gt;lchild;</p><p>②若 p-&gt;ltag &#x3D;&#x3D; 0, 则 p 必有左孩子（不知道有没有右孩子）</p><p>case1: 若p有右孩子 ——— 后序前驱：右孩子</p><p>case2: 若p没有右孩子 ——— 后序前驱：左孩子</p><ul><li>后序<strong>后继</strong></li></ul><p>在后序线索二叉树中找到指定节点 *p 的后序后继 next</p><p>①若 p-&gt;rtag &#x3D;&#x3D; 1, 则 next &#x3D; p-&gt;rchild;</p><p>②若 p-&gt;rtag &#x3D;&#x3D; 0, 则 p 必有右孩子, 左孩子不知道, 但是在后序遍历中，左右子树中的结点只有可能是根的前驱，而不可能是根的后继，所以找不到后继，（除非<strong>从头开始遍历 &#x2F; 三叉链表</strong>）</p><p>case1: 如果能找到p的父节点，且p是右孩子 —— p的父节点即为其后继</p><p>case2: 如果能找到p的父节点，且p是左孩子，其右兄弟为空 —— p的父节点即为其后继</p><p>case3: 如果能找到p的父节点，且p是左孩子，其右兄弟非空 —— p的后继为其右兄弟子树中第一个被后序遍历的结点；</p><p>case4: p没有父节点，即p为根节点，则p没有后序后继；</p><h2 id="4-树的存储"><a href="#4-树的存储" class="headerlink" title="4.树的存储"></a>4.树的存储</h2><h3 id="4-1-双亲表示法（顺序存储）"><a href="#4-1-双亲表示法（顺序存储）" class="headerlink" title="4.1 双亲表示法（顺序存储）"></a>4.1 双亲表示法（顺序存储）</h3><p>双亲表示法：每个结点中保存指向双亲的“指针”</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100         <span class="comment">//树中最多结点数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>                   <span class="comment">//树的结点定义</span></span><br><span class="line">   ElemType data;                 <span class="comment">//数据存储</span></span><br><span class="line">   <span class="type">int</span> parent;                    <span class="comment">//双亲位置域</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>                   <span class="comment">//树的类型定义</span></span><br><span class="line">   PTNode nodes[MAX_TREE_SIZE];   <span class="comment">//双亲表示</span></span><br><span class="line">   <span class="type">int</span> n;                         <span class="comment">//结点数</span></span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure><p>增：新增数据元素，无需按逻辑上的次序存储；（需要更改结点数n）</p><p>删（叶子结点）：将伪指针域设置为-1；或者 用后面的数据填补；（需要更改结点数n）</p><p>删（非叶子结点）：还需要删除该结点的子孙结点统统删除</p><p>查询：<strong>优点</strong>-查指定结点的双亲很方便；<strong>缺点</strong>-查指定结点的孩子只能从头遍历，空数据导致遍历更慢；</p><h3 id="4-2-孩子表示法（顺序-链式存储）"><a href="#4-2-孩子表示法（顺序-链式存储）" class="headerlink" title="4.2 孩子表示法（顺序+链式存储）"></a>4.2 孩子表示法（顺序+链式存储）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> child;              <span class="comment">//孩子结点在数组中的位置</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span>    <span class="comment">// 下一个孩子</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   ElemType data;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">firstChild</span>;</span>    <span class="comment">// 第一个孩子</span></span><br><span class="line">&#125;CTBox;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">   <span class="type">int</span> n, r;   <span class="comment">// 结点数和根的位置</span></span><br><span class="line">&#125;CTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-3-孩子兄弟表示法（链式存储）"><a href="#4-3-孩子兄弟表示法（链式存储）" class="headerlink" title="4.3 孩子兄弟表示法（链式存储）"></a>4.3 孩子兄弟表示法（链式存储）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//数据域</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="comment">//第一个孩子和右兄弟指针, *firstchild 看作左指针，*nextsibling看作右指针</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>, *<span class="title">nextsibling</span>;</span></span><br><span class="line">&#125;CSNode. *CSTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>孩子兄弟表示法</strong>也可以相当于<strong>把树转化成二叉树</strong></p><p><strong>森林和二叉树的转换</strong>：把各个树的根节点视为兄弟关系</p><h2 id="5-树和森林的遍历"><a href="#5-树和森林的遍历" class="headerlink" title="5.树和森林的遍历"></a>5.树和森林的遍历</h2><h3 id="5-1-树的遍历"><a href="#5-1-树的遍历" class="headerlink" title="5.1 树的遍历"></a>5.1 树的遍历</h3><ul><li>先根遍历：若树非空，先访问根结点，再依次对每棵子树进行先根遍历；（与对应二叉树的先序遍历序列相同）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(TreeNode *R)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(R!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      visit(R);            <span class="comment">//访问根节点</span></span><br><span class="line">      <span class="keyword">while</span>(R还有下一个子树T)</span><br><span class="line">         PreOrder(T);      <span class="comment">//先跟遍历下一个子树</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>后根遍历：若树非空，先依次对每棵子树进行后根遍历，最后再返回根节点；（与对应二叉树的中序遍历序列相同）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(TreeNode *R)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(R!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="keyword">while</span>(R还有下一个子树T)</span><br><span class="line">         PostOrder(T);      <span class="comment">//后跟遍历下一个子树</span></span><br><span class="line">      visit(R);             <span class="comment">//访问根节点</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>层序遍历（队列实现）（广度优先遍历）</li></ul><p>若树非空，则根结点入队；</p><p>若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队；</p><p>重复以上操作直至队尾为空；</p><h3 id="5-2-森林的遍历"><a href="#5-2-森林的遍历" class="headerlink" title="5.2 森林的遍历"></a>5.2 森林的遍历</h3><ul><li>先序遍历：等同于依次对各个树进行<strong>先根遍历</strong>；也可以先转换成与之对应的二叉树，对二叉树进行先序遍历；</li><li>中序遍历：等同于依次对各个树进行<strong>后根遍历</strong>；也可以先转换成与之对应的二叉树，对二叉树进行中序遍历；</li></ul><h2 id="6-树与二叉树的应用"><a href="#6-树与二叉树的应用" class="headerlink" title="6.树与二叉树的应用"></a>6.树与二叉树的应用</h2><h3 id="6-1二叉排序树-BST"><a href="#6-1二叉排序树-BST" class="headerlink" title="6.1二叉排序树(BST)"></a>6.1二叉排序树(BST)</h3><p><strong>二叉排序树</strong>：左子树结点值 &lt; 根结点值 &lt; 右子树结点值（左子树、右子树同样是二叉排序树）</p><h4 id="6-1-1-查找"><a href="#6-1-1-查找" class="headerlink" title="6.1.1 查找"></a>6.1.1 查找</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> key;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BSTNode, *BSTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在二叉排序树中查找值为key的结点（非递归）</span></span><br><span class="line"><span class="comment">//最坏空间复杂度：O(1)</span></span><br><span class="line">BSTNode *<span class="title function_">BST_Search</span><span class="params">(BSTree T, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">   <span class="keyword">while</span>(T!=<span class="literal">NULL</span> &amp;&amp; key!=T-&gt;key)&#123;        <span class="comment">//若树空或等于跟结点值，则结束循环</span></span><br><span class="line">      <span class="keyword">if</span>(key&lt;T-&gt;key)       <span class="comment">//值小于根结点值，在左子树上查找</span></span><br><span class="line">         T = T-&gt;lchild;</span><br><span class="line">      <span class="keyword">else</span>                  <span class="comment">//值大于根结点值，在右子树上查找</span></span><br><span class="line">         T = T-&gt;rchild;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在二叉排序树中查找值为key的结点（递归）</span></span><br><span class="line"><span class="comment">//最坏空间复杂度：O(n)</span></span><br><span class="line">BSTNode *<span class="title function_">BSTSearch</span><span class="params">(BSTree T, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">if</span>(Key == T-&gt;key)</span><br><span class="line">      <span class="keyword">return</span> T;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; T-&gt;key)</span><br><span class="line">      <span class="keyword">return</span> BSTSearch(T-&gt;lchild, key);</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> BSTSearch(T-&gt;rchild, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-1-2-插入"><a href="#6-1-2-插入" class="headerlink" title="6.1.2 插入"></a>6.1.2 插入</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在二叉排序树中插入关键字为k的新结点（递归）</span></span><br><span class="line"><span class="comment">//最坏空间复杂度：O(n)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BST_Insert</span><span class="params">(BSTree &amp;T, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;           <span class="comment">//原树为空，新插入的结点为根结点</span></span><br><span class="line">      T = (BSTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">      T-&gt;key = k;</span><br><span class="line">      T-&gt;lchild = T-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;                       <span class="comment">//插入成功</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(K == T-&gt;key)               <span class="comment">//树中存在相同关键字的结点，插入失败</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(k &lt; T-&gt;key)                 </span><br><span class="line">      <span class="keyword">return</span> BST_Insert(T-&gt;lchild,k);</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> BST_Insert(T-&gt;rchild,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新插入的结点一定是叶子结点</span></span><br></pre></td></tr></table></figure><h4 id="6-1-3-二叉排序树的构造"><a href="#6-1-3-二叉排序树的构造" class="headerlink" title="6.1.3 二叉排序树的构造"></a>6.1.3 二叉排序树的构造</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照str[]中的关键字序列建立二叉排序树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Crear_BST</span><span class="params">(BSTree &amp;T, <span class="type">int</span> str[], <span class="type">int</span> n)</span>&#123;</span><br><span class="line">   T = <span class="literal">NULL</span>;                     <span class="comment">//初始时T为空树</span></span><br><span class="line">   <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">      BST_Insert(T,str[i]);     <span class="comment">//依次将每个关键字插入到二叉排序树中</span></span><br><span class="line">      i++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-1-4-删除"><a href="#6-1-4-删除" class="headerlink" title="6.1.4 删除"></a>6.1.4 删除</h4><p>①若被删除结点z是叶子结点，则直接删除</p><p>②若被删除结点z不是叶子结点只有一棵左子树或右子树，则让z的子树替代z的位置即可</p><p>③若被删除结点z有左、右两棵子树，则令z的直接后继（或直接前驱）替代z，然后从二叉排序树中删除这个直接后继（或直接前驱），这样就转换成了第一或第二种情况。</p><p>z的直接后继：z的右子树中最左下的结点（该结点一定没有左子树）</p><p>z的直接前驱：z的左子树中最右下的结点（该结点一定没有右子树）</p><h4 id="6-1-5-查找效率分析"><a href="#6-1-5-查找效率分析" class="headerlink" title="6.1.5 查找效率分析"></a>6.1.5 查找效率分析</h4><p>查找长度：查找运算中，需要对比关键字的次数，反映了查找操作时间复杂度；</p><p>查找成功的平均查找长度ASL</p><p>查找失败的平均查找长度ASL</p><h3 id="6-2-平衡二叉树-AVL"><a href="#6-2-平衡二叉树-AVL" class="headerlink" title="6.2 平衡二叉树(AVL)"></a>6.2 平衡二叉树(AVL)</h3><p><strong>平衡二叉树</strong>：树上任一结点的左子树和右子树的高度之差不超过1。</p><blockquote><p><strong>结点的平衡因子</strong> &#x3D; 左子树高度 - 右子树高</p><p>平衡二叉树<strong>平衡因子</strong>绝对值不大于1</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//平衡二叉树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> key;         <span class="comment">//数据域</span></span><br><span class="line">   <span class="type">int</span> balance;     <span class="comment">//平衡因子</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> *<span class="title">lchild</span>;</span> *rchild; </span><br><span class="line">&#125;AVLNode, *AVLTree;</span><br></pre></td></tr></table></figure><p>在<strong>二叉排序树</strong>中插入新结点后，如何保持平衡？</p><blockquote><p>从插入点往回找到第一个不平衡结点，调整以该结点为根的子树。</p><p>在插入操作中，只要<strong>将最小不平衡子树调整平衡</strong>，则其他祖先结点都会恢复平衡</p></blockquote><h4 id="6-2-1-调整最小不平衡子树"><a href="#6-2-1-调整最小不平衡子树" class="headerlink" title="6.2.1 调整最小不平衡子树"></a>6.2.1 调整最小不平衡子树</h4><p><strong>LL</strong>——在A的左孩子的左子树中插入导致不平衡</p><p>调整： A的<strong>左孩子</strong>结点<strong>右上旋</strong>代替A成为根结点</p><p><strong>RR</strong>——在A的右孩子的右子树中插入导致不平衡</p><p>调整： A的<strong>右孩子</strong>结点<strong>左上旋</strong>代替A成为根结点</p><p><strong>LR</strong>——在A的左孩子的右子树中插入导致不平衡</p><p>调整： A的<strong>左孩子的右孩子</strong>，<strong>先左上旋</strong>替代A的左孩子，<strong>再右上旋</strong>替代A结点</p><p><strong>RL</strong>——在A的右孩子的左子树中插入导致不平衡</p><p>调整： A的<strong>右孩子的左孩子</strong>，<strong>先右上旋</strong>替代A的右孩子，<strong>再左上旋</strong>替代A结点</p><h4 id="6-2-2-平衡二叉树的查找与效率分析"><a href="#6-2-2-平衡二叉树的查找与效率分析" class="headerlink" title="6.2.2 平衡二叉树的查找与效率分析"></a>6.2.2 平衡二叉树的查找与效率分析</h4><p>若树高为h，则最坏情况下，查找一个关键字最多需要对比h次，即查找操作的时间复杂度不可能超过O(h);</p><p>平衡二叉树的最大深度为O(log₂n)，平衡二叉树的平均查找长度为O(log₂n)</p><h3 id="6-3-哈夫曼树"><a href="#6-3-哈夫曼树" class="headerlink" title="6.3 哈夫曼树"></a>6.3 哈夫曼树</h3><h4 id="6-3-1-带权路径长度"><a href="#6-3-1-带权路径长度" class="headerlink" title="6.3.1 带权路径长度"></a>6.3.1 带权路径长度</h4><p>结点的权：有某种现实含义的数值（如：表示结点的重要性等）</p><p><strong>结点的带权路径长度</strong>：从树的根到该结点的路径长度（经过的边数）与该结点上权值的乘积</p><p><strong>树的带权路径长度</strong>：树中所有叶结点的带权路径长度之和（WPL）</p><h4 id="6-3-2-哈夫曼树的定义"><a href="#6-3-2-哈夫曼树的定义" class="headerlink" title="6.3.2 哈夫曼树的定义"></a>6.3.2 哈夫曼树的定义</h4><p>在含有n个带权叶结点的二叉树中，其中<strong>带权路径最小（WPL）的二叉树</strong>成为<strong>哈夫曼树</strong>，也称<strong>最优二叉树</strong></p><h4 id="6-3-3-哈夫曼树的构造"><a href="#6-3-3-哈夫曼树的构造" class="headerlink" title="6.3.3 哈夫曼树的构造"></a>6.3.3 哈夫曼树的构造</h4><p>给定n个权值分别为w₁,w₂,…,wn的结点，构造哈夫曼树的算法描述如下：</p><p>① 将n个结点作为n棵仅含有一个根结点的二叉树，构成森林F；</p><p>② 生成一个新结点，并从森林F中找出根结点权值最小的两棵树作为新结点的左右子树，且令新结点的权值为两棵子树的根结点的权值之和；</p><p>③ 从森林F中删除选择的这两棵树，并将新生成的树加入到F中；</p><p>④ 重复②和③的步骤，直到F中只有一棵树为止，此时即为哈夫曼树。</p><p><strong>哈夫曼树的性质</strong>：</p><p>①每个初始结点都会成为叶结点，双支结点都为新生成的结点；</p><p>②权值越大离根结点越近，权值越小离根结点越远；</p><p>③ 哈夫曼树中没有度为1的结点；</p><p>④n个叶子结点的哈夫曼树的结点总数为2n-1，其中度为2的结点数为n-1，这n-1个结点都是新结点。</p><h4 id="6-3-4-哈夫曼编码"><a href="#6-3-4-哈夫曼编码" class="headerlink" title="6.3.4 哈夫曼编码"></a>6.3.4 哈夫曼编码</h4><p>在数据通信中，若对每个字符用<strong>相等长度的二进制位</strong>表示，称这种编码方式为<strong>固定长度编码</strong>。</p><p>若允许对不同字符用<strong>不等长的二进制位</strong>表示，则这种编码方式称为<strong>可变长度编码</strong>。</p><p>若编码中没有一个编码是其他编码的前缀，则称这样的编码为<strong>前缀编码</strong>。</p><p><strong>可变长度编码比固定长度编码要好得多</strong>，其特点是对频率高的字符赋以短编码，而对频率较低的字符则赋以较长一些的编码，从而可以使字符的平均编码长度减短，起到<strong>压缩数据</strong>的效果。</p><p><strong>哈夫曼编码是一种被广泛应用而且非常有效的数据压缩编码。</strong></p><p>将字符集中的每个字符作为一个叶子结点，各个字符出现的频率作为结点的权值，构造哈夫曼树（哈夫曼树不唯一，哈夫曼编码不唯一）。</p><h1 id="第六章：图"><a href="#第六章：图" class="headerlink" title="第六章：图"></a>第六章：图</h1><h2 id="1-图的基本概念"><a href="#1-图的基本概念" class="headerlink" title="1.图的基本概念"></a>1.图的基本概念</h2><p>图G由顶点集V和边集E组成，记为G &#x3D; (V, E)。</p><p>其中V(G)表示图G中顶点的有限非空集；E(G)表示图G中顶点之间的关系（边）集合。</p><p>若V &#x3D; {v1, v2, … , vn}，则用|V|表示图G中顶点的个数，也称图G的阶，E &#x3D; {(u, v) | u∈V, v∈V}，用|E|表示图G中边的条数。  </p><p>注意：线性表可以是空表，树可以是空树，但图不可以是空，即<strong>V一定是非空集</strong>。</p><p>若E是无向边（简称 边）的有限集合时，则图G为<strong>无向图</strong>；边是顶点的无序对，记为(v, w)或(w, v)。</p><p>若E是有向边（也称 弧）的有限集合时，则图G为<strong>有向图</strong>；弧是顶点的有序对，记为&lt;v, w&gt;。</p><p><strong>简单图</strong>：</p><blockquote><p>① 不存在重复边；</p><p>② 不存在顶点到自身的边  </p><p>（本章只讨论简单图）</p></blockquote><p><strong>多重图</strong>：</p><blockquote><p>图G中某两个结点之间的边数多于一条，又允许顶点通过同一条边和自己关联，则G为多重图  </p></blockquote><p><strong>顶点的度、入度、出度</strong>：</p><p>对于<strong>无向图</strong>：</p><blockquote><p>顶点v的度是指依附于该顶点的边的条数，记为TD(v)。  </p><p>所有顶点的度之和等于 2|E|</p></blockquote><p>对于<strong>有向图</strong>：</p><blockquote><p>入度是以顶点v为终点的有向边的数目，记为ID(v)；</p><p>出度是以顶点v为起点的有向边的数目，记为OD(v)。</p><p>顶点v的度等于其入度和出度之和，即TD(v) &#x3D; ID(v) + OD(v)。  </p><p>所有顶点的入度之和 &#x3D; 所有顶点的出度之和 &#x3D; |E|</p></blockquote><p><strong>顶点- 顶点的关系描述</strong>：</p><blockquote><ul><li><p>路径——顶点Vp到顶点Vq之间的一条路径是指顶点序列</p></li><li><p>回路——第一个顶点和最后一个顶点相同的路径称为回路或环</p></li><li><p>简单路径——在路径序列中，顶点不重复出现的路径称为简单路径。</p></li><li><p>简单回路——除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。</p></li><li><p>路径长度——路径上边的数目</p></li><li><p>点到点的距离——从顶点u出发到顶点v的最短路径若存在，则此路径的长度称为从u到v的距离。若从u到v根本不存在路径，则记该距离为无穷（∞）。</p></li><li><p>无向图中，若从顶点v到顶点w有路径存在，则称v和w是<strong>连通</strong>的</p></li><li><p>有向图中，若从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是<strong>强连通</strong>的</p></li></ul></blockquote><p><strong>连通图、强连通图</strong></p><p>若图G中任意两个顶点都是连通的，则称图G为连通图，否则称为非连通图</p><blockquote><p>对于n个顶点的无向图G，</p><p>若G是连通图，则最少有 n-1 条边，</p><p>若G是非连通图，则最多可能有 (n-1)(n-2)&#x2F;2 条边  </p></blockquote><p>若图中任何一对顶点都是强连通的，则称此图为强连通图</p><blockquote><p>对于n个顶点的有向图G，若G是强连通图，则最少有 n 条边（形成回路）  </p></blockquote><p><strong>子图、生成子图</strong></p><blockquote><p>设有两个图G &#x3D; (V, E)和G‘ &#x3D; (V’, E‘)，若V¢是V的子集，且E’是E的子集，则称G‘是G的<strong>子图</strong>。<br>若有满足V(G’) &#x3D; V(G)的子图G‘，则称其为G的生成<strong>子图</strong>。</p></blockquote><p><strong>连通分量、强连通分量</strong></p><blockquote><p>极大连通子图：子图必须连通，且包含尽可能多的顶点和边</p><p>极大强连通子图：子图必须强连通，同时保留尽可能多的边</p><p>无向图中的<strong>极大连通子图</strong>称为<strong>连通分量</strong>,  有向图中的<strong>极大强连通子图</strong>称为有向图的<strong>强连通分量</strong>  </p></blockquote><p><strong>生成树</strong></p><blockquote><p><strong>连通图</strong>的<strong>生成树</strong>是<strong>包含图中全部顶点</strong>的一个<strong>极小连通子图</strong>（边要在连通的前提下尽可能少）。<br>若图中顶点数为n，则它的生成树含有 n-1 条边。对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。  </p></blockquote><p><strong>生成森林</strong></p><blockquote><p>在<strong>非连通图</strong>中，<strong>连通分量的生成树</strong>构成了非连通图的生成森林。  </p></blockquote><p><strong>边的权、带权图&#x2F;网</strong></p><blockquote><p>边的权——在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值。</p><p>带权图&#x2F;网——边上带有权值的图称为带权图，也称网。</p><p>带权路径长度——当图是带权图时，一条路径上所有边的权值之和，称为该路径的带权路径长度  </p></blockquote><p><strong>几种特殊的图</strong></p><blockquote><p><strong>无向完全图</strong>——无向图中任意两个顶点之间都存在边  </p><p><strong>有向完全图</strong>——有向图中任意两个顶点之间都存在方向相反的两条弧  </p><p><strong>稀疏图</strong>——边数很少的图  </p><p><strong>稠密图</strong>——边数很多的图</p><p>（没有绝对的界限，一般来说，|E| &lt; |V|log|V|时，可以将G视为稀疏图  ）  </p><p><strong>树</strong>——不存在回路，且连通的无向图</p><p><strong>有向树</strong>——一个顶点的入度为0、其余顶点的入度均为1的有向图，称为有向树。  </p></blockquote><h2 id="2-图的存储"><a href="#2-图的存储" class="headerlink" title="2.图的存储"></a>2.图的存储</h2><h3 id="2-1-邻接矩阵"><a href="#2-1-邻接矩阵" class="headerlink" title="2.1 邻接矩阵"></a>2.1 邻接矩阵</h3><table><thead><tr><th align="center"></th><th align="center">A</th><th align="center">B</th><th align="center">C</th></tr></thead><tbody><tr><td align="center"><strong>A</strong></td><td align="center">0</td><td align="center">1（A和B之间存在边）</td><td align="center">0</td></tr><tr><td align="center"><strong>B</strong></td><td align="center">1（B和A之间存在边）</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center"><strong>C</strong></td><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  MaxVertexNum 100                   <span class="comment">//顶点数目的最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> Vex[MaxVertexNum];                 <span class="comment">//顶点表</span></span><br><span class="line">    <span class="comment">//也可以用bool或枚举类型来表示边</span></span><br><span class="line">    <span class="type">int</span> Edge[MaxVertexNum][MaxVertexNum];   <span class="comment">//邻接矩阵，边表</span></span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;                      <span class="comment">//图的当前顶点数和边数/弧数</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure><p><strong>邻接矩阵的空间复杂度只和顶点数相关，适合用于存储稠密图。</strong></p><p><strong>无向图</strong>：</p><blockquote><p>第i个结点的度 &#x3D; 第i行（或第i列）的非零元素个数  </p></blockquote><p><strong>有向图</strong>：</p><blockquote><p>第i个结点的出度 &#x3D; 第i行的非零元素个数</p><p>第i个结点的入度 &#x3D; 第i列的非零元素个数</p><p>第i个结点的度 &#x3D; 第i行、第i列的非零元素个数之和  </p></blockquote><p><strong>邻接矩阵法存储带权图（网）</strong>  </p><blockquote><p>存在边——边上的权值。</p><p>不存在边——用∞来表示，在代码中，可以用int的上限来表示“无穷”。</p></blockquote><p><strong>邻接矩阵的性质</strong></p><blockquote><p>设图G的邻接矩阵为A（矩阵元素为0&#x2F;1），则 A^n 的元素 A^n[i][j] 等于由顶点 i 到顶点 j 的长度为 n 的路径的数目（说明i）</p></blockquote><h3 id="2-2-邻接表"><a href="#2-2-邻接表" class="headerlink" title="2.2 邻接表"></a>2.2 邻接表</h3><p>（顺序+链式存储）</p><table><thead><tr><th align="center">data</th><th align="center">first</th></tr></thead><tbody><tr><td align="center">(0)A</td><td align="center">-&gt;(1)B  -&gt;(2)C  [存在A指向B与A指向C的边]</td></tr><tr><td align="center">(1)B</td><td align="center">-&gt;(0)A</td></tr><tr><td align="center">(2)C</td><td align="center">-&gt;(0)A</td></tr></tbody></table><p>边的先后顺序可以改变，所以邻接表表示方法并不唯一。</p><p><strong>邻接表适合用于稀疏图</strong>。</p><h3 id="2-3-十字链表"><a href="#2-3-十字链表" class="headerlink" title="2.3 十字链表"></a>2.3 十字链表</h3><p>（<strong>存储有向图</strong>）</p><p>①画邻接表</p><p>②增加弧结点的域</p><p>③自己指向自己</p><table><thead><tr><th>顶点结点</th><th>data</th><th>firstin</th><th>firstout</th></tr></thead><tbody><tr><td></td><td>数据域</td><td>该顶点作为弧头的第一条弧</td><td>该顶点作为弧尾的第一条弧</td></tr></tbody></table><table><thead><tr><th>弧结点</th><th>尾</th><th>头</th><th>同头</th><th>同尾</th></tr></thead><tbody><tr><td></td><td>弧尾顶点编号</td><td>弧头顶点编号</td><td>弧头相同的下一条弧</td><td>弧尾相同的下一跳弧</td></tr><tr><td></td><td></td><td></td><td>用箭头指（没有就空^）</td><td>用箭头指（没有就空^）</td></tr></tbody></table><h3 id="2-4-邻接多重表"><a href="#2-4-邻接多重表" class="headerlink" title="2.4 邻接多重表"></a>2.4 邻接多重表</h3><p>（<strong>存储无向图</strong>）</p><table><thead><tr><th>顶点结点</th><th>data</th><th>firstedge</th></tr></thead><tbody><tr><td></td><td>数据域</td><td>与该顶点相连的第一条边（用箭头指）</td></tr></tbody></table><table><thead><tr><th>弧结点</th><th>i</th><th>iLink</th><th>j</th><th>jLink</th></tr></thead><tbody><tr><td></td><td>边的顶点编号</td><td>依附于顶点 i 的下一条边</td><td>边的顶点编号</td><td>依附于顶点 j 的下一条边</td></tr><tr><td></td><td></td><td>用箭头连线（没有就空^）</td><td></td><td>用箭头连线（没有就空^）</td></tr></tbody></table><h2 id="3-图的基本操作"><a href="#3-图的基本操作" class="headerlink" title="3.图的基本操作"></a>3.图的基本操作</h2><p><strong>Adjacent(G,x,y)</strong>：判断图G是否存在边&lt;x, y&gt;或(x, y)。</p><p><strong>Neighbors(G,x)</strong>：列出图G中与结点x邻接的边。</p><p><strong>InsertVertex(G,x)</strong>：在图G中插入顶点x。</p><p><strong>DeleteVertex(G,x)</strong>：从图G中删除顶点x。</p><p><strong>AddEdge(G,x,y)</strong>：若无向边(x, y)或有向边&lt;x, y&gt;不存在，则向图G中添加该边。</p><p><strong>RemoveEdge(G,x,y)</strong>：若无向边(x, y)或有向边&lt;x, y&gt;存在，则从图G中删除该边。</p><p><strong>FirstNeighbor(G,x)</strong>：求图G中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点或图中不存在x，则返回-1。</p><p><strong>NextNeighbor(G,x,y)</strong>：假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1。</p><p><strong>Get_edge_value(G,x,y)</strong>：获取图G中边(x, y)或&lt;x, y&gt;对应的权值。</p><p><strong>Set_edge_value(G,x,y,v)</strong>：设置图G中边(x, y)或&lt;x, y&gt;对应的权值为v。  </p><h2 id="4-图的遍历算法"><a href="#4-图的遍历算法" class="headerlink" title="4.图的遍历算法"></a>4.图的遍历算法</h2><h3 id="4-1-广度优先遍历（BFS）"><a href="#4-1-广度优先遍历（BFS）" class="headerlink" title="4.1 广度优先遍历（BFS）"></a>4.1 广度优先遍历（BFS）</h3><p> 广度优先搜索（BFS）类似于二叉树的层序遍历算法。</p><p>它的基本思想是：首项访问起始顶点v，接着由v出发，依次访问v的各个未访问过的邻接顶点w1,w2,w3,…,wi，然后依次访问它们所有未被访问过的邻接顶点……以此类推，知道所有顶点都被访问过位置。</p><p>类似的思想还将应用于Dijkstra单源最短路径算法和prime最小生成树算法。</p><p>广度优先搜索生成的树为广度优先生成树</p><p><strong>要点</strong>：</p><p>①找到与⼀个顶点相邻的所有顶点</p><p>②标记哪些顶点被访问过</p><p>③需要⼀个辅助队列  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="type">bool</span> visited[MaxVertexNum];    <span class="comment">//标记访问数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFSTraverse</span><span class="params">(Graph G)</span>      <span class="comment">//对图G进行广度优先遍历</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">// 遍历一下所有的顶点</span></span><br><span class="line">        visited[i] = <span class="literal">false</span>;    <span class="comment">// 将所有的顶点都设为未访问标志。</span></span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">// 从0号顶点开始遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[i])        <span class="comment">// 对每个连通分量调用一次BFS</span></span><br><span class="line">            BFS(G,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//广度优先遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span>        <span class="comment">//从顶点v出发</span></span><br><span class="line">&#123;</span><br><span class="line">    visit(v);                  <span class="comment">//访问初始顶点</span></span><br><span class="line">    visited[V]=<span class="literal">true</span>;           <span class="comment">//对v做已访问标记</span></span><br><span class="line">    EnQueue(Q,v);              <span class="comment">//顶点v入队列Q</span></span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        Dequeue(Q,v);          <span class="comment">//顶点v出队列</span></span><br><span class="line">        <span class="keyword">for</span>(w=FirstNeighbor(G,v);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,v,w))</span><br><span class="line">            <span class="comment">//检测v所有邻接点</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[w])        <span class="comment">//w为v的尚未访问的邻接顶点</span></span><br><span class="line">            &#123;</span><br><span class="line">                visit(w);          <span class="comment">//访问顶点w</span></span><br><span class="line">                visited[w]=<span class="literal">true</span>;   <span class="comment">//对w做已访问标记</span></span><br><span class="line">                EnQueue(Q,w);      <span class="comment">//顶点w入队列</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-深度优先遍历（DFS）"><a href="#4-2-深度优先遍历（DFS）" class="headerlink" title="4.2 深度优先遍历（DFS）"></a>4.2 深度优先遍历（DFS）</h3><p>与广度优先搜索不同，深度优先搜索(DFS)(DFS)类似于树的先序遍历。正如其名称中所暗含的意思一样，这种搜索算法所遵循的策略是尽可能“深”的搜索一个图。</p><p>它的基本思想如下：首先访问图中某一起始顶点v，然后从v出发，访问与v邻接且未被访问的任一定点w1，再访问与w1邻接且未被访问的任意顶点w2，……重复上述过程。当不能再继续向下访问时，一次退回到最近被访问的顶点，若他还有邻接顶点未被访问过，则从该点开始继续上述搜索过程，知道搜索顶点均被访问过为止。</p><p>深度优先搜索生成的树为深度优先生成树</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 100</span></span><br><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];   <span class="comment">//访问标记数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSTraverse</span><span class="params">(Graph G)</span>       <span class="comment">//对图G进行深度优先遍历</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;i++)</span><br><span class="line">        visited[v]=<span class="literal">false</span>;       <span class="comment">//初始化已访问标记数据</span></span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;i++)     <span class="comment">//从v=0开始遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[v])</span><br><span class="line">            DFS(G,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span>         <span class="comment">//从顶点v出发，深度优先遍历图G</span></span><br><span class="line">&#123;</span><br><span class="line">    visit(v);                   <span class="comment">//访问顶点v</span></span><br><span class="line">    visited[v]=<span class="literal">true</span>;            <span class="comment">//设已访问标记</span></span><br><span class="line">    <span class="keyword">for</span>(w=FirstNeighbor(G,v);w&gt;=<span class="number">0</span>;w=NextNeighor(G,v,w))</span><br><span class="line">        <span class="keyword">if</span>(!visited[w])         <span class="comment">//w为u的尚未访问的邻接顶点</span></span><br><span class="line">            DFS(G,w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-最小生成树"><a href="#5-最小生成树" class="headerlink" title="5.最小生成树"></a>5.最小生成树</h2><h3 id="5-1-最小生成树的概念"><a href="#5-1-最小生成树的概念" class="headerlink" title="5.1 最小生成树的概念"></a>5.1 最小生成树的概念</h3><p>对于⼀个带权连通⽆向图G &#x3D; (V, E)，⽣成树不同，每棵树的权（即树中所有边上的权值之和）也可能不同。设R为G的所有⽣成树的集合，若T为R中边的权值之和最⼩的⽣成树，则T称为G的最⼩⽣成树（Minimum-Spanning-Tree, MST）   </p><ul><li><p>最⼩⽣成树可能有多个，但边的权值之和总是唯⼀且最⼩的</p></li><li><p>最⼩⽣成树的边数 &#x3D; 顶点数 - 1。砍掉⼀条则不连通，增加⼀条边则会出现回路  </p></li><li><p>如果⼀个连通图本身就是⼀棵树，则其最⼩⽣成树就是它本身 </p></li><li><p>只有连通图才有⽣成树，⾮连通图只有⽣成森林</p></li></ul><h3 id="5-2-Prim算法"><a href="#5-2-Prim算法" class="headerlink" title="5.2 Prim算法"></a>5.2 Prim算法</h3><p>Prim 算法（普⾥姆）：</p><p>从某⼀个顶点开始构建⽣成树；</p><p>每次将代价最⼩的新顶点纳⼊⽣成树，直到所有顶点都纳⼊为⽌。  </p><p>时间复杂度：O(|V|²)，适用于边稠密图</p><h3 id="5-3-Kruskal算法"><a href="#5-3-Kruskal算法" class="headerlink" title="5.3 Kruskal算法"></a>5.3 Kruskal算法</h3><p>Kruskal 算法（克鲁斯卡尔）：</p><p>每次选择⼀条权值最⼩的边，使这条边的两头连通（原本已经连通的就不选），直到所有结点都连通。</p><p>时间复杂度：O(|E|log₂|E|)，适用于边稀疏图</p><h2 id="6-最短路径算法"><a href="#6-最短路径算法" class="headerlink" title="6.最短路径算法"></a>6.最短路径算法</h2><h3 id="6-1-BFS算法"><a href="#6-1-BFS算法" class="headerlink" title="6.1 BFS算法"></a>6.1 BFS算法</h3><p>（无权图的<strong>单源最短路径</strong>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求顶点u到其他顶点的最短路径</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS_MIN_Ditance</span><span class="params">(Graph G,<span class="type">int</span> u)</span>&#123;</span><br><span class="line">    <span class="comment">//d[i]表示从u到i结点的最短路径</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)&#123;</span><br><span class="line">        d[i]=∞;          <span class="comment">//初始化路径长度（∞可以用int最大值代替）</span></span><br><span class="line">        path[i]=<span class="number">-1</span>;      <span class="comment">//最短路径从哪个顶点过来</span></span><br><span class="line">    &#125;</span><br><span class="line">    d[u]=<span class="number">0</span>;              <span class="comment">//把顶点u设为0</span></span><br><span class="line">    visited[u]=TRUE;</span><br><span class="line">    EnQueue(Q,u);</span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q))&#123;</span><br><span class="line">        DeQueue(Q,v);              <span class="comment">//顶点u出队列</span></span><br><span class="line">        <span class="keyword">for</span>(w=FirstNeighbor(G,v);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,v,w))</span><br><span class="line">            <span class="keyword">if</span>(!visited[w])        <span class="comment">//w为u的尚未访问的邻接顶点</span></span><br><span class="line">            &#123;</span><br><span class="line">                d[w]=d[u]+<span class="number">1</span>;       <span class="comment">//路径长度+1</span></span><br><span class="line">                path[w]=u;         <span class="comment">//最短路径应从u到w</span></span><br><span class="line">                visited[w]=TRUE;   <span class="comment">//设已访问标记</span></span><br><span class="line">                EnQueue(Q,w);      <span class="comment">//顶点w入队</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-Dijkstra算法"><a href="#6-2-Dijkstra算法" class="headerlink" title="6.2 Dijkstra算法"></a>6.2 Dijkstra算法</h3><p>迪杰斯特拉（1972年图灵奖得主）</p><p>（无权图、带权图的<strong>单源最短路径</strong>）</p><p>和Prime是一样的，不过Prime是最小生成树，计算的是将这些点连起来花费的最小代价。而Dijkstra计算的是，从某点开始到其他点花费的最小代价。</p><p>但是<strong>Dijkstra算法不适用于有负权值的带权图</strong></p><p>①<strong>从V₀开始，初始化三个数组信息</strong>。</p><p>令 final[0]&#x3D;ture; dist[0]&#x3D;0; path[0]&#x3D;-1；</p><p>其余顶点final[k]&#x3D;false; dist[k]&#x3D;arcs[0][k]; path[k]&#x3D; (arcs[0][k]&#x3D;&#x3D;∞) ? -1 : 0  </p><blockquote><p><strong>final[]</strong> ：标记各顶点是否已找到最短路径</p><p><strong>dist[]</strong>  ：最短路径长度</p><p><strong>path[]</strong> ：路径上的前驱</p></blockquote><p>②<strong>循环遍历所有结点，找到还没确定最短路径，且dist 最⼩的顶点Vi，令final[i]&#x3D;ture</strong>。  </p><p>③<strong>检查所有邻接⾃ Vi 的顶点，若其 final 值为false，则更新 dist 和 path 信息</strong> 。</p><blockquote><p>若 final[j]&#x3D;&#x3D;false 且 dist[i]+arcs[i][j] &lt; dist[j]，</p><p>则令 dist[j]&#x3D;dist[i]+arcs[i][j] ; path[j]&#x3D;i。</p><p>（注： arcs[i][j]表示 Vi 到 Vj 的弧的权值）  </p></blockquote><p>④<strong>重复②③直至final全为true</strong></p><h3 id="6-3-Floyd算法"><a href="#6-3-Floyd算法" class="headerlink" title="6.3 Floyd算法"></a>6.3 Floyd算法</h3><p>弗洛伊德（1978年图灵奖得主）</p><p>（无权图、带权图的<strong>各顶点间的最短路径</strong>）</p><p>Floyd<strong>可以用于有负权值的带权图</strong>。</p><p>Floyd<strong>不能解决带有“负权回路”（有负权值的边组成回路）的图</strong>，这种图可能没有最短路径。</p><p>对于n个顶点的图G，求任意⼀对顶点 Vi —&gt; Vj 之间的最短路径可分为如下⼏个阶段：</p><blockquote><p><strong>#初始</strong>：不允许在其他顶点中转，最短路径是？</p><p>A(-1)——目前来看，各顶点间的最短路径长度</p><p>path(-1)——两个顶点之间的中转点</p><p><strong>#0</strong>：若允许在 V0 中转，最短路径是？</p><p>检查所有元素</p><p>若 A(k−1)[i][j] &gt; A(k−1)[i][k] + A(k−1)[k][j]</p><p>则 A(k)[i][j] &#x3D; A(k−1)[i][k] + A(k−1)[k][j]；path(k)[i][j] &#x3D; k</p><p>否则 A(k) 和 path(k) 保持原值</p><p><strong>#1</strong>：若允许在 V0、 V1 中转，最短路径是？</p><p><strong>#2</strong>：若允许在 V0、 V1、 V2 中转，最短路径是？</p><p>…</p><p><strong>#n-1</strong>：若允许在 V0、 V1、 V2 …… Vn-1 中转，最短路径是？  </p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Floyd核心算法</span></span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">&#123;             </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)       <span class="comment">//所有的路都让k加进去试试  </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)   <span class="comment">//如果从i到j的路上有k走的会更轻松的话,那就让k去吧 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(A[i][j]&gt;A[i][k]+A[k][j])    <span class="comment">//判断是否会更加轻松       </span></span><br><span class="line">&#123;</span><br><span class="line">A[i][j] = A[i][k]+A[k][j]; <span class="comment">//更新最短路径长度</span></span><br><span class="line">path[i][j] = k;            <span class="comment">//中转点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-有向无环图"><a href="#7-有向无环图" class="headerlink" title="7.有向无环图"></a>7.有向无环图</h2><p><strong>有向无环图</strong>：若一个<strong>有向图</strong>中<strong>不存在环</strong>，则称为有向无环图，简称<strong>DAG图</strong></p><p><strong>有向无环图可以用来描述表达式</strong></p><h2 id="8-拓扑排序"><a href="#8-拓扑排序" class="headerlink" title="8.拓扑排序"></a>8.拓扑排序</h2><p> <strong>AOV网</strong></p><blockquote><p>用顶点表示活动的网</p><p>用DAG表示一个工程；顶点表示活动；有向边 &lt;Vi，Vj&gt;表示活动Vi必须先于活动Vj进行</p></blockquote><h3 id="8-1-拓扑排序"><a href="#8-1-拓扑排序" class="headerlink" title="8.1 拓扑排序"></a>8.1 拓扑排序</h3><blockquote><p>在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序。</p><p>①每个顶点出现且只出现一次</p><p>②若顶点A在序列中排在顶点B的前面，则在图中不存在从顶点B到顶点A的路径。</p></blockquote><p><strong>拓扑排序的实现：</strong></p><blockquote><p>①从DAG图中选择一个没有前驱的顶点并输出。</p><p>②从图中删除该顶点和所有以它为为起点的有向边。</p><p>③重复①和②直到<strong>当前的DAG图为空</strong>或<strong>当前图中不存在无前驱的顶点</strong>为止。（而后一种情况则说明有向图中必然存在环）</p><p>注意：有回路的图不适合用拓扑排序</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拓扑排序</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">TopologicalSort</span><span class="params">(Graph G)</span>&#123;</span><br><span class="line">InitStack(S); <span class="comment">//初始化栈，存储入度为0的顶点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line"><span class="keyword">if</span>(indegree[i]==<span class="number">0</span>)</span><br><span class="line">Push(S,i);<span class="comment">//将所有入度为0的顶点进栈</span></span><br><span class="line"><span class="type">int</span> count=<span class="number">0</span>;<span class="comment">//计数，记录当前已经输出的顶点数</span></span><br><span class="line"><span class="keyword">while</span>(!IsEmpty(S))&#123;<span class="comment">//栈不空，则存在入度为0的顶点</span></span><br><span class="line">Pop(S,i);<span class="comment">//栈顶元素出栈</span></span><br><span class="line">print[count++]=i;<span class="comment">//输出顶点i;</span></span><br><span class="line"><span class="keyword">for</span>(p=G.vertices[i].firstarc;p;p=p-&gt;nextrac)&#123;</span><br><span class="line"><span class="comment">//将所有i指向的顶点的入度减1，并将入度减为0的顶点压入栈S</span></span><br><span class="line">v=p-&gt;adjvex;</span><br><span class="line"><span class="keyword">if</span>(!(--indegree[v]))</span><br><span class="line">Push(S,v);  <span class="comment">//入度为0，则入栈</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(count&lt;G.vexnum)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//排序失败，有向图中有回路</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//拓扑排序成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-逆拓扑排序"><a href="#8-2-逆拓扑排序" class="headerlink" title="8.2 逆拓扑排序"></a>8.2 逆拓扑排序</h3><p><strong>逆拓扑排序的实现</strong></p><blockquote><p>①从AOV网中选择一个没有后继（出度为O)的顶点并输出。</p><p>②从网中删除该顶点和所有以它为终点的有向边。</p><p>③重复①和②直到当前的AOV网为空。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逆拓扑排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSTraverse</span><span class="params">(Graph G)</span>&#123; <span class="comment">//对图G进行深度优先遍历</span></span><br><span class="line"><span class="keyword">for</span>(v=<span class="number">0</span>; v&lt;G.vexnum; ++v)</span><br><span class="line">visited[v]=FALSE;   <span class="comment">//初始化已访问标记数据</span></span><br><span class="line"><span class="keyword">for</span>(v=<span class="number">0</span>; v&lt;G.vexnum; ++v)<span class="comment">//本代码中是从v=0开始遍历</span></span><br><span class="line"><span class="keyword">if</span>(!visited[v])</span><br><span class="line">DFS(G,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span>&#123;<span class="comment">//从顶点v出发，深度优先遍历图G</span></span><br><span class="line">visited[v]=TRUE;<span class="comment">//设已访问标记</span></span><br><span class="line"><span class="keyword">for</span>(w=FirstNeighbor(G,v);w&gt;=<span class="number">0</span>; w=NextNeighor(G,v,w))</span><br><span class="line"><span class="keyword">if</span>(!visited[w])&#123;<span class="comment">// w为u的尚未访问的邻接顶点</span></span><br><span class="line">DFS(G,w);</span><br><span class="line">&#125;</span><br><span class="line">print(v );        <span class="comment">//输出顶点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-关键路径"><a href="#9-关键路径" class="headerlink" title="9.关键路径"></a>9.关键路径</h2><p><strong>AOE网</strong></p><blockquote><p>在带权有向图中，以<strong>顶点表示事件</strong>，以<strong>有向边表示活动</strong>，以<strong>边上的权值表示完成该活动的开销</strong>（如完成活动所需的时间)，称之为用边表示活动的网络，简称<strong>AOE网</strong>(Activity On Edge NetWork)</p></blockquote><p><strong>AOE网的两个性质</strong></p><blockquote><p>①只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始;</p><p>②只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生。另外，有些活动是可以并行进行的。</p></blockquote><p>在AOE网中<strong>仅有一个</strong>入度为0的顶点，称为<strong>开始顶点〈源点)</strong>，它表示整个工程的开始;<br>也<strong>仅有一个</strong>出度为0的顶点，称为<strong>结束顶点（汇点)</strong>，它表示整个工程的结束。</p><p>从源点到汇点的有向路径可能有多条，所有路径中，具有最大路径长度的路径称为<strong>关键路径</strong>，而把关键路径上的活动称为<strong>关键活动</strong>。</p><p>完成整个工程的<strong>最短时间</strong>就是<strong>关键路径的长度</strong>，若关键活动不能按时完成，则整个工程的完成时间就会延长。</p><blockquote><ul><li><p>事件vk的最早发生时间ve(k)——决定了所有从vk开始的活动能够开工的最早时间。</p></li><li><p>事件vk的最迟发生时间vl(k)——它是指在不推迟整个工程完成的前提下，该事件最迟必须发生的时间。</p></li><li><p>活动ai的最早开始时间e(i)——指该活动弧的起点所表示的事件的最早发生时间。</p></li><li><p>活动ai的最迟开始时间l(i)——它是指该活动弧的终点所表示事件的最迟发生时间与该活动所需时间之差。</p></li><li><p>活动ai的<strong>时间余量d(i)&#x3D;l(i)-e(i)</strong>——是指在不增加完成整个工程所需总时间的情况下，活动ai可以拖延的时间。</p></li></ul><p>【若一个活动的时间余量为零，则说明该活动必须要如期完成，d(i)&#x3D;0即l(i) &#x3D;e(i)的活动ai是关键活动，由关键活动组成的路径就是关键路径】</p></blockquote><h1 id="第七章：查找"><a href="#第七章：查找" class="headerlink" title="第七章：查找"></a>第七章：查找</h1><h2 id="1-查找的基本概念"><a href="#1-查找的基本概念" class="headerlink" title="1.查找的基本概念"></a>1.查找的基本概念</h2><p><strong>查找</strong> —— 在数据集合中寻找满⾜某种条件的数据元素的过程称为查找<br><strong>查找表（查找结构）</strong>—— ⽤于查找的数据集合称为查找表，它由同⼀类型的数据元素（或记录）组成<br><strong>关键字</strong> —— 数据元素中**唯⼀**标识该元素的某个数据项的值，使⽤基于关键字的查找，查找结果应该是唯⼀的。  </p><p><strong>对查找表的常见操作</strong></p><blockquote><p>①查找符合条件的数据元素</p><p>②插⼊、删除某个数据元素  </p></blockquote><p><strong>查找算法的评价指标</strong>  </p><blockquote><p>①查找⻓度——在查找运算中，需要对⽐关键字的次数称为查找⻓度<br>②平均查找⻓度（ASL, Average Search Length）—— 所有查找过程中进⾏关键字的⽐较次数的平均值  </p></blockquote><h2 id="2-顺序查找"><a href="#2-顺序查找" class="headerlink" title="2.顺序查找"></a>2.顺序查找</h2><h3 id="2-1-算法思想"><a href="#2-1-算法思想" class="headerlink" title="2.1 算法思想"></a>2.1 算法思想</h3><p>顺序查找，⼜叫“线性查找”，通常⽤于线性表。</p><p>算法思想：从头到 jio 挨个找（或者反过来也OK）  </p><h3 id="2-2-算法实现"><a href="#2-2-算法实现" class="headerlink" title="2.2 算法实现"></a>2.2 算法实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>        <span class="comment">//查找表的数据结构（顺序表）</span></span><br><span class="line">    Elemtype *elem;    <span class="comment">//动态数组基址</span></span><br><span class="line">    <span class="type">int</span> TableLen;      <span class="comment">//表的长度</span></span><br><span class="line">&#125;SSTable;</span><br><span class="line"><span class="comment">//顺序查找</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Search_Seq</span><span class="params">(SSTable ST, ElemType key)</span>&#123;</span><br><span class="line">    <span class="comment">// 引入哨兵元素，在创建查找表时，0号单元留空，预留给带查找元素关键字</span></span><br><span class="line"><span class="comment">// 引入哨兵元素的目的是使得循环不必判断数组是否越界，可以避免很多不必要的判断语句，提高效率 </span></span><br><span class="line">ST.elem[<span class="number">0</span>] = key;                               <span class="comment">//“哨兵”  </span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = ST.TableLen; ST.elem[i] != key; --i);   <span class="comment">//从后往前找</span></span><br><span class="line"><span class="keyword">return</span> i;    <span class="comment">//查找成功，返回元素下标；查找失败，则返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><h2 id="3-折半查找"><a href="#3-折半查找" class="headerlink" title="3.折半查找"></a>3.折半查找</h2><h3 id="3-1-算法思想"><a href="#3-1-算法思想" class="headerlink" title="3.1 算法思想"></a>3.1 算法思想</h3><p><strong>折半查找</strong>，又称“二分查找”，仅适用于<strong>有序</strong>的<strong>顺序表</strong></p><p><strong>基本思想</strong>：</p><blockquote><p>首先将给定值key于表<strong>中间位置</strong>的元素进行比较，若相等，则查找成功，返回元素位置；若不等，则目标元素只能在中间元素以外的前半部分或后半部分，然后在缩小的范围内继续同样的查找。</p></blockquote><h3 id="3-2-算法实现"><a href="#3-2-算法实现" class="headerlink" title="3.2 算法实现"></a>3.2 算法实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>        <span class="comment">//查找表的数据结构（顺序表）</span></span><br><span class="line">    Elemtype *elem;    <span class="comment">//动态数组基址</span></span><br><span class="line">    <span class="type">int</span> TableLen;      <span class="comment">//表的长度</span></span><br><span class="line">&#125;SSTable;</span><br><span class="line"><span class="comment">//折半查找（以升序为例）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">binnarySearch</span><span class="params">(SSTable L, ElemType key)</span>&#123;</span><br><span class="line"><span class="type">int</span> low = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> high = L.TableLen - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> mid;</span><br><span class="line"><span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">mid = (low + high) / <span class="number">2</span>;      <span class="comment">//取中间位置（向下取整）</span></span><br><span class="line"><span class="keyword">if</span>(L.elem[mid] == key)       <span class="comment">//查找成功直接返回</span></span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(L.elem[mid] &lt; key)</span><br><span class="line">low = mid + <span class="number">1</span>;           <span class="comment">//从后半部分开始查找</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">high = mid - <span class="number">1</span>;          <span class="comment">//从前半部分开始查找</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 查找失败，返回-1    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(log₂n)</p><h3 id="3-3-折半查找判定树"><a href="#3-3-折半查找判定树" class="headerlink" title="3.3 折半查找判定树"></a>3.3 折半查找判定树</h3><p><strong>构造：</strong></p><blockquote><p>由mid所指元素将原有元素分割到左右子树中</p><p>key：右子树结点数 - 左子树结点树 的绝对值小于等于1</p></blockquote><p><strong>特性：</strong></p><blockquote><p>折半查找判定树是平衡的二叉排序树</p><p>折半查找判定树，只有最下面一层是不满的</p><p>若查找表有n个关键字，则失败结点有 n+1 个</p><p>树高h&#x3D;[log₂(n+1)] （不包含失败结点）</p></blockquote><h2 id="4-分块查找"><a href="#4-分块查找" class="headerlink" title="4.分块查找"></a>4.分块查找</h2><h3 id="4-1-算法思想"><a href="#4-1-算法思想" class="headerlink" title="4.1 算法思想"></a>4.1 算法思想</h3><p><strong>基本思想</strong>：</p><blockquote><p>将查找表分为若干子块，块内元素可以无序，但块之间是有序的，即前一块中的最大关键字小于后一块中的最小关键字。再建立一个索引表，索引表中的每个元素含有各块中的最大关键字和各块中的第一个元素的地址，索引表按关键字有序排序。</p><p>分块查找吸取了顺序查找和折半查找各自的优点，既有动态结构，又适合于快速查找。</p><p>查找分为两步，第一步是在索引表中确定待查记录所在的块，可以使用顺序查找或折半查找；第二部是在块内顺序查找。</p></blockquote><h2 id="5-B树"><a href="#5-B树" class="headerlink" title="5.B树"></a>5.B树</h2><p>B树，又称<strong>多路平衡查找树</strong>，所有结点的最大孩子数称为<strong>阶</strong>。一般用m来指代</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5叉查找树的结点定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    Elemtype keys[<span class="number">4</span>];       <span class="comment">//最多四个关键字</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">child</span>[5];</span>  <span class="comment">//最多5个孩子</span></span><br><span class="line">    <span class="type">int</span> num;                <span class="comment">//结点中有几个关键字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-B树的性质"><a href="#5-1-B树的性质" class="headerlink" title="5.1 B树的性质"></a>5.1 B树的性质</h3><p><strong>对于m阶的B树</strong>：</p><blockquote><ul><li><p>根节点的⼦树数∈[2, m]，关键字数∈[1, m-1]。</p><p>其他结点的⼦树数∈[ , m]；关键字数∈[ -1, m-1]  </p></li><li><p>对任⼀结点，其所有⼦树⾼度都相同  </p></li><li><p>关键字的值：⼦树0&lt;关键字1&lt;⼦树1&lt;关键字2&lt;⼦树2&lt;…. (类⽐⼆叉查找树 左&lt;中&lt;右)  </p></li><li><p>所有叶节点都位于同一层，并且是不带信息的</p></li></ul></blockquote><h3 id="5-2-B树的查找"><a href="#5-2-B树的查找" class="headerlink" title="5.2 B树的查找"></a>5.2 B树的查找</h3><p>B树的查找可分为两步</p><blockquote><p>1.在B树中找结点(磁盘上进行)</p><p>2.在结点内找关键字(内存上进行)，可采用顺序查找法或折半查找法。</p></blockquote><h3 id="5-3-B树的插入"><a href="#5-3-B树的插入" class="headerlink" title="5.3 B树的插入"></a>5.3 B树的插入</h3><p>通过B树的查找算法确定查找失败的位置，这个位置就是应该插入的位置。</p><p>开始进行插入，如果要插入结点的关键字数量小于m，直接插入即可。如果大于等于m，那就不符合B树的特性了，那就要进行分裂。</p><p>分裂的方法是：位置为”向上取整m&#x2F;2”的关键字，给到父节点，这个关键字的左部分保持在原来结点，右部分放到一个新节点。</p><p>如果给到父节点关键字后，父节点的关键字数量也大于等于m了，那么就要进行二次分裂。</p><h3 id="5-4-B树的删除"><a href="#5-4-B树的删除" class="headerlink" title="5.4 B树的删除"></a>5.4 B树的删除</h3><p>删除可分为两种情况，被删的关键字在与不在终端结点中。</p><ul><li>不在终端结点中</li></ul><blockquote><p>如果要删关键字k，找到k的直接前驱（左侧指针所指⼦树中“最右下”的元素  ）或直接后继（右侧指针所指⼦树中“最左下”的元素  ）来替代被删除的关键字。</p></blockquote><ul><li>在终端结点中，又分为三种情况</li></ul><blockquote><p>①直接删除。 当将要被删除关键字所在结点的关键字数量大于等于“向上取整m&#x2F;2”，代表删掉之后就是“向上取整m&#x2F;2”-1，依旧符合B树特性，可以直接删掉。<br>借兄弟一手。 顾名思义，为啥要借，就是自身不符合前面直接删除的条件(删掉之后不符合B树特性了)，所以要借兄弟的，那兄弟够借嘛？所以又可以分为两种</p><p>②兄弟够借。若被删除关键字所在结点删除前的关键字个数低于下限，且与此结点右（或左）兄弟结点的关键字个数还很宽裕，则需要调整该结点、右（或左）兄弟结点及其双亲结点（⽗⼦换位法）  </p><p>③兄弟不够借。若被删除关键字所在结点删除前的关键字个数低于下限，且此时与该结点相邻的左、右兄弟结点的关键字个数均&#x3D;⌈m&#x2F;2⌉ - 1，则将关键字删除后<strong>与左（或右）兄弟结点及双亲结点中的关键字进⾏合并</strong></p><p>在合并过程中，双亲结点中的关键字个数会减1。若其双亲结点是根结点且关键字个数减少⾄0（根结点关键字个数为1时，有2棵⼦树），则直接将根结点删除，合并后的新结点成为根；若双亲结点不是根结点，且关键字个数减少到 ，则⼜要与它⾃⼰的兄弟结点进⾏调整或合并操作，并重复上述步骤，直⾄符合B树的要求为⽌</p></blockquote><h2 id="6-B-树"><a href="#6-B-树" class="headerlink" title="6.B+树"></a>6.B+树</h2><p>B+树是专门为数据库设计的。</p><p>B+树的查找、插入、删除与B树类似，但是B+树查找到关键字后，并不终止，而是继续向下查找，直到叶节点上的关键字为止。</p><h3 id="6-1-B-树的性质"><a href="#6-1-B-树的性质" class="headerlink" title="6.1 B+树的性质"></a>6.1 B+树的性质</h3><p><strong>⼀棵m阶的B+树需满⾜下列条件</strong>：</p><blockquote><ul><li><p>每个分⽀结点最多有m棵⼦树（孩⼦结点）。</p></li><li><p>⾮叶根结点⾄少有两棵⼦树，其他每个分⽀结点⾄少有 棵⼦树。</p></li><li><p><strong>结点的⼦树个数与关键字个数相等。</strong></p></li><li><p><strong>所有叶结点包含全部关键字</strong>及指向相应记录的指针，叶结点中将关键字按⼤⼩顺序排列，并且相邻叶结点按⼤⼩顺序相互链接起来。</p></li><li><p>所有分⽀结点中仅包含它的各个⼦结点中关键字的最⼤值及指向其⼦结点的指针。</p></li></ul></blockquote><h3 id="6-2-B-树-vs-B树"><a href="#6-2-B-树-vs-B树" class="headerlink" title="6.2 B+树 vs B树"></a>6.2 B+树 vs B树</h3><p><strong>相同点</strong>：</p><ul><li><p>除根节点外，最少 [m&#x2F;2] 个分叉（确保结点不要太“空”）</p></li><li><p>任何⼀个结点的⼦树都要⼀样⾼（确保“绝对平衡”）</p></li></ul><p><strong>不同点</strong>：</p><table><thead><tr><th></th><th>m阶B树</th><th>m阶B+树</th></tr></thead><tbody><tr><td>类比</td><td>⼆叉查找树的进化——&gt;m叉查找树</td><td>分块查找的进化——&gt;多级分块查找</td></tr><tr><td>关键字与分叉</td><td>n个关键字对应n+1个分叉（⼦树）</td><td>n个关键字对应n个分叉</td></tr><tr><td>节点包含的信息</td><td>所有结点中都包含记录的信息</td><td>只有最下层叶⼦结点才包含记录的信息 （可使树更矮）</td></tr><tr><td>查找方式</td><td>不⽀持顺序查找。查找成功时，可能停在 任何⼀层结点，查找速度“不稳定”</td><td>⽀持顺序查找。查找成功或失败都会到达 最下⼀层结点，查找速度“稳定</td></tr></tbody></table><h2 id="7-散列查找"><a href="#7-散列查找" class="headerlink" title="7.散列查找"></a>7.散列查找</h2><h3 id="7-1-概念"><a href="#7-1-概念" class="headerlink" title="7.1 概念"></a>7.1 概念</h3><p><strong>散列表</strong>（Hash Table），⼜称<strong>哈希表</strong>。是⼀种数据结构，特点是：<strong>数据元素的关键字与其存储地址直接相关</strong>  。</p><p><strong>散列函数</strong>：把查找表中的关键字映射成该关键字对应地址的函数，记为Addr&#x3D;Hash（key）。这里的地址可以是数组下标、索引或内存地址等。</p><p>若不同的关键字通过散列函数映射到同⼀个值，则称它们为**“同义词”**  </p><p>通过散列函数确定的位置已经存放了其他元素，则称这种情况为**“冲突”**   </p><p><strong>理想</strong>情况下，散列表的<strong>查找时间复杂度为O(1)</strong>，即与表中元素的个数无关。</p><h3 id="7-2-构造散列函数"><a href="#7-2-构造散列函数" class="headerlink" title="7.2 构造散列函数"></a>7.2 构造散列函数</h3><p>①<strong>除留余数法</strong></p><blockquote><p><strong>H(key) &#x3D; key % p</strong></p><p>假定散列表表长为m，取一个不大于m但最接近m的<strong>质数</strong>p</p><p>(取质数的话大多数情况下能让冲突发生得更少，分布得更均匀，参见《数论》)</p></blockquote><p>②<strong>直接定址法</strong>  </p><blockquote><p><strong>H(key) &#x3D; key 或 H(key) &#x3D; a*key + b</strong>  </p><p>其中，a和b是常数。这种⽅法计算最简单，且不会产⽣冲突。它<strong>适合关键字的分布基本连续的情况</strong>，若关键字分布不连续，空位较多，则会造成存储空间的浪费。  </p></blockquote><p>③<strong>数字分析法</strong></p><blockquote><p><strong>选取数码分布较为均匀的若⼲位作为散列地址</strong>  </p><p>设关键字是r进制数（如⼗进制数），⽽<strong>r个数码在各位上出现的频率不⼀定相同</strong>，可能在某些位上分布均匀⼀些，每种数码出现的机会均等；⽽在某些位上分布不均匀，只有某⼏种数码经常出现。</p><p>此时可选取数码分布较为均匀的若⼲位作为散列地址。这种⽅法适合于已知的关键字集合，若更换了关键字，则需要重新构造新的散列函数。  </p></blockquote><p>④<strong>平⽅取中法</strong></p><blockquote><p><strong>取关键字的平⽅值的中间⼏位作为散列地址。</strong>  </p><p>具体取多少位要视实际情况⽽定。</p><p><strong>这种⽅法得到的散列地址与关键字的每位都有关系</strong>。</p><p>因此使得散列地址分布⽐较均匀，<strong>适⽤于关键字的每位取值都不够均匀或均⼩于散列地址所需的位数</strong>。  </p><p>例：存储学生的身份证号</p></blockquote><h3 id="7-3-处理冲突的办法"><a href="#7-3-处理冲突的办法" class="headerlink" title="7.3 处理冲突的办法"></a>7.3 处理冲突的办法</h3><h4 id="7-3-1-拉链法"><a href="#7-3-1-拉链法" class="headerlink" title="7.3.1 拉链法"></a>7.3.1 拉链法</h4><p>⽤<strong>拉链法</strong>（⼜称链接法、链地址法）处理“冲突”： <strong>把所有“同义词”存储在⼀个链表中</strong></p><p>散列表的查找过程于构造散列表的过程基本一致。根</p><p>据散列函数和关键字可以计算出记录的散列地址。</p><p>若散列地址上：</p><p>①无记录，说明查找失败；</p><p>②若有记录且关键字相同，则查找成功；</p><p>③若有记录但关键字不同，使用给定的处理冲突方法计算下一个散列地址，再次进行比较。</p><p><strong>装填因子</strong>：定义一个表的装满程度，即α &#x3D; 表中记录数&#x2F;散列表长度</p><h4 id="7-3-2-开放定址法"><a href="#7-3-2-开放定址法" class="headerlink" title="7.3.2 开放定址法"></a>7.3.2 开放定址法</h4><p>开放定址法，是指可存放新表项的空闲地址既向它的同义词表项开放，⼜向它的⾮同义词表项开放。  </p><p>数学递推公式：</p><p><strong>Hi &#x3D; (H(key) + di) % m</strong></p><p>i &#x3D; 0, 1, 2,…, k（k≤m - 1）， m表示散列表表⻓； <strong>di为增量序列</strong>； i 可理解为“第i次发⽣冲突”  </p><p>取定某一增量序列di后，对应的处理方法就是确定的。通常有以下4种取法</p><p>①<strong>线性探测法</strong>（线性探测再散列法）</p><p><strong>di &#x3D; 0，1，2，···，m-1</strong></p><blockquote><ul><li><p>冲突发生时，顺序查看表中下一个单元，直到找出一个空单元或查遍全表（此时表已满）。</p></li><li><p>线性探查法可能使第 i 个散列地址的同义词存入第 i+1 个散列地址，这样本应存入第 i+1 个散列地址的元素就要争夺 i+2 个散列地址。<strong>造成大量元素在相邻的散列地址上聚集（堆积）起来，大大降低了查找效率。</strong></p></li><li><p>采⽤“开放定址法”时，删除结点<strong>不能简单地将被删结点的空间置为空</strong>，否则将截断在它之后填⼊散列表的同义词结点的查找路径，可以做⼀个“删除标记”，进⾏逻辑删除</p></li></ul></blockquote><p>②<strong>平方探测法</strong>（二次探测再散列法）</p><p><strong>di &#x3D; 0²，1²，-1²，2²，-2²，···，k²，-k²（k≤m&#x2F;2）</strong></p><blockquote><ul><li>散列表长度m必须是一个可以表示为4k+3的素数。</li><li>是一种处理冲突的较好方法，可以避免出现堆积问题。</li><li>⼩坑：散列表⻓度m必须是⼀个可以表示成4j + 3的素数，才能探测到所有位置，参加《数论》</li></ul></blockquote><p>③<strong>再散列法</strong>（双散列法）</p><p><strong>Hi &#x3D; RHi(Key)      i&#x3D;1,2,3….,k</strong>  </p><blockquote><ul><li>除了原始的散列函数 H(key) 之外，多准备⼏个散列函数，当散列函数冲突时，⽤下⼀个散列函数计算⼀个新地址，直到不冲突为⽌</li></ul></blockquote><p>④<strong>伪随机序列法</strong>：</p><p><strong>di为伪随机数序列</strong></p><h1 id="第八章：排序"><a href="#第八章：排序" class="headerlink" title="第八章：排序"></a>第八章：排序</h1><h2 id="1-排序的基本概念"><a href="#1-排序的基本概念" class="headerlink" title="1.排序的基本概念"></a>1.排序的基本概念</h2><p><strong>排序（Sort）</strong> ，就是重新排列表中的元素，使表中的元素满⾜<strong>按关键字有序</strong>的过程。  </p><p><strong>排序算法的评价指标</strong> </p><blockquote><p>算法的<strong>稳定性</strong>。 </p><p>若待排序表中有两个元素Ri和Rj，其对应的关键字相同即keyi &#x3D; keyj，且在排序前Ri在Rj的前⾯，若使⽤某⼀排序算法排序后， Ri仍然在Rj的前⾯，则称这个排序算法是稳定的，否则称排序算法是不稳定的。  </p></blockquote><p><strong>排序算法的分类</strong></p><blockquote><ul><li>内部排序——数据都在内存中</li></ul><p>关注如何使算法时间、空间复杂度更低</p><ul><li>外部排序——数据太多，无法全部放入内存</li></ul><p>还要关注如何使读&#x2F;写磁盘次数更少</p></blockquote><h2 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2.插入排序"></a>2.插入排序</h2><h3 id="2-1-算法思想-1"><a href="#2-1-算法思想-1" class="headerlink" title="2.1 算法思想"></a>2.1 算法思想</h3><p>每次将⼀个待排序的记录按其关键字⼤⼩插⼊到前⾯已排好序的⼦序列中，直到全部记录插⼊完成。  </p><h3 id="2-2-算法实现-1"><a href="#2-2-算法实现-1" class="headerlink" title="2.2 算法实现"></a>2.2 算法实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不带“哨兵”</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span>&#123;   <span class="comment">//A中共n个数据元素</span></span><br><span class="line">    <span class="type">int</span> i,j,temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>])&#123;           <span class="comment">//A[i]关键字小于前驱</span></span><br><span class="line">            temp = A[i];  </span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>; j&gt;=<span class="number">0</span> &amp;&amp; A[j]&gt;temp; --j)</span><br><span class="line">                A[j+<span class="number">1</span>] = A[j];     <span class="comment">//所有大于temp的元素都向后挪</span></span><br><span class="line">            A[j+<span class="number">1</span>] = temp;         <span class="comment">//复制到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带“哨兵”</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span>&#123;          <span class="comment">//A中从1开始存储，0放哨兵</span></span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>])&#123;    </span><br><span class="line">            A[<span class="number">0</span>] = A[i];                  <span class="comment">//复制为哨兵</span></span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>; A[<span class="number">0</span>] &lt; A[j]; --j)  <span class="comment">//从后往前查找待插入位置</span></span><br><span class="line">                A[j+<span class="number">1</span>] = A[j];            <span class="comment">//向后挪动</span></span><br><span class="line">            A[j+<span class="number">1</span>] = A[<span class="number">0</span>];                <span class="comment">//复制到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间效率：空间复杂度&#x3D;O(1)</p><p>时间效率: 平均时间复杂度&#x3D;O(n²)</p><p>稳定性：插入排序是一种稳定的排序方法</p><h3 id="2-3-算法优化"><a href="#2-3-算法优化" class="headerlink" title="2.3 算法优化"></a>2.3 算法优化</h3><p><strong>折半插入排序</strong>：先⽤折半查找找到应该插⼊的位置，再移动元素  </p><p>当 <strong>low&gt;high</strong> 时折半查找停⽌，应将 [low, i-1] 内的元素全部右移，并将 A[0] 复制到 low 所指位置 （即high+1）</p><p>当 <strong>A[mid]&#x3D;&#x3D;A[0]</strong> 时，为了保证算法的“稳定性”，应继续在 mid 所指位置右边寻找插⼊位置  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span>&#123; </span><br><span class="line">    <span class="type">int</span> i,j,low,high,mid;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        A[<span class="number">0</span>] = A[i];                    <span class="comment">//将A[i]暂存到A[0]</span></span><br><span class="line">        low = <span class="number">1</span>; high = i<span class="number">-1</span>;            <span class="comment">//折半查找的范围</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;               <span class="comment">//折半查找</span></span><br><span class="line">            mid = (low + high)/<span class="number">2</span>;       <span class="comment">//取中间点</span></span><br><span class="line">            <span class="keyword">if</span>(A[mid]&gt;A[<span class="number">0</span>])             <span class="comment">//查找左半子表</span></span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>                        <span class="comment">//查找右半子表</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>; j&gt;high+<span class="number">1</span>;--j)        <span class="comment">//统一后移元素，空出插入位置</span></span><br><span class="line">            A[j+<span class="number">1</span>] = A[j];</span><br><span class="line">        A[high+<span class="number">1</span>] = A[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-希尔排序"><a href="#3-希尔排序" class="headerlink" title="3.希尔排序"></a>3.希尔排序</h2><h3 id="3-1-算法思想-1"><a href="#3-1-算法思想-1" class="headerlink" title="3.1 算法思想"></a>3.1 算法思想</h3><p>先追求表中元素部分有序，再逐渐逼近全局有序。</p><p>先将待排序表分割成若⼲形如 L[i, i + d, i + 2d,…, i + kd] 的“特殊”⼦表，对各个⼦表分别进⾏直接插⼊排序。<strong>缩⼩增量d</strong>，重复上述过程，直到d&#x3D;1为⽌。  </p><h3 id="3-2-算法实现-1"><a href="#3-2-算法实现-1" class="headerlink" title="3.2 算法实现"></a>3.2 算法实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="comment">//A[0]为暂存单元，不是哨兵</span></span><br><span class="line">    <span class="keyword">for</span>(d=n/<span class="number">2</span>; d&gt;=<span class="number">1</span>; d=d/<span class="number">2</span>)&#123;   <span class="comment">//步长递减（看具体要求，一般是1/2）</span></span><br><span class="line">        <span class="keyword">for</span>(i=d+<span class="number">1</span>; i&lt;=n; ++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(A[i]&lt;A[i-d])&#123;             <span class="comment">//需将A[i]插入有序增量子表</span></span><br><span class="line">                A[<span class="number">0</span>]=A[i];</span><br><span class="line">                <span class="keyword">for</span>(j=i-d; j&gt;<span class="number">0</span> &amp;&amp; A[<span class="number">0</span>]&lt;A[j];j-=d)</span><br><span class="line">                    A[j+d]=A[j];         <span class="comment">//记录后移，查找插入的位置</span></span><br><span class="line">                A[j+d]=A[<span class="number">0</span>;]             <span class="comment">//插入</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间效率：空间复杂度&#x3D;O(1)</p><p>时间效率: 平均时间复杂度&#x3D;O(n²)</p><p>稳定性：希尔排序是一种不稳定的排序方法</p><h2 id="4-冒泡排序"><a href="#4-冒泡排序" class="headerlink" title="4.冒泡排序"></a>4.冒泡排序</h2><p>冒泡排序是基于交换的排序</p><h3 id="4-1-算法思想-1"><a href="#4-1-算法思想-1" class="headerlink" title="4.1 算法思想"></a>4.1 算法思想</h3><ul><li><p>第一趟排序使关键字值最小的一个元素“冒”到最前面（其最终位置）</p></li><li><p>每趟冒泡的结果是把序列中最小（或最大）元素放到序列的最终位置，这样最多做n-1趟冒泡就能把所有元素排好序；</p></li><li><p>为保证稳定性，关键字相同的元素不交换；</p></li></ul><h3 id="4-2-算法实现"><a href="#4-2-算法实现" class="headerlink" title="4.2 算法实现"></a>4.2 算法实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span>&#123;   <span class="comment">//从0开始存放</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;         <span class="comment">// 表示本趟冒泡是否发生交换的标志</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=n<span class="number">-1</span>; j&gt;i; j--)&#123;  <span class="comment">//一趟冒泡过程</span></span><br><span class="line">            <span class="keyword">if</span>(A[j<span class="number">-1</span>]&gt;A[j])&#123;       <span class="comment">//若为逆序</span></span><br><span class="line">                swap(A[j<span class="number">-1</span>],A[j]); <span class="comment">//交换</span></span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//本趟遍历后没有发生交换，说明表已经有序，可以结束算法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间效率：空间复杂度&#x3D;O(1)</p><p>时间效率: 平均时间复杂度&#x3D;O(n²)</p><p>稳定性：冒泡排序是一种稳定的排序方法</p><h2 id="5-快速排序"><a href="#5-快速排序" class="headerlink" title="5.快速排序"></a>5.快速排序</h2><p>快速排序也是基于交换的排序</p><h3 id="5-1-算法思想"><a href="#5-1-算法思想" class="headerlink" title="5.1 算法思想"></a>5.1 算法思想</h3><p>在待排序表L[1…n]中任取⼀个元素pivot作为枢轴（或基准，通常取⾸元素），</p><p>通过⼀趟排序将待排序表划分为独⽴的两部分L[1…k-1]和L[k+1…n]，使得L[1…k-1]中的所有元素⼩于pivot，L[k+1…n]中的所有元素⼤于等于pivot，则pivot放在了其最终位置L(k)上， 这个过程称为⼀次“划分”。</p><p>然后分别递归地对两个⼦表重复上述过程，直⾄每部分内只有⼀个元素或空为⽌，即所有元素放在了其最终位置上。  </p><h3 id="5-2-算法实现"><a href="#5-2-算法实现" class="headerlink" title="5.2 算法实现"></a>5.2 算法实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用第一个元素将待排序序列划分为左右两个部分</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Partition</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = A[low];     <span class="comment">//用第一个元素作为枢轴</span></span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; A[high]&gt;=pivot) --high; <span class="comment">//high所指元素大于枢轴，high左移</span></span><br><span class="line">        A[low] = A[high];   <span class="comment">//high所指元素小于枢轴，移动到左侧</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; A[low]&lt;=pivot)  ++low;  <span class="comment">//low所指元素小于枢轴，low右移</span></span><br><span class="line">        A[high] = A[low];   <span class="comment">//low所指元素大于枢轴，移动到右侧</span></span><br><span class="line">    &#125;</span><br><span class="line">    A[low] = pivot   <span class="comment">//枢轴元素存放到最终位置</span></span><br><span class="line">    <span class="keyword">return</span> low；     <span class="comment">//返回存放枢轴的最终位置</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="type">void</span> QuickSort(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high) &#123;    <span class="comment">//递归跳出条件</span></span><br><span class="line">        <span class="type">int</span> pivotpos = Partition(A, low, high);   <span class="comment">//划分</span></span><br><span class="line">    QuickSort（A, low, pivotpos - <span class="number">1</span>);         <span class="comment">//划分左子表</span></span><br><span class="line">    QuickSort（A, pivotpos + <span class="number">1</span>, high);        <span class="comment">//划分右子表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间效率：最好空间复杂度&#x3D;O(log₂n)，最坏空间复杂度&#x3D;O(n)</p><p>时间效率: 平均时间复杂度&#x3D;O(nlog₂n)</p><p>稳定性：快速排序是一种不稳定的排序方法</p><p>快速排序是所有内部排序算法中平均性能最优的排序算法</p><h2 id="6-简单选择排序"><a href="#6-简单选择排序" class="headerlink" title="6.简单选择排序"></a>6.简单选择排序</h2><p><strong>简单选择排序</strong> 和 <strong>堆排序</strong> 都属于<strong>选择排序</strong></p><p><strong>选择排序</strong>：每⼀趟在待排序元素中选取关键字最⼩（或最⼤）的元素加⼊有序⼦序列 </p><h3 id="6-1-算法思想"><a href="#6-1-算法思想" class="headerlink" title="6.1 算法思想"></a>6.1 算法思想</h3><p>每⼀趟在待排序元素中选取关键字最⼩的元素加⼊有序⼦序列。</p><h3 id="6-2-算法实现"><a href="#6-2-算法实现" class="headerlink" title="6.2 算法实现"></a>6.2 算法实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简单选择排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span>&#123;       <span class="comment">//A从0开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;          <span class="comment">//一共进行n-1趟，i指向待排序序列中第一个元素</span></span><br><span class="line">        <span class="type">int</span> min = i;                   <span class="comment">//记录最小元素位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;n; j++)&#123;      <span class="comment">//在A[i...n-1]中选择最小的元素</span></span><br><span class="line">            <span class="keyword">if</span>(A[j]&lt;A[min])&#123;</span><br><span class="line">                min = j;               <span class="comment">//更新最小元素位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min!=i)                     </span><br><span class="line">            swap(A[i],A[min]);         <span class="comment">//交换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间效率：空间复杂度&#x3D;O(1)</p><p>时间效率：时间复杂度&#x3D;O(n²)</p><p>稳定性：简单选择排序是一种不稳定的排序方法</p><h2 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7.堆排序"></a>7.堆排序</h2><p><strong>堆排序</strong>是<strong>选择排序</strong>中的一种</p><p><strong>什么是堆？</strong></p><blockquote><p>若n个关键字序列L[1…n] 满⾜下⾯某⼀条性质，则称为堆（Heap） ：</p><p>① 若满⾜：L(i)≥L(2i) 且 L(i)≥L(2i+1) （1 ≤ i ≤n&#x2F;2 ） —— ⼤根堆（⼤顶堆）</p><p>② 若满⾜：L(i)≤L(2i) 且 L(i)≤L(2i+1) （1 ≤ i ≤n&#x2F;2 ） —— ⼩根堆（⼩顶堆）  </p><p>堆从逻辑上来看，就是一棵顺序存储的完全二叉树</p><p>大根堆：完全二叉树中，根≥左、右</p><p>大根堆：完全二叉树中，根≤左、右</p><p>注意：<strong>在顺序存储的完全⼆叉树中， ⾮终端结点编号 i≤⌊n&#x2F;2⌋</strong>  </p><p>​i 的左孩子 2i ；i 的右孩子 2i+1 ；i 的父节点 [i&#x2F;2] ；</p></blockquote><h3 id="7-1-算法思想"><a href="#7-1-算法思想" class="headerlink" title="7.1 算法思想"></a>7.1 算法思想</h3><p>每一趟在待排序元素中选取关键字最小（或最大）的元素加入有序子序列，堆顶元素的关键字最大或最小 （以下以大根堆为例）</p><p>① 将给定初始序列(n个元素)，<strong>建立初始大根堆</strong>：把所有非终端结点 从后往前都检查一遍，是否满足大根堆的要求——根 ≥ 左、右，若不满足，则将当前结点与更大的孩子互换</p><p>② <strong>基于大根堆进行排序</strong>：每一趟将堆顶元素加入有序子序列中，堆顶元素与待排序序列中最后一个元素交换后，即最大元素换到末尾，之后该位置就不用改变，即移出完全二叉树(len&#x3D;len-1)，把剩下的待排序元素序列再调整为大根堆；————“一趟处理”</p><p>③ 剩下最后一个元素则不需要再调整；</p><h3 id="7-2-算法实现"><a href="#7-2-算法实现" class="headerlink" title="7.2 算法实现"></a>7.2 算法实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对初始序列建立大根堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BuildMaxHeap</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len/<span class="number">2</span>; i&gt;<span class="number">0</span>; i--)        <span class="comment">//从后往前调整所有非终端结点</span></span><br><span class="line">        HeadAdjust(A, i, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将以k为根的子树调整为大根堆</span></span><br><span class="line"><span class="comment">从最底层的分支结点开始调整*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeadAdjust</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> k, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    A[<span class="number">0</span>] = A[k];                      <span class="comment">//A[0]暂存子树的根结点</span></span><br><span class="line">    <span class="comment">//i为当前所选根结点的左孩子，i*=2是为了判断调整后再下一层是否满足大根堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>*k; i&lt;=len; i*=<span class="number">2</span>)&#123;     <span class="comment">//沿key较大的子结点向下筛选</span></span><br><span class="line">        <span class="comment">//i&lt;len是为了保证i是有右兄弟的</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;len &amp;&amp; A[i]&lt;A[i+<span class="number">1</span>])      <span class="comment">//判断：当前所选根结点的左、右结点哪个更大</span></span><br><span class="line">            i++;                      <span class="comment">//取key较大的子结点的下标</span></span><br><span class="line">        <span class="keyword">if</span>(A[<span class="number">0</span>] &gt;= A[i]) </span><br><span class="line">            <span class="keyword">break</span>;                    <span class="comment">//筛选结束：i指向更大的子结点</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            A[k] = A[i];              <span class="comment">//将A[i]调整至双亲结点上</span></span><br><span class="line">            k=i;                      <span class="comment">//修改k值，以便继续向下筛选</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k] = A[<span class="number">0</span>]                       <span class="comment">//被筛选的结点的值放入最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="type">void</span> swap(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基于大根堆进行排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    BuildMaxHeap(A, len);          <span class="comment">//初始建堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len; i&gt;<span class="number">1</span>; i--)&#123;      <span class="comment">//n-1趟的交换和建堆过程</span></span><br><span class="line">        swap(A[i], A[<span class="number">1</span>]);          <span class="comment">//堆顶元素和堆底元素交换</span></span><br><span class="line">        HeadAdjust(A,<span class="number">1</span>,i<span class="number">-1</span>);       <span class="comment">//把剩余的待排序元素整理成堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间效率：空间复杂度&#x3D;O(1)</p><p>时间效率: 平均时间复杂度&#x3D;O(nlog₂n)</p><p>稳定性：堆排序是一种不稳定的排序方法</p><h2 id="8-归并排序"><a href="#8-归并排序" class="headerlink" title="8.归并排序"></a>8.归并排序</h2><p>归并：把两个或多个已经有序的序列合并成一个</p><h3 id="8-1-算法思想"><a href="#8-1-算法思想" class="headerlink" title="8.1 算法思想"></a>8.1 算法思想</h3><p>k路归并：每选出一个元素，需对比关键字k-1次；</p><p>外部排序通常采用归并排序，内部排序一般采用2路归并；</p><h3 id="8-2-算法实现"><a href="#8-2-算法实现" class="headerlink" title="8.2 算法实现"></a>8.2 算法实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建辅助数组B</span></span><br><span class="line"><span class="type">int</span> *B=(<span class="type">int</span> *)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//A[low,...,mid],A[mid+1,...,high] 各自有序，将这两个部分归并</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(k=low; k&lt;=high; k++)&#123;</span><br><span class="line">        B[k] = A[k];     <span class="comment">//将A中所有元素复制到B中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=low, j=mid+<span class="number">1</span>, k=i; i&lt;=mid &amp;&amp; j&lt;= high; k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(B[i]&lt;=B[j])   <span class="comment">//为保证稳定性两个元素相等，优先使用靠前的那个</span></span><br><span class="line">            A[k]=B[i++]; <span class="comment">//将较小值复制到A中</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            A[k]=B[j++];</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">//没有归并完的部分复制到尾部，while只会执行一个 </span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)  A[k++]=B[i++];     <span class="comment">//若第一个表未检测完，复制</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;=high) A[k++]=B[j++];     <span class="comment">//若第二个表未检测完，复制</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (low+high)/<span class="number">2</span>;    <span class="comment">//从中间划分</span></span><br><span class="line">        MergeSort(A, low, mid);    <span class="comment">//对左半部分归并排序</span></span><br><span class="line">        MergeSort(A, mid+<span class="number">1</span>, high); <span class="comment">//对右半部分归并排序</span></span><br><span class="line">        Merge(A,low,mid,high);     <span class="comment">//归并</span></span><br><span class="line">    &#125;<span class="keyword">if</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间效率：空间复杂度&#x3D;O(n)</p><p>时间效率: 平均时间复杂度&#x3D;O(nlog₂n)</p><p>稳定性：堆排序是一种稳定的排序方法</p><h2 id="9-基数排序"><a href="#9-基数排序" class="headerlink" title="9.基数排序"></a>9.基数排序</h2><h3 id="9-1-算法思想"><a href="#9-1-算法思想" class="headerlink" title="9.1 算法思想"></a>9.1 算法思想</h3><p>基数排序是一种<strong>非比较</strong>的<strong>稳定</strong>的算法，其原理是将整数<strong>按每个位数分别比较</strong>。它利用了桶的思想。</p><h3 id="9-2-算法实现"><a href="#9-2-算法实现" class="headerlink" title="9.2 算法实现"></a>9.2 算法实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10<span class="comment">//数组长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> D 10<span class="comment">//最大位数</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetDigit</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> i)</span> <span class="comment">//取整数M的第i位数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(i &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">M /= <span class="number">10</span>;</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> M % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RadixSort</span><span class="params">(<span class="type">int</span> num[], <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i, j, k, l, digit;</span><br><span class="line"><span class="type">int</span> allot[<span class="number">10</span>][N];<span class="comment">//《分配数组》</span></span><br><span class="line"><span class="built_in">memset</span>(allot, <span class="number">0</span>, <span class="keyword">sizeof</span>(allot));<span class="comment">//初始化《分配数组》</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= D; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//分配相应位数的数据，并存入《分配数组》</span></span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">&#123;</span><br><span class="line">digit = GetDigit(num[j], i);</span><br><span class="line">k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(allot[digit][k])</span><br><span class="line">k++;</span><br><span class="line">allot[digit][k] = num[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将《分配数组》的数据依次收集到原数组中</span></span><br><span class="line">l = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(allot[j][k] &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">num[l++] = allot[j][k];</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//每次分配，收集后初始化“分配数组”，用于下一位数的分配和收集</span></span><br><span class="line"><span class="built_in">memset</span>(allot, <span class="number">0</span>, <span class="keyword">sizeof</span>(allot));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num[N] = &#123;<span class="number">52</span>, <span class="number">20</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">17</span>, <span class="number">39</span>, <span class="number">8</span>, <span class="number">300</span>, <span class="number">60</span>, <span class="number">81</span>&#125;;</span><br><span class="line">RadixSort(num, N);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, num[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-外部排序"><a href="#10-外部排序" class="headerlink" title="10.外部排序"></a>10.外部排序</h2><h3 id="10-1-外部排序的原理"><a href="#10-1-外部排序的原理" class="headerlink" title="10.1 外部排序的原理"></a>10.1 外部排序的原理</h3><p><strong>外部排序</strong>指的是大文件的排序，即待排序的记录存储在外存储器上，待排序的文件<strong>无法一次装入内存</strong>，需要在内存和外部存储器之间<strong>进行多次数据交换</strong>，以达到<strong>排序整个文件</strong>的目的。</p><h3 id="10-2-影响外部排序效率的因素"><a href="#10-2-影响外部排序效率的因素" class="headerlink" title="10.2 影响外部排序效率的因素"></a>10.2 影响外部排序效率的因素</h3><p>外部排序时间开销 &#x3D; 读写外存时间 + 内部排序时间 + 内部归并时间</p><p>可以尝试用<strong>多路归并</strong>，减少归并的趟数，减少读写外村时间。</p><p>如果采用k路平衡归并的策略，，选出一个最小的元素需要对比关键字（k-1）次，同样也会导致内部归并时间的增加。</p><p>①可以用<strong>败者树</strong>，使得k路平衡归并所需要对比关键字次数减少</p><p><strong>败者树</strong>（类似比赛）（k路归并）</p><blockquote><ul><li>可以视为一棵完全二叉树，k个叶子结点分别是当前比较的元素，非叶子结点用来记忆左右子树中的“失败者”，而让胜者往上继续比较，直到根结点。</li><li>构造完败者树后，选出最小（最大）元素，只需要对比关键字[log₂k]次</li></ul></blockquote><p>②也可以用<strong>置换-选择排序</strong>，从而让归并段的总数变少</p><p>③同样可以用<strong>最佳归并树</strong>减少读&#x2F;写次数</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言（进阶）笔记</title>
      <link href="/2025/06/01/C%E8%AF%AD%E8%A8%80%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/06/01/C%E8%AF%AD%E8%A8%80%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章、数据的存储"><a href="#第一章、数据的存储" class="headerlink" title="第一章、数据的存储"></a>第一章、数据的存储</h1><h2 id="1-整型在内存中的存储"><a href="#1-整型在内存中的存储" class="headerlink" title="1.整型在内存中的存储"></a>1.整型在内存中的存储</h2><h3 id="1-1-原码、反码和补码"><a href="#1-1-原码、反码和补码" class="headerlink" title="1.1 原码、反码和补码"></a>1.1 原码、反码和补码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>计算机中的整数有三种表示方法，即原码、反码和补码。</p><p>三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而<strong>数值位负整数的三种表示方法各不相同</strong>。</p><blockquote><p>原码—直接将二进制按照正负数的形式翻译成二进制就可以。</p><p>反码—将原码的符号位不变，其他位依次按位取反就可以得到了。</p><p>补码—反码+1即为补码</p></blockquote><p><strong>数值位正整数的原码、反码、补码都相同</strong>。</p><p><strong>对于整型来说，数据存放内存中其实存放的是补码。</strong></p><p>原因：在计算机系统中，数值一律用补码来表示和存储。原因在于使用补码可以将符号位和数值域统 一处理；</p><p>同时，加法和减法也可以统一处理（CPU只有加法器），另一方面，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。</p><h3 id="1-2-大端和小端"><a href="#1-2-大端和小端" class="headerlink" title="1.2 大端和小端"></a>1.2 大端和小端</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">-10</span>;</span><br><span class="line"><span class="comment">//原码：10000000 00000000 00000000 00001010</span></span><br><span class="line"><span class="comment">//反码：11111111 11111111 11111111 11110101</span></span><br><span class="line"><span class="comment">//补码：11111111 11111111 11111111 11110110</span></span><br><span class="line"><span class="comment">//       f   f    f   f    f   f    f   6</span></span><br><span class="line"><span class="comment">//0x ff ff ff f6</span></span><br><span class="line"><span class="comment">//但是在vs中，a的地址却是f6 ff ff ff</span></span><br></pre></td></tr></table></figure><p>大小端是什么：</p><blockquote><p>大端（存储）模式，是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中；</p><p>小端（存储）模式，是指数据的低位保存在内存的低地址中，而数据的高位，保存在内存的高地址中。</p></blockquote><p>为什么会有大端和小端：</p><blockquote><p>这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8bit。</p><p>但是在C语言中除了8 bit的char之外，还有16 bit的short型，32 bit的long型（要看具体的编译器），另外，对于位数大于8位 的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如何将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。</p><p>例如：一个 16bit 的 short 型 x ，在内存中的地址为 0x0010 ， x 的值为 0x1122 ，那么 0x11 为高字节， 0x22 为低字节。</p><p>对于大端模式，就将 0x11 放在低地址中，即 0x0010 中， 0x22 放在高地址中，即 0x0011 中。小端模式则刚好相反。</p><p>我们常用的 X86 结构是小端模式，而 KEIL C51 则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。</p></blockquote><p>举一个例题：</p><p>请简述大端字节序和小端字节序的概念，设计一个小程序来判断当前机器的字节序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">check_sys</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (*(<span class="type">char</span> *)&amp;i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = check_sys();</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小端\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大端\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码2 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">check_sys</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">    &#125;un;</span><br><span class="line">    un.i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> un.c;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="2-浮点型在内存中的存储"><a href="#2-浮点型在内存中的存储" class="headerlink" title="2.浮点型在内存中的存储"></a>2.浮点型在内存中的存储</h2><h3 id="2-1-浮点数存储的例子"><a href="#2-1-浮点数存储的例子" class="headerlink" title="2.1 浮点数存储的例子"></a>2.1 浮点数存储的例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">9</span>;</span><br><span class="line">    <span class="type">float</span> *pFloat = (<span class="type">float</span> *)&amp;n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n的值为：%d\n&quot;</span>,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*pFloat的值为：%f\n&quot;</span>,*pFloat);</span><br><span class="line">    </span><br><span class="line">    *pFloat = <span class="number">9.0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num的值为：%d\n&quot;</span>,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*pFloat的值为：%f\n&quot;</span>,*pFloat);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>输出结果：</p><p>n的值为：9</p><p>*pFloat的值为：0.000000</p><p>num的值为：1091567616</p><p>*pFloat的值为：9.000000</p><h3 id="2-2-浮点数存储规则"><a href="#2-2-浮点数存储规则" class="headerlink" title="2.2 浮点数存储规则"></a>2.2 浮点数存储规则</h3><p>num 和 *pFloat 在内存中明明是同一个数，为什么浮点数和整数的解读结果会差别这么大？</p><p>要理解这个结果，一定要搞懂浮点数在计算机内部的表示方法。</p><p>详细解读：</p><p>根据国际标准IEEE（电气和电子工程协会） 754，任意一个二进制浮点数V可以表示成下面的形式：</p><blockquote><p>(-1)^S * M * 2^E</p><p>(-1)^s表示符号位，当s&#x3D;0，V为正数；当s&#x3D;1，V为负数。</p><p>M表示有效数字，大于等于1，小于2。</p><p>2^E表示指数位。</p></blockquote><p>举例：</p><p>十进制的5.0，写成二进制是 101.0 ，相当于 1.01×2^2 。</p><p>那么，按照上面V的格式，可以得出s&#x3D;0，M&#x3D;1.01，E&#x3D;2。</p><p>十进制的-5.0，写成二进制是-101.0 ，相当于-1.01×2^2 。</p><p>那么，s&#x3D;1，M&#x3D;1.01，E&#x3D;2。</p><p><strong>IEEE 754规定：</strong></p><p>对于32位的浮点数，最高的1位是符号位s，接着的8位是指数E，剩下的23位为有效数字M。 </p><p>对于64位的浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。</p><p><strong>IEEE 754对有效数字M和指数E，还有一些特别规定：</strong></p><p>前面说过， 1≤M&lt;2 ，也就是说，M可以写成 1.xxxxxx 的形式，其中xxxxxx表示小数部分。</p><p>IEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分。</p><p>比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的是为了节省1位有效数字。</p><p>以32位浮点数为例，留给M只有23位， 将第一位的1舍去以后，等于可以保存24位有效数字。</p><p><strong>至于指数E，情况就比较复杂：</strong></p><p>首先，E为一个无符号整数（unsigned int）。</p><p>这意味着，如果E为8位，它的取值范围为0<del>255；如果E为11位，它的取值范围为0</del>2047。</p><p>但是，我们知道，科学计数法中的E是可以出现负数的，所以IEEE 754规定，存入内存时E的真实值必须再加上一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。</p><p>比如，2^10的E是10，所以保存成32位浮点数时，必须保存成10+127&#x3D;137，即10001001。</p><p><strong>然后，指数E从内存中取出还可以再分成三种情况：</strong> </p><p>①E不全为0或不全为1</p><blockquote><p>这时，浮点数就采用下面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1。</p><p>比如：</p><p>0.5（1&#x2F;2）的二进制形式为0.1，由于规定正数部分必须为1，即将小数点右移1位，则为 1.0*2^(-1)，其阶码为-1+127&#x3D;126，表示为 01111110，而尾数1.0去掉整数部分为0，补齐0到23位00000000000000000000000，则其二进制表示形式为:</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">01111110</span> <span class="number">00000000000000000000000</span> </span><br></pre></td></tr></table></figure><p>②E全为0</p><blockquote><p>这时，浮点数的指数E等于1-127（或者1-1023）即为真实值，有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。</p></blockquote><p>③E全为1</p><blockquote><p>这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）；</p></blockquote><p><strong>解释一开始的例子：</strong></p><p>为什么 0x00000009 还原成浮点数，就成了 0.000000 ？</p><p>首先，将 0x00000009 拆分，得到第一位符号位s&#x3D;0，后面8位的指数 E&#x3D;00000000 ，最后23位的有效数字M&#x3D;000 0000 0000 0000 0000 1001。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span> -&gt; <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1001</span></span><br></pre></td></tr></table></figure><p>由于指数E全为0，所以符合上一节的第二种情况。因此，浮点数V就写成：</p><p>  V&#x3D;(-1)^0 × 0.00000000000000000001001×2^(-126)&#x3D;1.001×2^(-146)</p><p>显然，V是一个很小的接近于0的正数，所以用十进制小数表示就是0.000000。</p><p>浮点数9.0，如何用二进制表示？还原成十进制又是多少？</p><p>首先，浮点数9.0等于二进制的1001.0，即1.001×2^3</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9.0</span> -&gt; <span class="number">1001.0</span> -&gt;(<span class="number">-1</span>)^<span class="number">01.0012</span>^<span class="number">3</span> -&gt; s=<span class="number">0</span>, M=<span class="number">1.001</span>,E=<span class="number">3</span>+<span class="number">127</span>=<span class="number">130</span></span><br></pre></td></tr></table></figure><p>那么，第一位的符号位s&#x3D;0，有效数字M等于001后面再加20个0，凑满23位，指数E等于3+127&#x3D;130， 即10000010。所以，写成二进制形式，应该是s+E+M，即</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">10000010</span> <span class="number">001</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> </span><br></pre></td></tr></table></figure><p>这个32位的二进制数，还原成十进制，正是1091567616 。</p><h1 id="第二章、指针的进阶"><a href="#第二章、指针的进阶" class="headerlink" title="第二章、指针的进阶"></a>第二章、指针的进阶</h1><h2 id="1-字符指针"><a href="#1-字符指针" class="headerlink" title="1.字符指针"></a>1.字符指针</h2><p>在指针的类型中我们知道有一种指针类型为字符指针 char* ;</p><blockquote><p>注意：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* pstr = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure><p>这里并不是把字符串 hello 放到字符指针 pstr 里了，本质是把字符串 hello 首字符的地址放到了 pstr 中。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str1[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str3 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str4 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(str1 ==str2)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;str1 and str2 are same\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;str1 and str2 are not same\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(str3 ==str4)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;str3 and str4 are same\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;str3 and str4 are not same\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//str1 and str2 are not same</span></span><br><span class="line"><span class="comment">//str3 and str4 are same</span></span><br></pre></td></tr></table></figure><p>这里str3和str4指向的是一个同一个常量字符串。</p><p>C&#x2F;C++会把常量字符串存储到单独的一个内存区域，当几个指针。指向同一个字符串的时候，他们实际会指向同一块内存。但是用相同的常量字符串去初始化不同的数组的时候就会开辟出不同的内存块。</p><p>所以str1和str2不同，str3和str4相同。</p><h2 id="2-指针数组"><a href="#2-指针数组" class="headerlink" title="2.指针数组"></a>2.指针数组</h2><p>指针数组是一个存放指针的数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* arr1[<span class="number">10</span>]; <span class="comment">//整形指针的数组</span></span><br><span class="line"><span class="type">char</span>* arr2[<span class="number">10</span>]; <span class="comment">//一级字符指针的数组</span></span><br><span class="line"><span class="type">char</span>** arr3[<span class="number">10</span>];<span class="comment">//二级字符指针的数组</span></span><br></pre></td></tr></table></figure><h2 id="3-数组指针"><a href="#3-数组指针" class="headerlink" title="3.数组指针"></a>3.数组指针</h2><h3 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h3><p>数组指针是<strong>指针</strong>，是能够指向数组的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//解释：p先和*结合，说明p是一个指针变量，然后指着指向的是一个大小为10个整型的数组。所以p是一个指针，指向一个数组，叫数组指针。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里要注意：[]的优先级要高于*号的，所以必须加上（）来保证p先和*结合。</span></span><br></pre></td></tr></table></figure><h3 id="3-2-“数组名”-vs-“-数组名”"><a href="#3-2-“数组名”-vs-“-数组名”" class="headerlink" title="3.2 “数组名” vs “&amp;数组名”"></a>3.2 “数组名” vs “&amp;数组名”</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>arr 和 &amp;arr 是一样的东西吗？</p><p>举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arr = %p\n&quot;</span>, arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arr+1 = %p\n&quot;</span>, arr+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;arr= %p\n&quot;</span>, &amp;arr); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;arr+1= %p\n&quot;</span>, &amp;arr+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>结果：</p><blockquote><p>arr &#x3D; 012FF6EC</p><p>arr+1 &#x3D; 012FF6F0</p><p>&amp;arr&#x3D; 012FF6EC</p><p>&amp;arr+1&#x3D; 012FF714</p></blockquote><p>从上面代码的结果可知：&amp;arr和arr，有同样的数值，但本质上是不同的。</p><p><strong>实际上：</strong></p><p>arr是数组名，数组名表示数组首元素的地址。</p><p>&amp;arr 表示的是数组的地址，而不是数组首元素的地址。</p><p>本例中 &amp;arr 的类型是： int(*)[10] ，是一种数组指针类型</p><p>数组的地址+1，跳过整个数组的大小，所以 &amp;arr+1 相对于 &amp;arr 的差值是40.</p><h2 id="4-函数指针"><a href="#4-函数指针" class="headerlink" title="4.函数指针"></a>4.函数指针</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, test);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;test);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><blockquote><p>003A1474</p><p>003A1474</p></blockquote><p>输出了两个地址，这两个地址是 test 函数的地址。那么，如何保存函数的地址呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hehe\n&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">void</span> (*pfun)(); <span class="comment">//pfun是指针，指向一个函数</span></span><br></pre></td></tr></table></figure><p>补充两段有趣的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码1</span></span><br><span class="line">( *( <span class="type">void</span> (*)() )<span class="number">0</span> )();</span><br><span class="line"><span class="comment">//把0强制转换成无参无返回值的函数指针类型，然后将0解引用后调用</span></span><br><span class="line"><span class="comment">//就是调用0地址处的函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//代码2</span></span><br><span class="line"><span class="type">void</span> ( *signal( <span class="type">int</span> , <span class="type">void</span>(*)(<span class="type">int</span>) ) )(<span class="type">int</span>);</span><br><span class="line"><span class="comment">//signal是一个函数声明</span></span><br><span class="line"><span class="comment">//这个函数参数有2个，一个是int，另一个是函数指针，该指针指向的函数参数为int，返回类型是void</span></span><br><span class="line"><span class="comment">//signal函数的返回类型也是函数指针，该指针指向的函数参数int，返回类型是void</span></span><br><span class="line"><span class="comment">//简化版本</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(* <span class="type">pfun_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">pfun_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span>,<span class="type">pfun_t</span>)</span>;</span><br></pre></td></tr></table></figure><h2 id="5-函数指针数组"><a href="#5-函数指针数组" class="headerlink" title="5.函数指针数组"></a>5.函数指针数组</h2><p>数组是一个存放相同类型数据的存储空间，指针数组是一个存放指针的数组。</p><p>那如果把函数的地址存到一个数组中，这个数组就叫函数指针数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*parr[<span class="number">10</span>])();</span><br></pre></td></tr></table></figure><p>函数指针数组的用途：<strong>转移表</strong></p><p>实例：</p><p>使用函数指针数组实现计算器。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a/b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">int</span> input = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>(*p[<span class="number">5</span>])(<span class="type">int</span> x, <span class="type">int</span> y) = &#123; <span class="number">0</span>, add, sub, mul, div &#125;; <span class="comment">//转移表     </span></span><br><span class="line">    <span class="keyword">while</span> (input)&#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;*************************\n&quot;</span> );</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;  1:add           2:sub  \n&quot;</span> );</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;  3:mul           4:div  \n&quot;</span> );</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;*************************\n&quot;</span> );</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;请选择：&quot;</span> );</span><br><span class="line">        <span class="built_in">scanf</span>( <span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">        <span class="keyword">if</span> ((input &lt;= <span class="number">4</span> &amp;&amp; input &gt;= <span class="number">1</span>))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入操作数：&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">            ret = (*p[input])(x, y);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>( <span class="string">&quot;输入有误\n&quot;</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-指向函数指针数组的指针"><a href="#6-指向函数指针数组的指针" class="headerlink" title="6.指向函数指针数组的指针"></a>6.指向函数指针数组的指针</h2><p>指向函数指针数组的指针是一个指针</p><p>指针指向一个数组 ，数组的元素都是函数指针  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//函数指针pfun</span></span><br><span class="line"><span class="type">void</span> (*pfun)(<span class="type">const</span> <span class="type">char</span>*) = test;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//函数指针的数组pfunArr</span></span><br><span class="line"><span class="type">void</span> (*pfunArr[<span class="number">5</span>])(<span class="type">const</span> <span class="type">char</span>* str);</span><br><span class="line">pfunArr[<span class="number">0</span>] = test;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//指向函数指针数组pfunArr的指针ppfunArr</span></span><br><span class="line"><span class="type">void</span> (*(*ppfunArr)[<span class="number">5</span>])(<span class="type">const</span> <span class="type">char</span>*) = &amp;pfunArr;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-回调函数"><a href="#7-回调函数" class="headerlink" title="7.回调函数"></a>7.回调函数</h2><p>回调函数就是一个通过函数指针调用的函数。</p><p>如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。</p><p>回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。  </p><p>举个例子：</p><p>首先先演示一下qsort函数（快速排序）的使用：</p><p>qsot函数可以排序任意类型的数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//qosrt函数的使用者须实现一个比较函数</span></span><br><span class="line"><span class="comment">//void*是一种无具体类型的指针</span></span><br><span class="line"><span class="comment">//void*的指针变量可以存放任意类型的地址</span></span><br><span class="line"><span class="comment">//void*的指针不能直接进行解引用、 +-*/ 操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">int_cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> * p1, <span class="type">const</span> <span class="type">void</span> * p2)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> (*( <span class="type">int</span> *)p1 - *(<span class="type">int</span> *) p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">qsort(arr, <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), <span class="keyword">sizeof</span> (<span class="type">int</span>), int_cmp);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i&lt; <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用回调函数，模拟实现qsort（采用冒泡的方式）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//比较函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">int_cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> * p1, <span class="type">const</span> <span class="type">void</span> * p2)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> (*( <span class="type">int</span> *)p1 - *(<span class="type">int</span> *) p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> _swap(<span class="type">void</span> *p1, <span class="type">void</span> * p2, <span class="type">int</span> size)&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i&lt; size; i++)&#123;</span><br><span class="line"><span class="type">char</span> tmp = *((<span class="type">char</span> *)p1 + i);</span><br><span class="line">*(( <span class="type">char</span> *)p1 + i) = *((<span class="type">char</span> *) p2 + i);</span><br><span class="line">*(( <span class="type">char</span> *)p2 + i) = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bubble</span><span class="params">(<span class="type">void</span> *base, <span class="type">int</span> count , <span class="type">int</span> size, <span class="type">int</span>(*cmp )(<span class="type">void</span> *, <span class="type">void</span> *))</span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt; count - <span class="number">1</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;count-i<span class="number">-1</span>; j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (cmp ((<span class="type">char</span> *) base + j*size , (<span class="type">char</span> *)base + (j + <span class="number">1</span>)*size) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">_swap(( <span class="type">char</span> *)base + j*size, (<span class="type">char</span> *)base + (j + <span class="number">1</span>)*size, size);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//char *arr[] = &#123;&quot;aaaa&quot;,&quot;dddd&quot;,&quot;cccc&quot;,&quot;bbbb&quot;&#125;;</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">bubble(arr, <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), <span class="keyword">sizeof</span> (<span class="type">int</span>), int_cmp);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i&lt; <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-指针和数组的笔试题"><a href="#8-指针和数组的笔试题" class="headerlink" title="8.指针和数组的笔试题"></a>8.指针和数组的笔试题</h2><p>X86环境</p><p>（X86环境下地址大小为4，X64环境下地址大小为8）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一维数组</span></span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(a));        <span class="comment">//16（数组名a单独放在sizeof内部，计算整个数组的大小）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(a+<span class="number">0</span>));      <span class="comment">//4 （a表示首元素的地址，a+0同样表示首元素的地址）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(*a));       <span class="comment">//4 （*a表示对首元素地址的解引用）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(a+<span class="number">1</span>));      <span class="comment">//4 （a表示首元素的地址，a+1表示第二个元素的地址）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(a[<span class="number">1</span>]));     <span class="comment">//4 （a[1]是数组的第二个元素）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;a));       <span class="comment">//4 （&amp;a表示数组的地址）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(*&amp;a));      <span class="comment">//16（*&amp;a表示对数组的地址的解引用）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;a+<span class="number">1</span>));     <span class="comment">//4 （&amp;a+1跳过整个数组后的地址）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;a[<span class="number">0</span>]));    <span class="comment">//4 （&amp;a[0]表示数组第一个元素的地址）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;a[<span class="number">0</span>]+<span class="number">1</span>));  <span class="comment">//4 （&amp;a[0]+1表示数组第二个元素的地址）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符数组</span></span><br><span class="line"><span class="type">char</span> arr[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr));        <span class="comment">//6</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr+<span class="number">0</span>));      <span class="comment">//4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(*arr));       <span class="comment">//1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr[<span class="number">1</span>]));     <span class="comment">//1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr));       <span class="comment">//4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr+<span class="number">1</span>));     <span class="comment">//4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr[<span class="number">0</span>]+<span class="number">1</span>));  <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(arr));        <span class="comment">//随机值，因为末尾没有&#x27;\0&#x27;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(arr+<span class="number">0</span>));      <span class="comment">//随机值，因为末尾没有&#x27;\0&#x27;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(*arr));       <span class="comment">//报错，strlen会把97（&#x27;a&#x27;的ascii值）作为起始地址统计字符串，内存访问冲突</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(arr[<span class="number">1</span>]));     <span class="comment">//报错，同上</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;arr));       <span class="comment">//报错，&amp;arr是arr数组的地址，与形参参数 类型不符合</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;arr+<span class="number">1</span>));     <span class="comment">//报错，同上</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;arr[<span class="number">0</span>]+<span class="number">1</span>));  <span class="comment">//随机值，因为末尾没有&#x27;\0&#x27;</span></span><br><span class="line"><span class="comment">//sizeof是操作符，任意类型均可</span></span><br><span class="line"><span class="comment">//sizeof获取了数据在内存中所占用的存储空间，以字节为单位来计数</span></span><br><span class="line"><span class="comment">//strlen是库函数，针对字符串</span></span><br><span class="line"><span class="comment">//strlen关注字符串中&#x27;\0&#x27;的位置，计算的是&#x27;\0&#x27;前出现了多少个字符</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> arr[] = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr));        <span class="comment">//7</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr+<span class="number">0</span>));      <span class="comment">//4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(*arr));       <span class="comment">//1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr[<span class="number">1</span>]));     <span class="comment">//1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr));       <span class="comment">//4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr+<span class="number">1</span>));     <span class="comment">//4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr[<span class="number">0</span>]+<span class="number">1</span>));  <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(arr));        <span class="comment">//6</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(arr+<span class="number">0</span>));      <span class="comment">//6</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(*arr));       <span class="comment">//报错，strlen会把97（&#x27;a&#x27;的ascii值）作为起始地址统计字符串，内存访问冲突</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(arr[<span class="number">1</span>]));     <span class="comment">//报错，同上</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;arr));       <span class="comment">//报错，&amp;arr是arr数组的地址，与形参参数 类型不符合</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;arr+<span class="number">1</span>));     <span class="comment">//报错，同上</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;arr[<span class="number">0</span>]+<span class="number">1</span>));  <span class="comment">//5</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *p = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(p));          <span class="comment">//4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(p+<span class="number">1</span>));        <span class="comment">//4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(*p));         <span class="comment">//1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(p[<span class="number">0</span>]));       <span class="comment">//1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;p));         <span class="comment">//4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;p+<span class="number">1</span>));       <span class="comment">//4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;p[<span class="number">0</span>]+<span class="number">1</span>));    <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(p));          <span class="comment">//6</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(p+<span class="number">1</span>));        <span class="comment">//5</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(*p));         <span class="comment">//报错</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(p[<span class="number">0</span>]));       <span class="comment">//报错</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;p));         <span class="comment">//报错</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;p+<span class="number">1</span>));       <span class="comment">//报错</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;p[<span class="number">0</span>]+<span class="number">1</span>));    <span class="comment">//5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二维数组</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(a));           <span class="comment">//48</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(a[<span class="number">0</span>][<span class="number">0</span>]));     <span class="comment">//4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(a[<span class="number">0</span>]));        <span class="comment">//16</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(a[<span class="number">0</span>]+<span class="number">1</span>));      <span class="comment">//4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(*(a[<span class="number">0</span>]+<span class="number">1</span>)));   <span class="comment">//4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(a+<span class="number">1</span>));         <span class="comment">//4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(*(a+<span class="number">1</span>)));      <span class="comment">//16</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;a[<span class="number">0</span>]+<span class="number">1</span>));     <span class="comment">//4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(*(&amp;a[<span class="number">0</span>]+<span class="number">1</span>)));  <span class="comment">//16</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(*a));          <span class="comment">//16</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(a[<span class="number">3</span>]));        <span class="comment">//16</span></span><br></pre></td></tr></table></figure><p><strong>总结</strong>：<br><strong>数组名</strong>的<strong>意义</strong>：</p><blockquote><ol><li>sizeof(数组名)，这里的数组名表示整个数组，计算的是整个数组的大小。</li><li>&amp;数组名，这里的数组名表示整个数组，取出的是整个数组的地址。</li><li>除此之外所有的数组名都表示首元素的地址。</li></ol></blockquote><h2 id="9-指针笔试题"><a href="#9-指针笔试题" class="headerlink" title="9.指针笔试题"></a>9.指针笔试题</h2><blockquote><p>笔试题1</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="type">int</span> *ptr = (<span class="type">int</span> *)(&amp;a + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;%d,%d&quot;</span>, *(a + <span class="number">1</span>), *(ptr - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2,5</span></span><br></pre></td></tr></table></figure><p>笔试题2</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span>&#123;</span></span><br><span class="line"><span class="type">int</span> Num;</span><br><span class="line"><span class="type">char</span> *pcName;</span><br><span class="line"><span class="type">short</span> sDate;</span><br><span class="line"><span class="type">char</span> cha[<span class="number">2</span>];</span><br><span class="line"><span class="type">short</span> sBa[<span class="number">4</span>];</span><br><span class="line">&#125;*p;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, p + <span class="number">0x1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)p + <span class="number">0x1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>*)p + <span class="number">0x1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//00000014</span></span><br><span class="line"><span class="comment">//00000001</span></span><br><span class="line"><span class="comment">//00000004</span></span><br></pre></td></tr></table></figure><p>笔试题3</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">4</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="type">int</span> *ptr1 = (<span class="type">int</span> *)(&amp;a + <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> *ptr2 = (<span class="type">int</span> *)((<span class="type">int</span>)a + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;%x,%x&quot;</span>, ptr1[<span class="number">-1</span>], *ptr2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4,2000000</span></span><br></pre></td></tr></table></figure><p>笔试题4</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">2</span>] = &#123; (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>) &#125;;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = a[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>笔试题5</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span>(*p)[<span class="number">4</span>];</span><br><span class="line">p = a;</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;%p,%d\n&quot;</span>, &amp;p[<span class="number">4</span>][<span class="number">2</span>] - &amp;a[<span class="number">4</span>][<span class="number">2</span>], &amp;p[<span class="number">4</span>][<span class="number">2</span>] - &amp;a[<span class="number">4</span>][<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//FFFFFFFC,-4</span></span><br></pre></td></tr></table></figure><p>笔试题6</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> aa[<span class="number">2</span>][<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line"><span class="type">int</span> *ptr1 = (<span class="type">int</span> *)(&amp;aa + <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> *ptr2 = (<span class="type">int</span> *)(*(aa + <span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;%d,%d&quot;</span>, *(ptr1 - <span class="number">1</span>), *(ptr2 - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//10,5</span></span><br></pre></td></tr></table></figure><p>笔试题7</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">char</span> *a[] = &#123;<span class="string">&quot;work&quot;</span>,<span class="string">&quot;at&quot;</span>,<span class="string">&quot;alibaba&quot;</span>&#125;;</span><br><span class="line"><span class="type">char</span>**pa = a;</span><br><span class="line">pa++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *pa);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//at</span></span><br></pre></td></tr></table></figure><p>笔试题8</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">char</span> *c[] = &#123;<span class="string">&quot;ENTER&quot;</span>,<span class="string">&quot;NEW&quot;</span>,<span class="string">&quot;POINT&quot;</span>,<span class="string">&quot;FIRST&quot;</span>&#125;;</span><br><span class="line"><span class="type">char</span>**cp[] = &#123;c+<span class="number">3</span>,c+<span class="number">2</span>,c+<span class="number">1</span>,c&#125;;</span><br><span class="line"><span class="type">char</span>***cpp = cp;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, **++cpp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *--*++cpp+<span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *cpp[<span class="number">-2</span>]+<span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, cpp[<span class="number">-1</span>][<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//POINT</span></span><br><span class="line"><span class="comment">//ER</span></span><br><span class="line"><span class="comment">//ST</span></span><br><span class="line"><span class="comment">//EW</span></span><br></pre></td></tr></table></figure><h2 id="10-附录（qsort的使用）"><a href="#10-附录（qsort的使用）" class="headerlink" title="10.附录（qsort的使用）"></a>10.附录（qsort的使用）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span><span class="comment">//qsort的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">int_cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> *(<span class="type">int</span>*)a - *(<span class="type">int</span>*)b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">char_cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> *(<span class="type">char</span>*)a - *(<span class="type">char</span>*)b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">double_cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> *(<span class="type">double</span>*)a &gt; *(<span class="type">double</span>*)b ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">struct_cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ((<span class="keyword">struct</span> Student*)a)-&gt;id - ((<span class="keyword">struct</span> Student*)b)-&gt;id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">str_cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(*(<span class="type">char</span>**)a, *(<span class="type">char</span>**)b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//int排序</span></span><br><span class="line"><span class="type">int</span> num[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">2</span> &#125;;</span><br><span class="line">qsort(num, <span class="keyword">sizeof</span>(num) / <span class="keyword">sizeof</span>(num[<span class="number">0</span>]), <span class="keyword">sizeof</span>(num[<span class="number">0</span>]), int_cmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(num) / <span class="keyword">sizeof</span>(num[<span class="number">0</span>]); i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, num[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="comment">//char排序</span></span><br><span class="line"><span class="type">char</span> word[<span class="number">5</span>] = <span class="string">&quot;CADB&quot;</span>;</span><br><span class="line">qsort(word, <span class="keyword">sizeof</span>(word) / <span class="keyword">sizeof</span>(word[<span class="number">0</span>]), <span class="keyword">sizeof</span>(word[<span class="number">0</span>]), char_cmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(word) / <span class="keyword">sizeof</span>(word[<span class="number">0</span>]); i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, word[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="comment">//double排序</span></span><br><span class="line"><span class="type">double</span> in[<span class="number">5</span>] = &#123; <span class="number">1.23</span>,<span class="number">3.14159</span>,<span class="number">2.6</span>,<span class="number">5.74</span>,<span class="number">4.11</span> &#125;;</span><br><span class="line">qsort(in, <span class="keyword">sizeof</span>(in) / <span class="keyword">sizeof</span>(in[<span class="number">0</span>]), <span class="keyword">sizeof</span>(in[<span class="number">0</span>]), double_cmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(in) / <span class="keyword">sizeof</span>(in[<span class="number">0</span>]); i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf &quot;</span>, in[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="comment">//struct排序</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu</span>[3] =</span> &#123; &#123;<span class="number">2</span>,<span class="string">&quot;小明&quot;</span>&#125;,&#123;<span class="number">1</span>,<span class="string">&quot;小李&quot;</span>&#125;,&#123;<span class="number">3</span>,<span class="string">&quot;小红&quot;</span>&#125; &#125;;</span><br><span class="line">qsort(stu, <span class="keyword">sizeof</span>(stu) / <span class="keyword">sizeof</span>(stu[<span class="number">0</span>]), <span class="keyword">sizeof</span>(stu[<span class="number">0</span>]), struct_cmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(stu) / <span class="keyword">sizeof</span>(stu[<span class="number">0</span>]); i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d%s &quot;</span>, stu[i].id,stu[i].name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="comment">//string排序</span></span><br><span class="line"><span class="type">char</span> *str[<span class="number">5</span>] = &#123; <span class="string">&quot;AAA&quot;</span>,<span class="string">&quot;EEE&quot;</span>,<span class="string">&quot;CCC&quot;</span>,<span class="string">&quot;BBB&quot;</span>,<span class="string">&quot;DDD&quot;</span> &#125;;</span><br><span class="line">qsort(str, <span class="keyword">sizeof</span>(str) / <span class="keyword">sizeof</span>(str[<span class="number">0</span>]), <span class="keyword">sizeof</span>(str[<span class="number">0</span>]), str_cmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(str) / <span class="keyword">sizeof</span>(str[<span class="number">0</span>]); i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, str[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第三章、字符串-内存函数"><a href="#第三章、字符串-内存函数" class="headerlink" title="第三章、字符串+内存函数"></a>第三章、字符串+内存函数</h1><p>C语言中对字符和字符串的处理很是频繁，但是C语言本身是没有字符串类型的，字符串通常放在<strong>常量字符串</strong>或者<strong>字符数组</strong>中。<br><strong>字符串常量</strong>适用于那些对它不做修改的字符串函数.  </p><h2 id="1-函数介绍"><a href="#1-函数介绍" class="headerlink" title="1.函数介绍"></a>1.函数介绍</h2><h3 id="1-1-strlen"><a href="#1-1-strlen" class="headerlink" title="1.1 strlen"></a>1.1 strlen</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * str )</span>;</span><br></pre></td></tr></table></figure><ul><li><p>strlen函数返回的是字符串中’\0’前面出现的字符个数（不包含’\0’）</p></li><li><p>strlen函数的返回值为size_t，是无符号的</p></li></ul><blockquote><p>size_t的真实类型与操作系统有关，</p><p>在32位架构中被普遍定义为：typedef  unsigned int size_t;&#x2F;&#x2F;4字节</p><p>而在64位架构中被定义为：typedef  unsigned long size_t;&#x2F;&#x2F;8字节</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* str1 = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* str2 = <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strlen</span>(str2)-<span class="built_in">strlen</span>(str1)&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;str2&gt;str1\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;srt1&gt;str2\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//str2&gt;str1</span></span><br><span class="line"><span class="comment">//因为strlen函数返回值为size_t,strlen(str2)-strlen(str1)的结果也是size_t，所以输出str2&gt;str1</span></span><br></pre></td></tr></table></figure><h3 id="1-2-strcpy"><a href="#1-2-strcpy" class="headerlink" title="1.2 strcpy"></a>1.2 strcpy</h3><p>字符串复制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> * dest, <span class="type">const</span> <span class="type">char</span> * src )</span>;</span><br></pre></td></tr></table></figure><ul><li><p>Copies the C string pointed by source into the array pointed by destination, including the terminating null character (and stopping at that point).</p></li><li><p>源字符串必须以 ‘\0’ 结束。</p></li><li><p>会将源字符串中的 ‘\0’ 拷贝到目标空间。</p></li><li><p>目标空间必须足够大，以确保能存放源字符串。</p></li><li><p>目标空间必须可变</p></li></ul><h3 id="1-3-strcat"><a href="#1-3-strcat" class="headerlink" title="1.3 strcat"></a>1.3 strcat</h3><p>字符串连接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">strcat</span> <span class="params">( <span class="type">char</span> * dest, <span class="type">const</span> <span class="type">char</span> * src )</span>;</span><br></pre></td></tr></table></figure><ul><li><p>Appends a copy of the source string to the destination string. The terminating null character in destination is overwritten by the first character of source, and a null-character is included at the end of the new string formed by the concatenation of both in destination.</p></li><li><p>源字符串必须以 ‘\0’ 结束。</p></li><li><p>目标空间必须有足够的大，能容纳下源字符串的内容。</p></li><li><p>目标空间必须可修改。</p></li></ul><h3 id="1-4-strcmp"><a href="#1-4-strcmp" class="headerlink" title="1.4 strcmp"></a>1.4 strcmp</h3><p>字符串比较</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * str1, <span class="type">const</span> <span class="type">char</span> * str2 )</span>;</span><br></pre></td></tr></table></figure><ul><li><p>This function starts comparing the first character of each string. If they are equal to each other, it continues with the following pairs until the characters differ or until a terminating null-character is reached.  </p></li><li><p>第一个字符串大于第二个字符串，则返回大于0的数字；</p></li><li><p>第一个字符串等于第二个字符串，则返回0；</p></li><li><p>第一个字符串小于第二个字符串，则返回小于0的数字。</p></li></ul><h3 id="1-5-strncpy"><a href="#1-5-strncpy" class="headerlink" title="1.5 strncpy"></a>1.5 strncpy</h3><p>将指定长度的字符串复制到字符数组中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">strncpy</span> <span class="params">( <span class="type">char</span> * destination, <span class="type">const</span> <span class="type">char</span> * source, <span class="type">size_t</span> num )</span>;</span><br></pre></td></tr></table></figure><ul><li><p>Copies the first num characters of source to destination. If the end of the source C string (which is signaled by a null-character) is found before num characters have been copied, destination is padded with zeros until a total of num characters have been written to it.</p></li><li><p>拷贝num个字符从源字符串到目标空间。</p></li><li><p>如果源字符串的长度小于num，则拷贝完源字符串之后，在目标的后边追加0，直到num个。</p></li></ul><h3 id="1-6-strncat"><a href="#1-6-strncat" class="headerlink" title="1.6 strncat"></a>1.6 strncat</h3><p>在字符串的结尾追加n个字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">strncat</span> <span class="params">( <span class="type">char</span> * destination, <span class="type">const</span> <span class="type">char</span> * source, <span class="type">size_t</span> num )</span></span><br></pre></td></tr></table></figure><ul><li><p>Appends the first num characters of source to destination, plus a terminating null-character.</p></li><li><p>If the length of the C string in source is less than num, only the content up to the terminating null-character is copied.</p></li></ul><h3 id="1-7-strncmp"><a href="#1-7-strncmp" class="headerlink" title="1.7 strncmp"></a>1.7 strncmp</h3><p>比较字符串前 n 个字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strncmp</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * str1, <span class="type">const</span> <span class="type">char</span> * str2, <span class="type">size_t</span> num )</span>;</span><br></pre></td></tr></table></figure><ul><li><p>比较到出现另个字符不一样或者一个字符串结束或者num个字符全部比较完 。</p></li><li><table><thead><tr><th>return value</th><th>indicates</th></tr></thead><tbody><tr><td>&lt;0</td><td>the first character that does not match has a <strong>lower</strong> value in str1 than in str2</td></tr><tr><td>0</td><td>the contents of both strings are equal</td></tr><tr><td>&gt;0</td><td>the first character that does not match has a <strong>greater</strong> value in str1 than in str2</td></tr></tbody></table></li></ul><h3 id="1-8-strstr"><a href="#1-8-strstr" class="headerlink" title="1.8 strstr"></a>1.8 strstr</h3><p>返回字符串中首次出现子串的地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">strstr</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> * str2)</span>;</span><br></pre></td></tr></table></figure><ul><li>Returns a pointer to the first occurrence of str2 in str1, or a null pointer if str2 is not part of str1.</li></ul><h3 id="1-9-strtok"><a href="#1-9-strtok" class="headerlink" title="1.9 strtok"></a>1.9 strtok</h3><p>分解字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">strtok</span> <span class="params">( <span class="type">char</span> * str, <span class="type">const</span> <span class="type">char</span> * sep )</span>;</span><br></pre></td></tr></table></figure><ul><li><p>sep参数是个字符串，定义了用作分隔符的字符集合。</p></li><li><p>第一个参数指定一个字符串，它包含了0个或者多个由sep字符串中一个或者多个分隔符分割的标记。  </p></li><li><p>strtok函数找到str中的下一个标记，并将其用 \0 结尾，返回一个指向这个标记的指针。（注：strtok函数会改变被操作的字符串，所以在使用strtok函数切分的字符串一般都是临时拷贝的内容并且可修改。）</p></li><li><p>strtok函数的第一个参数不为 NULL ，函数将找到str中第一个标记，strtok函数将保存它在字符串中的位置。</p></li><li><p>strtok函数的第一个参数为 NULL ，函数将在同一个字符串中被保存的位置开始，查找下一个标记。</p></li><li><p>如果字符串中不存在更多的标记，则返回 NULL 指针。</p></li></ul><h3 id="1-10-strerror"><a href="#1-10-strerror" class="headerlink" title="1.10 strerror"></a>1.10 strerror</h3><p>返回一个指向错误字符串的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">strerror</span> <span class="params">( <span class="type">int</span> errnum )</span>;</span><br></pre></td></tr></table></figure><ul><li>返回错误码，所对应的错误信息。</li></ul><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span>&#123;</span><br><span class="line">   FILE *fp;</span><br><span class="line">   fp = fopen(<span class="string">&quot;file.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span>( fp == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Error: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">   &#125; </span><br><span class="line">  <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//让我们编译并运行上面的程序，这将产生以下结果，因为我们尝试打开一个不存在的文件：</span></span><br><span class="line"><span class="comment">//Error: No such file or directory</span></span><br></pre></td></tr></table></figure><h3 id="1-11-memcpy"><a href="#1-11-memcpy" class="headerlink" title="1.11 memcpy"></a>1.11 memcpy</h3><p>内存拷贝函数，从源内存地址的起始位置开始拷贝若干个字节到目标内存地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">memcpy</span> <span class="params">( <span class="type">void</span> * destination, <span class="type">const</span> <span class="type">void</span> * source, <span class="type">size_t</span> num )</span>;</span><br></pre></td></tr></table></figure><ul><li>函数memcpy从source的位置开始向后复制num个字节的数据到destination的内存位置。</li><li>这个函数在遇到 ‘\0’ 的时候并不会停下来。</li><li><strong>如果source和destination有任何的重叠，复制的结果都是未定义的。</strong>  </li><li>c语言规定，memcpy支持不重叠拷贝就够了，但是<strong>在vs，memcpy也能支持重叠拷贝</strong>。</li></ul><h3 id="1-12-memmove"><a href="#1-12-memmove" class="headerlink" title="1.12 memmove"></a>1.12 memmove</h3><p>拷贝字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">memmove</span> <span class="params">( <span class="type">void</span> * destination, <span class="type">const</span> <span class="type">void</span> * source, <span class="type">size_t</span> num )</span>;</span><br></pre></td></tr></table></figure><ul><li>和memcpy的差别就是memmove函数处理的源内存块和目标内存块是可以重叠的。</li><li><strong>如果源空间和目标空间出现重叠，就得使用memmove函数处理。</strong></li></ul><h3 id="1-13-memcmp"><a href="#1-13-memcmp" class="headerlink" title="1.13 memcmp"></a>1.13 memcmp</h3><p>把存储区 ptr1 和存储区 ptr2 的前 n 个字节进行比较</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span> <span class="params">( <span class="type">const</span> <span class="type">void</span> * ptr1,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="type">void</span> * ptr2,</span></span><br><span class="line"><span class="params"> <span class="type">size_t</span> num )</span>;</span><br></pre></td></tr></table></figure><ul><li><p>比较从ptr1和ptr2指针开始的num个字节。</p></li><li><table><thead><tr><th>return value</th><th>indicates</th></tr></thead><tbody><tr><td>&lt;0</td><td>the first byte that does not match in both memory blocks has a <strong>lower</strong> value in ptr1 than in ptr2 (if evaluated as unsigned char values)</td></tr><tr><td>0</td><td>the contents of both memory blocks are equal</td></tr><tr><td>&gt;0</td><td>the first byte that does not match in both memory blocks has a <strong>greater</strong> value in ptr1 than in ptr2 (if evaluated as unsigned char values)</td></tr></tbody></table></li></ul><h2 id="2-函数的模拟实现"><a href="#2-函数的模拟实现" class="headerlink" title="2.函数的模拟实现"></a>2.函数的模拟实现</h2><h3 id="2-1-模拟实现strlen"><a href="#2-1-模拟实现strlen" class="headerlink" title="2.1 模拟实现strlen"></a>2.1 模拟实现strlen</h3><p>三种方式</p><p>方式1（计数器）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(*str)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式2（无临时变量的计数器，递归）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*str==<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+my_strlen(str+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式3（指针-指针）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">    <span class="type">char</span> *p = s;</span><br><span class="line">    <span class="keyword">while</span>(*p != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p-s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-模拟实现strcpy"><a href="#2-2-模拟实现strcpy" class="headerlink" title="2.2 模拟实现strcpy"></a>2.2 模拟实现strcpy</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src )</span>&#123;</span><br><span class="line">    <span class="type">char</span> *ret = dest;</span><br><span class="line">    assert(dest &amp;&amp; src);</span><br><span class="line">    <span class="keyword">while</span>(*dest++ = *src++);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-模拟实现strcat"><a href="#2-3-模拟实现strcat" class="headerlink" title="2.3 模拟实现strcat"></a>2.3 模拟实现strcat</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strcat</span> <span class="params">( <span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src )</span>&#123;</span><br><span class="line">    <span class="type">char</span> *ret = dest;</span><br><span class="line">    assert(dest &amp;&amp; src);</span><br><span class="line">    <span class="keyword">while</span>(*dest)&#123;</span><br><span class="line">        dest++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*dest++ = *src++);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-模拟实现strstr"><a href="#2-4-模拟实现strstr" class="headerlink" title="2.4 模拟实现strstr"></a>2.4 模拟实现strstr</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strstr</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span>&#123;</span><br><span class="line">    <span class="type">char</span> *cp = (<span class="type">char</span> *)str1;</span><br><span class="line">    <span class="type">char</span> *s1,*s2;</span><br><span class="line">    <span class="keyword">if</span>(!*str2)&#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="type">char</span> *)str1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*cp)&#123;</span><br><span class="line">        s1 = cp;</span><br><span class="line">        s2 = (<span class="type">char</span> *)str2;</span><br><span class="line">        <span class="keyword">while</span>( *s1 &amp;&amp; *s2 &amp;&amp; !(*s1-*s2) )&#123;</span><br><span class="line">            s1++;</span><br><span class="line">            s2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!*str2)&#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="type">char</span> *)str1);</span><br><span class="line">    &#125;</span><br><span class="line">        cp++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-模拟实现strcmp"><a href="#2-5-模拟实现strcmp" class="headerlink" title="2.5 模拟实现strcmp"></a>2.5 模拟实现strcmp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_strcmp</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> * src, <span class="type">const</span> <span class="type">char</span> * dst)</span>&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">assert(dst &amp;&amp; src);</span><br><span class="line"><span class="keyword">while</span>( ! (ret = *(<span class="type">unsigned</span> <span class="type">char</span> *)src - *(<span class="type">unsigned</span> <span class="type">char</span> *)dst) &amp;&amp; *dst)&#123;</span><br><span class="line">        src++;</span><br><span class="line">        dst++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span> ( ret &lt; <span class="number">0</span> )</span><br><span class="line">ret = <span class="number">-1</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( ret &gt; <span class="number">0</span> )</span><br><span class="line">ret = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-模拟实现memcpy"><a href="#2-6-模拟实现memcpy" class="headerlink" title="2.6 模拟实现memcpy"></a>2.6 模拟实现memcpy</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">memcpy</span> <span class="params">( <span class="type">void</span> * dst, <span class="type">const</span> <span class="type">void</span> * src, <span class="type">size_t</span> count)</span>&#123;</span><br><span class="line"><span class="type">void</span> * ret = dst;</span><br><span class="line">assert(dst &amp;&amp; src);</span><br><span class="line"><span class="keyword">while</span> (count--) &#123;</span><br><span class="line">*(<span class="type">char</span> *)dst = *(<span class="type">char</span> *)src;</span><br><span class="line">dst = (<span class="type">char</span> *)dst + <span class="number">1</span>;</span><br><span class="line">src = (<span class="type">char</span> *)src + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.7 模拟实现memmove</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">memmove</span> <span class="params">( <span class="type">void</span> * dst, <span class="type">const</span> <span class="type">void</span> * src, <span class="type">size_t</span> count)</span>&#123;</span><br><span class="line"><span class="type">void</span> * ret = dst;</span><br><span class="line"><span class="keyword">if</span> (dst &lt;= src || (<span class="type">char</span> *)dst &gt;= ((<span class="type">char</span> *)src + count)) &#123;</span><br><span class="line"><span class="keyword">while</span> (count--) &#123;</span><br><span class="line">*(<span class="type">char</span> *)dst = *(<span class="type">char</span> *)src;</span><br><span class="line">dst = (<span class="type">char</span> *)dst + <span class="number">1</span>;</span><br><span class="line">src = (<span class="type">char</span> *)src + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">dst = (<span class="type">char</span> *)dst + count - <span class="number">1</span>;</span><br><span class="line">src = (<span class="type">char</span> *)src + count - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (count--) &#123;</span><br><span class="line">*(<span class="type">char</span> *)dst = *(<span class="type">char</span> *)src;</span><br><span class="line">dst = (<span class="type">char</span> *)dst - <span class="number">1</span>;</span><br><span class="line">src = (<span class="type">char</span> *)src - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第四章、自定义类型详解"><a href="#第四章、自定义类型详解" class="headerlink" title="第四章、自定义类型详解"></a>第四章、自定义类型详解</h1><h2 id="1-结构体"><a href="#1-结构体" class="headerlink" title="1.结构体"></a>1.结构体</h2><p>结构是一些值的集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量。  </p><h3 id="1-1-结构的声明"><a href="#1-1-结构的声明" class="headerlink" title="1.1 结构的声明"></a>1.1 结构的声明</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个描述学生的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>&#123;</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];  <span class="comment">//名字</span></span><br><span class="line"><span class="type">int</span> age;        <span class="comment">//年龄</span></span><br><span class="line"><span class="type">char</span> sex[<span class="number">5</span>];    <span class="comment">//性别</span></span><br><span class="line"><span class="type">char</span> id[<span class="number">20</span>];    <span class="comment">//学号</span></span><br><span class="line">&#125;;                  <span class="comment">//分号不能丢</span></span><br></pre></td></tr></table></figure><p>在声明结构的时候，可以不完全的声明（省略结构体的标签）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">char</span> b;</span><br><span class="line"><span class="type">float</span> c;</span><br><span class="line">&#125;x;</span><br></pre></td></tr></table></figure><h3 id="1-2-结构的自引用"><a href="#1-2-结构的自引用" class="headerlink" title="1.2  结构的自引用"></a>1.2  结构的自引用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-3-结构体变量的定义与初始化"><a href="#1-3-结构体变量的定义与初始化" class="headerlink" title="1.3 结构体变量的定义与初始化"></a>1.3 结构体变量的定义与初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line">&#125;p1;                <span class="comment">//声明类型的同时定义变量p1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">p2</span>;</span>    <span class="comment">//定义结构体变量p2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化：定义变量的同时赋初值。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">p3</span> =</span> &#123;x, y&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>&#123;</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">15</span>];  <span class="comment">//名字</span></span><br><span class="line"><span class="type">int</span> age;        <span class="comment">//年龄</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">s</span> =</span> &#123;<span class="string">&quot;zhangsan&quot;</span>, <span class="number">20</span>&#125;;     <span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">p</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;n1 = &#123;<span class="number">10</span>, &#123;<span class="number">4</span>,<span class="number">5</span>&#125;, <span class="literal">NULL</span>&#125;;            <span class="comment">//结构体嵌套初始化</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">n2</span> =</span> &#123;<span class="number">20</span>, &#123;<span class="number">5</span>, <span class="number">6</span>&#125;, <span class="literal">NULL</span>&#125;;<span class="comment">//结构体嵌套初始化</span></span><br></pre></td></tr></table></figure><h3 id="1-4-结构体内存对齐"><a href="#1-4-结构体内存对齐" class="headerlink" title="1.4 结构体内存对齐"></a>1.4 结构体内存对齐</h3><p>结构体中元素是按照定义顺序一个一个放到内存中去的，但并不是紧密排列的。</p><p><strong>结构体的对齐规则</strong>：</p><p>1.<strong>第一个成员在与结构体变量偏移量为0的地址处。</strong></p><p>2.<strong>其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。</strong></p><p>（对齐数 &#x3D; 编译器默认的一个对齐数 与 该成员大小的较小值）</p><p>3.结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍。</p><p>4.如果<strong>嵌套了结构体</strong>的情况，嵌套的结构体对齐到<strong>自己的最大对齐数的整数倍</strong>处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。  </p><p><strong>为什么存在内存对齐？</strong></p><p>大部份资料都是这样说的</p><p>1.<strong>平台</strong>原因(移植原因)：</p><p>不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。 </p><p>2.<strong>性能</strong>原因：</p><p>数据结构(尤其是栈)应该尽可能地在自然边界上对齐。</p><p>原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问  </p><blockquote><p>总体来说，结构体的内存对齐是<strong>拿空间来换取时间</strong>的做法。  </p><p>所以我们在设计结构体时，应该<strong>让占用空间小的成员尽量集中在一起</strong>。  </p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//练习1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span>&#123;</span></span><br><span class="line"><span class="type">char</span> c1;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">char</span> c2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> S1));</span><br><span class="line"><span class="comment">//12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//练习2</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span>&#123;</span></span><br><span class="line"><span class="type">char</span> c1;</span><br><span class="line"><span class="type">char</span> c2;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> S2));</span><br><span class="line"><span class="comment">//8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//练习3</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S3</span>&#123;</span></span><br><span class="line"><span class="type">double</span> d;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> S3));</span><br><span class="line"><span class="comment">//16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//练习4-结构体嵌套问题</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S4</span>&#123;</span></span><br><span class="line"><span class="type">char</span> c1;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S3</span> <span class="title">s3</span>;</span></span><br><span class="line"><span class="type">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> S4));</span><br><span class="line"><span class="comment">//32</span></span><br></pre></td></tr></table></figure><h3 id="1-5-修改默认对齐数"><a href="#1-5-修改默认对齐数" class="headerlink" title="1.5 修改默认对齐数"></a>1.5 修改默认对齐数</h3><p>不知道大家是否见过 #pragma 这个预处理指令，这里使用可以改变我们的默认对齐数。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(8)<span class="comment">//设置默认对齐数为8</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span>&#123;</span></span><br><span class="line"><span class="type">char</span> c1;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">char</span> c2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()<span class="comment">//取消设置的默认对齐数，还原为默认</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)<span class="comment">//设置默认对齐数为1</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span>&#123;</span></span><br><span class="line"><span class="type">char</span> c1;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">char</span> c2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()<span class="comment">//取消设置的默认对齐数，还原为默认</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//输出的结果是什么？</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> S1));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> S2));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论</strong>：结构在对齐方式不合适的时候，我么可以自己更改默认对齐数。  </p><h3 id="1-6-结构体传参"><a href="#1-6-结构体传参" class="headerlink" title="1.6 结构体传参"></a>1.6 结构体传参</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>&#123;</span></span><br><span class="line"><span class="type">int</span> data[<span class="number">1000</span>];</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">s</span> =</span> &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;, <span class="number">1000</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体传参</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print1</span><span class="params">(<span class="keyword">struct</span> S s)</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s.num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体地址传参</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print2</span><span class="params">(<span class="keyword">struct</span> S* ps)</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ps-&gt;num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">print1(s); <span class="comment">//传结构体</span></span><br><span class="line">print2(&amp;s); <span class="comment">//传地址</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 print1 和 print2 函数哪个好些？</p><p>答案：首选print2函数。  </p><p><strong>结构体传参的时候，要传结构体的地址。</strong>  </p><blockquote><p>原因：</p><p>函数传参的时候，参数是需要压栈，会有时间和空间上的系统开销。</p><p>如果传递一个结构体对象的时候，结构体过大，参数压栈的的系统开销比较大，所以会导致性能的下降。  </p></blockquote><h2 id="2-位段"><a href="#2-位段" class="headerlink" title="2.位段"></a>2.位段</h2><h3 id="2-1-什么是位段"><a href="#2-1-什么是位段" class="headerlink" title="2.1 什么是位段"></a>2.1 什么是位段</h3><p>位段的声明和结构是类似的，有两个不同：</p><p>1.位段的成员必须是 int、unsigned int 或signed int 。</p><p>2.位段的成员名后边有一个冒号和一个数字。  </p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="comment">//4byte</span></span><br><span class="line"><span class="type">int</span> _a:<span class="number">2</span>;  <span class="comment">//剩30bit</span></span><br><span class="line"><span class="type">int</span> _b:<span class="number">5</span>;  <span class="comment">//剩25bit</span></span><br><span class="line"><span class="type">int</span> _c:<span class="number">10</span>; <span class="comment">//剩15bit</span></span><br><span class="line">    <span class="comment">//4byte（vs上不会使用之前剩余的15bit）</span></span><br><span class="line"><span class="type">int</span> _d:<span class="number">30</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//A就是一个位段类型</span></span><br><span class="line"><span class="comment">//位段A的大小 8字节</span></span><br></pre></td></tr></table></figure><h3 id="2-2-位段的内存分配"><a href="#2-2-位段的内存分配" class="headerlink" title="2.2 位段的内存分配"></a>2.2 位段的内存分配</h3><p>1.位段的成员可以是 int unsigned int signed int 或者是 char （属于整形家族）类型</p><p>2.位段的空间上是按照需要以**4个字节（ int ）<strong>或者</strong>1个字节（ char ）**的方式来开辟的。</p><p>3.位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段  </p><h3 id="2-3-位段的跨平台问题"><a href="#2-3-位段的跨平台问题" class="headerlink" title="2.3 位段的跨平台问题"></a>2.3 位段的跨平台问题</h3><p>1.int 位段被当成有符号数还是无符号数是不确定的。</p><p>2.位段中最大位的数目不能确定。（16位机器最大16，32位机器最大32，写成27，在16位机器会出问题。</p><p>3.位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义。</p><p>4.当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是舍弃剩余的位还是利用，这是不确定的。</p><p><strong>总结</strong>：跟结构相比，位段可以达到同样的效果，但是可以很好的节省空间，但是有跨平台的问题存在。  </p><h2 id="3-枚举"><a href="#3-枚举" class="headerlink" title="3.枚举"></a>3.枚举</h2><h3 id="3-1-枚举类型的定义"><a href="#3-1-枚举类型的定义" class="headerlink" title="3.1 枚举类型的定义"></a>3.1 枚举类型的定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//星期</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Day</span>&#123;</span></span><br><span class="line">Mon,</span><br><span class="line">Tues,</span><br><span class="line">Wed,</span><br><span class="line">Thur,</span><br><span class="line">Fri,</span><br><span class="line">Sat,</span><br><span class="line">Sun</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//性别</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Sex</span>&#123;</span></span><br><span class="line">MALE,</span><br><span class="line">FEMALE,</span><br><span class="line">SECRET</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="comment">//颜色</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span>&#123;</span></span><br><span class="line">RED,</span><br><span class="line">GREEN,</span><br><span class="line">BLUE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上定义的 enum Day ， enum Sex ， enum Color 都是枚举类型。</p><p>{}中的内容是枚举类型的可能取值，也叫 枚举常量 。</p><p>这些可能取值都是有值的，默认从0开始，一次递增1，当然在定义的时候也可以赋初值。  </p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//颜色</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span>&#123;</span></span><br><span class="line">RED = <span class="number">1</span>,</span><br><span class="line">GREEN = <span class="number">2</span>,</span><br><span class="line">BLUE = <span class="number">4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-2-枚举的优点"><a href="#3-2-枚举的优点" class="headerlink" title="3.2 枚举的优点"></a>3.2 枚举的优点</h3><p>1.增加代码的可读性和可维护性</p><p>2.和#define定义的标识符比较，枚举有类型检查，更加严谨。</p><p>3.防止了命名污染（封装）</p><p>4.便于调试</p><p>5.使用方便，一次可以定义多个常量 </p><h3 id="3-3-枚举的应用"><a href="#3-3-枚举的应用" class="headerlink" title="3.3 枚举的应用"></a>3.3 枚举的应用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span>&#123;</span></span><br><span class="line">RED=<span class="number">1</span>,</span><br><span class="line">GREEN=<span class="number">2</span>,</span><br><span class="line">BLUE=<span class="number">4</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> <span class="title">clr</span> =</span> GREEN;<span class="comment">//只能拿枚举常量给枚举变量赋值，才不会出现类型的差异。</span></span><br></pre></td></tr></table></figure><h2 id="4-联合（共用体）"><a href="#4-联合（共用体）" class="headerlink" title="4.联合（共用体）"></a>4.联合（共用体）</h2><h3 id="4-1-联合类型的定义"><a href="#4-1-联合类型的定义" class="headerlink" title="4.1 联合类型的定义"></a>4.1 联合类型的定义</h3><p>联合也是一种特殊的自定义类型</p><p>这种类型定义的变量也包含一系列的成员，特征是这些成员公用同一块空间（所以联合也叫共用体）。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//联合类型的声明</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Un</span>&#123;</span></span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//联合变量的定义</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Un</span> <span class="title">un</span>;</span></span><br></pre></td></tr></table></figure><h3 id="4-2-联合的特点"><a href="#4-2-联合的特点" class="headerlink" title="4.2 联合的特点"></a>4.2 联合的特点</h3><p>联合的成员是共用同一块内存空间的，这样一个联合变量的大小，至少是最大成员的大小（因为联合至少得有能力保存最大的那个成员）  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Un</span>&#123;</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Un</span> <span class="title">un</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面输出的结果是一样的吗？</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, &amp;(un.i));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, &amp;(un.c));</span><br><span class="line"><span class="comment">//结果是一样的（说明同一时间只能用一个）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面输出的结果是什么？</span></span><br><span class="line">un.i = <span class="number">0x11223344</span>;</span><br><span class="line">un.c = <span class="number">0x55</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, un.i);</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><h3 id="4-3-联合大小的计算"><a href="#4-3-联合大小的计算" class="headerlink" title="4.3 联合大小的计算"></a>4.3 联合大小的计算</h3><p>联合的大小至少是最大成员的大小。</p><p>当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Un1</span>&#123;</span></span><br><span class="line"><span class="type">char</span> c[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Un2</span>&#123;</span></span><br><span class="line"><span class="type">short</span> c[<span class="number">7</span>];</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//下面输出的结果是什么？</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">union</span> Un1));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">union</span> Un2));</span><br></pre></td></tr></table></figure><h3 id="4-4-面试题"><a href="#4-4-面试题" class="headerlink" title="4.4 面试题"></a>4.4 面试题</h3><p>判断当前计算机的大小端存储</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">check_sys</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">    &#125;un;</span><br><span class="line">    un.i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> un.c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果返回1，表示小端</span></span><br><span class="line"><span class="comment">//如果返回0，表示大端</span></span><br></pre></td></tr></table></figure><h1 id="第五章、动态内存管理"><a href="#第五章、动态内存管理" class="headerlink" title="第五章、动态内存管理"></a>第五章、动态内存管理</h1><h2 id="1-动态内存分配的必要性"><a href="#1-动态内存分配的必要性" class="headerlink" title="1.动态内存分配的必要性"></a>1.动态内存分配的必要性</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">20</span>;        <span class="comment">//在栈空间上开辟四个字节</span></span><br><span class="line"><span class="type">char</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">//在栈空间上开辟10个字节的连续空间</span></span><br></pre></td></tr></table></figure><p>上述开辟空间方式有两个特点：</p><p>1.空间开辟大小是固定的。</p><p>2.数组在申明的时候，必须指定数组的长度，它所需要的内存在编译时分配  </p><p>但是对于空间的需求，不仅仅是上述的情况。有时候我们需要的空间大小在程序运行的时候才能知道，那数组的编译时开辟空间的方式就不能满足了。这时候就只能试试动态存开辟了  </p><h2 id="2-动态内存函数的介绍"><a href="#2-动态内存函数的介绍" class="headerlink" title="2.动态内存函数的介绍"></a>2.动态内存函数的介绍</h2><h3 id="2-1-malloc-和-free"><a href="#2-1-malloc-和-free" class="headerlink" title="2.1 malloc 和 free"></a>2.1 malloc 和 free</h3><p>malloc和free都声明在 stdlib.h 头文件中  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">malloc</span> <span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针。</p><ul><li><p>如果开辟成功，则返回一个指向开辟好空间的指针。</p></li><li><p>如果开辟失败，则返回一个NULL指针，因此malloc的返回值一定要做检查。</p></li><li><p>返回值的类型是 void* ，所以malloc函数并不知道开辟空间的类型，具体在使用的时候使用者自己来决定。</p></li><li><p>如果参数 size 为0，malloc的行为是标准是未定义的，取决于编译器。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span> <span class="params">(<span class="type">void</span>* ptr)</span>;</span><br></pre></td></tr></table></figure><p>free函数用来释放动态开辟的内存。</p><ul><li><p>如果参数 ptr 指向的空间不是动态开辟的，那free函数的行为是未定义的。</p></li><li><p>如果参数 ptr 是NULL指针，则函数什么事都不做。</p></li></ul><h3 id="2-2-calloc"><a href="#2-2-calloc" class="headerlink" title="2.2 calloc"></a>2.2 calloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">calloc</span> <span class="params">(<span class="type">size_t</span> num, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>函数的功能是为 num 个大小为 size 的元素开辟一块空间，并且把空间的每个字节初始化为0。</p></li><li><p>与函数 malloc 的区别只在于 calloc 会在返回地址之前把申请的空间的每个字节初始化为全0。</p></li></ul><h3 id="2-3-realloc"><a href="#2-3-realloc" class="headerlink" title="2.3 realloc"></a>2.3 realloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">realloc</span> <span class="params">(<span class="type">void</span>* ptr, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>ptr 是要调整的内存地址</p></li><li><p>size 调整之后新大小</p></li><li><p>返回值为调整之后的内存起始位置。</p></li><li><p>这个函数调整原内存空间大小的基础上，还会将原来内存中的数据移动到新的空间。</p></li></ul><p><strong>realloc</strong>在<strong>调整内存空间</strong>的是存在<strong>两种情况</strong> ：</p><p><strong>第一种情况</strong>：原有空间之后有足够大的空间 </p><p>扩展内存就直接在原有内存之后直接追加空间，原来空间的数据不发生变化。  </p><p><strong>第二种情况</strong>：原有空间之后没有足够大的空间 </p><p>在堆空间上另找一个合适大小的连续空间来使用。这样函数返回的是一个新的内存地址  </p><p><strong>realloc如果调整失败，会返回一个空指针</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p=(<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="number">10</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="type">int</span>* ptr=(<span class="type">int</span>*)<span class="built_in">realloc</span>(p,<span class="number">80</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> != ptr)&#123;<span class="comment">//避免realloc调整失败后返回空指针覆盖p</span></span><br><span class="line">    p=ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line">ptr=<span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p=<span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h2 id="3-常见的动态内存错误"><a href="#3-常见的动态内存错误" class="headerlink" title="3.常见的动态内存错误"></a>3.常见的动态内存错误</h2><h3 id="3-1-对NULL指针的解引用操作"><a href="#3-1-对NULL指针的解引用操作" class="headerlink" title="3.1 对NULL指针的解引用操作"></a>3.1 对NULL指针的解引用操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(INT_MAX);</span><br><span class="line">*p = <span class="number">20</span>;              <span class="comment">//如果p的值是NULL，就会有问题</span></span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-对动态开辟空间的越界访问"><a href="#3-2-对动态开辟空间的越界访问" class="headerlink" title="3.2 对动态开辟空间的越界访问"></a>3.2 对动态开辟空间的越界访问</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> == p)&#123;</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;=<span class="number">10</span>; i++)&#123;</span><br><span class="line">*(p+i) = i;       <span class="comment">//当i是10的时候越界访问</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-对非动态开辟内存使用free释放"><a href="#3-3-对非动态开辟内存使用free释放" class="headerlink" title="3.3 对非动态开辟内存使用free释放"></a>3.3 对非动态开辟内存使用free释放</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br><span class="line"><span class="built_in">free</span>(p);<span class="comment">//ok?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-使用free释放一块动态开辟内存的一部分"><a href="#3-4-使用free释放一块动态开辟内存的一部分" class="headerlink" title="3.4 使用free释放一块动态开辟内存的一部分"></a>3.4 使用free释放一块动态开辟内存的一部分</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">p++;</span><br><span class="line"><span class="built_in">free</span>(p);              <span class="comment">//p不再指向动态内存的起始位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-对同一块动态内存多次释放"><a href="#3-5-对同一块动态内存多次释放" class="headerlink" title="3.5 对同一块动态内存多次释放"></a>3.5 对同一块动态内存多次释放</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="built_in">free</span>(p);              <span class="comment">//重复释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-动态开辟-内存忘记释放（内存泄漏）"><a href="#3-6-动态开辟-内存忘记释放（内存泄漏）" class="headerlink" title="3.6 动态开辟 内存忘记释放（内存泄漏）"></a>3.6 动态开辟 内存忘记释放（内存泄漏）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> != p)&#123;</span><br><span class="line">*p = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//忘记释放，就会出现内存泄漏的问题</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">test();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态开辟的空间一定要释放，并且正确释放。</strong></p><h2 id="4-经典的笔试题"><a href="#4-经典的笔试题" class="headerlink" title="4.经典的笔试题"></a>4.经典的笔试题</h2><p><strong>题目1</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GetMemory</span><span class="params">(<span class="type">char</span> *p)</span>&#123;</span><br><span class="line">p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"><span class="type">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">GetMemory(str);</span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">&quot;hello world&quot;</span>);  <span class="comment">//str仍然是空指针，会非法访问内存，程序会崩溃</span></span><br><span class="line"><span class="built_in">printf</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请问运行Test 函数会有什么样的结果？  </p><p>程序崩溃</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改后</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetMemory</span><span class="params">(<span class="type">char</span>** p)</span>&#123;</span><br><span class="line">*p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"><span class="type">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">GetMemory(&amp;str);</span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(str);</span><br><span class="line">    <span class="built_in">free</span>(str);</span><br><span class="line">    str = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题目2</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">GetMemory</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"><span class="type">char</span> p[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"><span class="type">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">str = GetMemory();</span><br><span class="line"><span class="built_in">printf</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请问运行Test 函数会有什么样的结果？  </p><p>会出现一段乱码，函数结束后空间会回收。</p><p><strong>题目3</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GetMemory</span><span class="params">(<span class="type">char</span> **p, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">*p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"><span class="type">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">GetMemory(&amp;str, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请问运行Test 函数会有什么样的结果？</p><p>存在内存泄漏，没有释放内存。</p><p><strong>题目4</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"><span class="type">char</span> *str = (<span class="type">char</span> *) <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(str);    <span class="comment">//free不会让str指向空，需要主动把str指向NULL</span></span><br><span class="line"><span class="keyword">if</span>(str != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请问运行Test 函数会有什么样的结果？</p><p>非法访问内存，str指向的空间释放后不能再次使用。</p><h2 id="5-C-C-程序的内存开辟"><a href="#5-C-C-程序的内存开辟" class="headerlink" title="5.C&#x2F;C++程序的内存开辟"></a>5.C&#x2F;C++程序的内存开辟</h2><p>C&#x2F;C++程序内存分配的几个区域：</p><p>1.<strong>内核空间</strong>：用户代码不能读写</p><p>2.<strong>栈区（stack）</strong>（向下增长）：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 栈区主要存放运行函数而分配的局部变量、函数参数、返回数据、返回地址等。</p><p>3.<strong>堆区（heap）</strong>（向上增长）：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。分配方式类似于链表。</p><p>4.<strong>数据段（静态区）</strong>（static）存放<strong>全局变量</strong>、<strong>静态数据</strong>。程序结束后由系统释放。</p><p>5.<strong>代码段</strong>：存放函数体（类成员函数和全局函数）的二进制代码&#x2F;只读常量</p><h2 id="6-柔性数组"><a href="#6-柔性数组" class="headerlink" title="6.柔性数组"></a>6.柔性数组</h2><p>C99 中，结构中的最后一个元素允许是未知大小的数组，这就叫做『柔性数组』（flexible array）成员。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">st_type</span>&#123;</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> a[];     <span class="comment">//柔性数组成员</span></span><br><span class="line">&#125;type_a;</span><br></pre></td></tr></table></figure><h3 id="6-1-柔性数组的特点"><a href="#6-1-柔性数组的特点" class="headerlink" title="6.1 柔性数组的特点"></a>6.1 柔性数组的特点</h3><ul><li><p>结构中的柔性数组成员前面必须至少一个其他成员。</p></li><li><p>sizeof 返回的这种结构大小不包括柔性数组的内存。</p></li><li><p><strong>包含柔性数组成员的结构用malloc ()函数进行内存的动态分配</strong>，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小。</p></li></ul><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">st_type</span>&#123;</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> a[];                   <span class="comment">//柔性数组成员</span></span><br><span class="line">&#125;type_a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(type_a)); <span class="comment">//输出的是4</span></span><br></pre></td></tr></table></figure><h3 id="6-2-柔性数组的使用"><a href="#6-2-柔性数组的使用" class="headerlink" title="6.2 柔性数组的使用"></a>6.2 柔性数组的使用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码1</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">type_a *p = (type_a*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(type_a)+<span class="number">100</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">//业务处理</span></span><br><span class="line">p-&gt;i = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">p-&gt;a[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure><p>这样柔性数组成员a，相当于获得了100个整型元素的连续空间。</p><h3 id="6-3-柔性数组的优势"><a href="#6-3-柔性数组的优势" class="headerlink" title="6.3 柔性数组的优势"></a>6.3 柔性数组的优势</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">st_type</span>&#123;</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> *p_a;</span><br><span class="line">&#125;type_a;</span><br><span class="line">type_a *p = (type_a *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(type_a));</span><br><span class="line">p-&gt;i = <span class="number">100</span>;</span><br><span class="line">p-&gt;p_a = (<span class="type">int</span> *)<span class="built_in">malloc</span>(p-&gt;i*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务处理</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">p-&gt;p_a[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放空间</span></span><br><span class="line"><span class="built_in">free</span>(p-&gt;p_a);</span><br><span class="line">p-&gt;p_a = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>上述 代码1 和 代码2 可以完成同样的功能，但是 方法1 的实现有两个好处：</p><ul><li>方便内存释放</li></ul><p>如果我们的代码是在一个给别人用的函数中，你在里面做了二次内存分配，并把整个结构体返回给用户。用户调用free可以释放结构体，但是用户并不知道这个结构体内的成员也需要free，所以你不能指望用户来发现这个事。所以，如果我们把结构体的内存以及其成员要的内存一次性分配好了，并返回给用户一个结构体指针，用户做一次free就可以把所有的内存也给释放掉。 </p><ul><li>有利于提高访问速度</li></ul><p> 连续的内存有益于提高访问速度，也有益于减少内存碎片。（其实，我个人觉得也没多高了，反正你跑不了要用做偏移量的加法来寻址）  </p><h1 id="第六章、小练习：通讯录"><a href="#第六章、小练习：通讯录" class="headerlink" title="第六章、小练习：通讯录"></a>第六章、小练习：通讯录</h1><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>通讯录（暂时不考虑名字相同）</p><p>1.可以存放1000个人的信息</p><p>2.人的信息：名字，年龄，电话，住址，性别</p><p>3.增、删、改、查联系人</p><p>动态增加</p><p>查询根据联系人的电话查询</p><p>4.排序（根据年龄排序）</p><h2 id="二、完整代码"><a href="#二、完整代码" class="headerlink" title="二、完整代码"></a>二、完整代码</h2><p><strong>contact.h</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAME_MAX 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEX_MAX 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADDR_MAX 30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TELE_MAX 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULE_SZ 10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">option</span> &#123;</span></span><br><span class="line">EXIT,</span><br><span class="line">ADD,</span><br><span class="line">DEL,</span><br><span class="line">SEARCH,</span><br><span class="line">MODIFY,</span><br><span class="line">SORT,</span><br><span class="line">SHOW,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PeoInfo</span> &#123;</span></span><br><span class="line"><span class="type">char</span> name[NAME_MAX];</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">char</span> sex[SEX_MAX];</span><br><span class="line"><span class="type">char</span> addr[ADDR_MAX];</span><br><span class="line"><span class="type">char</span> tele[TELE_MAX];</span><br><span class="line">&#125;PeoInfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Contact</span> &#123;</span></span><br><span class="line">PeoInfo* data;<span class="comment">//存放数据</span></span><br><span class="line"><span class="type">int</span> sz;<span class="comment">//通讯录中有效信息的个数</span></span><br><span class="line"><span class="type">int</span> capacity;<span class="comment">//通讯录的最大容量</span></span><br><span class="line">&#125;Contact;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化通讯录</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitContact</span><span class="params">(Contact* pc)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁通讯录</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyContact</span><span class="params">(Contact* pc)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加联系人</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AddContact</span><span class="params">(Contact* pc)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印所有通讯录信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowContact</span><span class="params">(<span class="type">const</span> Contact* pc)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印一条通讯录信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowOneContact</span><span class="params">(<span class="type">const</span> Contact* pc, <span class="type">int</span> index)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按电话查找</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FindByTele</span><span class="params">(<span class="type">const</span> Contact* pc,<span class="type">char</span> tele[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除联系人</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DeleteContact</span><span class="params">(Contact* pc)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找联系人</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SearchContact</span><span class="params">(Contact* pc)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改联系人</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ModifyContact</span><span class="params">(Contact* pc)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//联系人排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SortContact</span><span class="params">(Contact* pc)</span>;</span><br></pre></td></tr></table></figure><p><strong>contact.cpp</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;contact.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitContact</span><span class="params">(Contact* pc)</span> &#123;</span><br><span class="line">assert(pc);</span><br><span class="line">pc-&gt;sz = <span class="number">0</span>;</span><br><span class="line">PeoInfo* tmp = (PeoInfo*)<span class="built_in">malloc</span>(DEFAULE_SZ * <span class="keyword">sizeof</span>(PeoInfo));</span><br><span class="line"><span class="keyword">if</span> (tmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">pc-&gt;data = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;InitContact()::%s\n&quot;</span>,strerror(errno));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">pc-&gt;capacity = DEFAULE_SZ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_capacity</span><span class="params">(Contact* pc)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (pc-&gt;sz == pc-&gt;capacity) &#123;</span><br><span class="line"><span class="comment">//增加容量</span></span><br><span class="line">PeoInfo* tmp = (PeoInfo*)<span class="built_in">realloc</span>(pc-&gt;data, (pc-&gt;capacity + <span class="number">2</span>) * <span class="keyword">sizeof</span>(PeoInfo));</span><br><span class="line"><span class="keyword">if</span> (tmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">pc-&gt;data = tmp;</span><br><span class="line">pc-&gt;capacity += <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;增容成功\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;check_capacity()::%s\n&quot;</span>, strerror(errno));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyContact</span><span class="params">(Contact* pc)</span> &#123;</span><br><span class="line"><span class="built_in">free</span>(pc-&gt;data);</span><br><span class="line">pc-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">pc-&gt;sz = <span class="number">0</span>;</span><br><span class="line">pc-&gt;capacity = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AddContact</span><span class="params">(Contact* pc)</span> &#123;</span><br><span class="line">assert(pc);</span><br><span class="line">check_capacity(pc);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入联系人</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入名字：&gt;&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, pc-&gt;data[pc-&gt;sz].name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入年龄：&gt;&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(pc-&gt;data[pc-&gt;sz].age));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入性别：&gt;&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, pc-&gt;data[pc-&gt;sz].sex);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入电话：&gt;&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, pc-&gt;data[pc-&gt;sz].tele);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入地址：&gt;&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, pc-&gt;data[pc-&gt;sz].addr);</span><br><span class="line"></span><br><span class="line">pc-&gt;sz++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;增加联系人成功\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowContact</span><span class="params">(<span class="type">const</span> Contact* pc)</span> &#123;</span><br><span class="line">assert(pc);</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%-10s\t%-5s\t%-5s\t%-13s\t%-20s\n&quot;</span>, <span class="string">&quot;名字&quot;</span>, <span class="string">&quot;年龄&quot;</span>, <span class="string">&quot;性别&quot;</span>, <span class="string">&quot;电话&quot;</span>, <span class="string">&quot;地址&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pc-&gt;sz; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%-10s\t%-5d\t%-5s\t%-13s\t%-20s\n&quot;</span>,</span><br><span class="line">pc-&gt;data[i].name, pc-&gt;data[i].age, pc-&gt;data[i].sex, pc-&gt;data[i].tele, pc-&gt;data[i].addr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowOneContact</span><span class="params">(<span class="type">const</span> Contact* pc, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">assert(pc);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%-10s\t%-5s\t%-5s\t%-13s\t%-20s\n&quot;</span>, <span class="string">&quot;名字&quot;</span>, <span class="string">&quot;年龄&quot;</span>, <span class="string">&quot;性别&quot;</span>, <span class="string">&quot;电话&quot;</span>, <span class="string">&quot;地址&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%-10s\t%-5d\t%-5s\t%-13s\t%-20s\n&quot;</span>,</span><br><span class="line">pc-&gt;data[i].name, pc-&gt;data[i].age, pc-&gt;data[i].sex, pc-&gt;data[i].tele, pc-&gt;data[i].addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">FindByTele</span><span class="params">(<span class="type">const</span> Contact* pc,<span class="type">char</span> tele[])</span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pc-&gt;sz; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(pc-&gt;data[i].tele, tele) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DeleteContact</span><span class="params">(Contact* pc)</span> &#123;</span><br><span class="line">assert(pc);</span><br><span class="line"><span class="type">char</span> tele[TELE_MAX] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">if</span> (pc-&gt;sz == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;通讯录空了，无法删除\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要删除人的电话：&gt;&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, tele);</span><br><span class="line"><span class="type">int</span> pos = FindByTele(pc, tele);</span><br><span class="line"><span class="keyword">if</span> (pos == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;要删除的人不存在\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (j = pos; j &lt; pc-&gt;sz<span class="number">-1</span>; j++) &#123;</span><br><span class="line">pc-&gt;data[j] = pc-&gt;data[j + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">pc-&gt;sz--;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;删除指定联系人成功\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SearchContact</span><span class="params">(Contact* pc)</span> &#123;</span><br><span class="line">assert(pc);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要查找人的电话：&gt;&quot;</span>);</span><br><span class="line"><span class="type">char</span> tele[TELE_MAX] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, tele);</span><br><span class="line"><span class="type">int</span> index = FindByTele(pc, tele);</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;通讯录里没有此人\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;查找成功\n&quot;</span>);</span><br><span class="line">ShowOneContact(pc, index);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ModifyContact</span><span class="params">(Contact* pc)</span> &#123;</span><br><span class="line">assert(pc);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要修改人的电话：&gt;&quot;</span>);</span><br><span class="line"><span class="type">char</span> tele[TELE_MAX] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, tele);</span><br><span class="line"><span class="type">int</span> index = FindByTele(pc, tele);</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;要修改的人不存在\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ShowOneContact(pc, index);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入名字：&gt;&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, pc-&gt;data[index].name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入年龄：&gt;&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(pc-&gt;data[index].age));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入性别：&gt;&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, pc-&gt;data[index].sex);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入电话：&gt;&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, pc-&gt;data[index].tele);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入地址：&gt;&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, pc-&gt;data[index].addr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;修改成功\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SortContact</span><span class="params">(Contact* pc)</span> &#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pc-&gt;sz; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; pc-&gt;sz - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (pc-&gt;data[j].age &lt; pc-&gt;data[j + <span class="number">1</span>].age) &#123;</span><br><span class="line">PeoInfo temp = pc-&gt;data[j];</span><br><span class="line">pc-&gt;data[j] = pc-&gt;data[j + <span class="number">1</span>];</span><br><span class="line">pc-&gt;data[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ShowContact(pc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>test.cpp</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;contact.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;**********************************************\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;********     1.add       2.del        ********\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;********     3.search    4.modify     ********\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;********     5.sort      6.show       ********\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;********     0.exit                   ********\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;**********************************************\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> input = <span class="number">0</span>;</span><br><span class="line">Contact con = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">InitContact(&amp;con);</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">menu();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请选择：&gt;&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line"><span class="keyword">switch</span> (input) &#123;</span><br><span class="line"><span class="keyword">case</span> ADD:</span><br><span class="line">AddContact(&amp;con);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DEL:</span><br><span class="line">DeleteContact(&amp;con);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SEARCH:</span><br><span class="line">SearchContact(&amp;con);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> MODIFY:</span><br><span class="line">ModifyContact(&amp;con);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SORT:</span><br><span class="line">SortContact(&amp;con);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SHOW:</span><br><span class="line">ShowContact(&amp;con);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EXIT:</span><br><span class="line">DestroyContact(&amp;con);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;退出通讯录\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;选择错误！\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第七章、文件操作"><a href="#第七章、文件操作" class="headerlink" title="第七章、文件操作"></a>第七章、文件操作</h1><h2 id="1-文件的概念"><a href="#1-文件的概念" class="headerlink" title="1.文件的概念"></a>1.文件的概念</h2><p>磁盘上的文件是文件。</p><p>但是在程序设计中，我们一般谈的文件有两种：<strong>程序文件</strong>、<strong>数据文件</strong>（从文件功能的角度来分类的）。  </p><ul><li>程序文件</li></ul><blockquote><p>包括源程序文件（后缀为.c）,目标文件（windows环境后缀为.obj）,可执行程序（windows环境后缀为.exe）。  </p></blockquote><ul><li>数据文件</li></ul><blockquote><p>文件的内容不一定是程序，而是程序运行时读写的数据，比如程序运行需要从中读取数据的文件，或者输出内容的文件 。</p></blockquote><p>本节主要讨论的是数据文件。</p><p>一个文件要有一个唯一的文件标识，以便用户识别和引用。</p><p>文件名包含3部分：文件路径+文件名主干+文件后缀（ 例如： c:\code\test.txt ）</p><p>为了方便起见，文件标识常被称为文件名。  </p><h2 id="2-文件的打开和关闭"><a href="#2-文件的打开和关闭" class="headerlink" title="2.文件的打开和关闭"></a>2.文件的打开和关闭</h2><h3 id="2-1-文件指针"><a href="#2-1-文件指针" class="headerlink" title="2.1 文件指针"></a>2.1 文件指针</h3><p>缓冲文件系统中，关键的概念是“<strong>文件类型指针</strong>”，简称“<strong>文件指针</strong>”。</p><p>每个被使用的文件都在内存中开辟了一个相应的文件信息区，用来存放文件的相关信息（如文件的名字，文件状态及文件当前的位置等）。这些信息是保存在一个结构体变量中的。该结构体类型是有系统声明的，取名<strong>FILE</strong>.  </p><p>例如，VS2013编译环境提供的 stdio.h 头文件中有以下的文件类型申明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">iobuf</span> &#123;</span></span><br><span class="line"><span class="type">char</span> *_ptr;</span><br><span class="line"><span class="type">int</span> _cnt;</span><br><span class="line"><span class="type">char</span> *_base;</span><br><span class="line"><span class="type">int</span> _flag;</span><br><span class="line"><span class="type">int</span> _file;</span><br><span class="line"><span class="type">int</span> _charbuf;</span><br><span class="line"><span class="type">int</span> _bufsiz;</span><br><span class="line"><span class="type">char</span> *_tmpfname;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">iobuf</span> <span class="title">FILE</span>;</span></span><br></pre></td></tr></table></figure><p>不同的c编译器的FILE类型包含的内容不完全相同，但是大同小异。</p><p>每当打开一个文件的时候，系统会根据文件的情况自动创建一个FILE结构的变量，并填充其中的信息，使用者不必关心细节。</p><p>一般都是通过一个FILE的指针来维护这个FILE结构的变量，这样使用起来更加方便。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE* pf; <span class="comment">//文件指针变量</span></span><br></pre></td></tr></table></figure><p>定义pf是一个指向FILE类型数据的指针变量。可以使pf指向某个文件的文件信息区（是一个结构体变量）。通过该文件信息区中的信息就能够访问该文件。也就是说，<strong>通过文件指针变量能够找到与它关联的文件</strong>。 </p><h3 id="2-2-文件的打开和关闭"><a href="#2-2-文件的打开和关闭" class="headerlink" title="2.2 文件的打开和关闭"></a>2.2 文件的打开和关闭</h3><p>文件在读写之前应该先打开文件，在使用结束之后应该关闭文件。</p><p>在编写程序的时候，在打开文件的同时，都会返回一个FILE*的指针变量指向该文件，也相当于建立了指针和文件的关系。</p><p><strong>ANSIC</strong> 规定使用<strong>fopen函数</strong>来打开文件，<strong>fclose函数</strong>来关闭文件  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开文件</span></span><br><span class="line">FILE * <span class="title function_">fopen</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * filename, <span class="type">const</span> <span class="type">char</span> * mode )</span>;</span><br><span class="line"><span class="comment">//关闭文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fclose</span> <span class="params">( FILE * stream )</span>;</span><br></pre></td></tr></table></figure><p><strong>mode</strong>（文件使用方式）:</p><table><thead><tr><th align="left">文件使用方式</th><th align="left">含义</th><th align="left">如果指定文件不存在</th></tr></thead><tbody><tr><td align="left">“r”（只读）</td><td align="left">为了输入数据，打开一个已经存在的文本文件</td><td align="left">出错</td></tr><tr><td align="left">“w”（只写）</td><td align="left">为了输出数据，打开一个文本文件</td><td align="left">建立一个新的文件</td></tr><tr><td align="left">“a”（追加）</td><td align="left">向文本文件尾添加数据</td><td align="left">建立一个新的文件</td></tr><tr><td align="left">“rb”（只读）</td><td align="left">为了输入数据，打开一个二进制文件</td><td align="left">出错</td></tr><tr><td align="left">“wb”（只写）</td><td align="left">为了输出数据，打开一个二进制文件</td><td align="left">建立一个新的文件</td></tr><tr><td align="left">“ab”（追加）</td><td align="left">向一个二进制文件尾添加数据</td><td align="left">出错</td></tr><tr><td align="left">“r+”（读写）</td><td align="left">为了读和写，打开一个文本文件</td><td align="left">出错</td></tr><tr><td align="left">“w+”（读写）</td><td align="left">为了读和写，建议一个新的文件</td><td align="left">建立一个新的文件</td></tr><tr><td align="left">“a+”（读写）</td><td align="left">打开一个文件，在文件尾进行读写</td><td align="left">建立一个新的文件</td></tr><tr><td align="left">“rb+”（读写）</td><td align="left">为了读和写打开一个二进制文件</td><td align="left">出错</td></tr><tr><td align="left">“wb+”（读写）</td><td align="left">为了读和写，新建一个新的二进制文件</td><td align="left">建立一个新的文件</td></tr><tr><td align="left">“ab+”（读写）</td><td align="left">打开一个二进制文件，在文件尾进行读和写</td><td align="left">建立一个新的文件</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fopen fclose example */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span>&#123;</span><br><span class="line">FILE * pFile;</span><br><span class="line"><span class="comment">//打开文件</span></span><br><span class="line">pFile = fopen (<span class="string">&quot;myfile.txt&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="comment">//文件操作</span></span><br><span class="line"><span class="keyword">if</span> (pFile!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">fputs</span> (<span class="string">&quot;fopen example&quot;</span>,pFile);</span><br><span class="line"><span class="comment">//关闭文件</span></span><br><span class="line">fclose (pFile);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-文件的顺序读写"><a href="#3-文件的顺序读写" class="headerlink" title="3.文件的顺序读写"></a>3.文件的顺序读写</h2><table><thead><tr><th align="center">功能</th><th align="center">函数名</th><th align="center">适用于</th></tr></thead><tbody><tr><td align="center">字符输入函数</td><td align="center">fgetc</td><td align="center">所有输入流</td></tr><tr><td align="center">字符输出函数</td><td align="center">fputc</td><td align="center">所有输出流</td></tr><tr><td align="center">文本行输入函数</td><td align="center">fgets</td><td align="center">所有输入流</td></tr><tr><td align="center">文本行输出函数</td><td align="center">fputs</td><td align="center">所有输出流</td></tr><tr><td align="center">格式化输入函数</td><td align="center">fscanf</td><td align="center">所有输入流</td></tr><tr><td align="center">格式化输出函数</td><td align="center">fprintf</td><td align="center">所有输出流</td></tr><tr><td align="center">二进制输入</td><td align="center">fread</td><td align="center">文件</td></tr><tr><td align="center">二进制输出</td><td align="center">fwrite</td><td align="center">文件</td></tr></tbody></table><h2 id="4-文件的随机读写"><a href="#4-文件的随机读写" class="headerlink" title="4.文件的随机读写"></a>4.文件的随机读写</h2><h3 id="4-1-fseek"><a href="#4-1-fseek" class="headerlink" title="4.1 fseek"></a>4.1 fseek</h3><p>根据文件指针的位置和偏移量来定位文件指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fseek</span> <span class="params">( FILE * stream, <span class="type">long</span> <span class="type">int</span> offset, <span class="type">int</span> origin )</span>;</span><br></pre></td></tr></table></figure><p>第一个参数<strong>stream</strong>为文件指针</p><p>第二个参数<strong>offset</strong>为偏移量，正数表示正向偏移，负数表示负向偏移</p><p>第三个参数<strong>origin</strong>设定从文件的哪里开始偏移,可能取值为：<strong>SEEK_CUR</strong>、<strong>SEEK_END</strong> 或 <strong>SEEK_SET</strong></p><blockquote><p>SEEK_SET： 文件开头</p><p>SEEK_CUR： 当前位置</p><p>SEEK_END： 文件结尾</p><p>其中SEEK_SET,SEEK_CUR和SEEK_END依次为0，1和2。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fseek example */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span>&#123;</span><br><span class="line">FILE * pFile;</span><br><span class="line">pFile = fopen ( <span class="string">&quot;example.txt&quot;</span> , <span class="string">&quot;wb&quot;</span> );</span><br><span class="line"><span class="built_in">fputs</span> ( <span class="string">&quot;This is an apple.&quot;</span> , pFile );</span><br><span class="line">fseek ( pFile , <span class="number">9</span> , SEEK_SET );</span><br><span class="line"><span class="built_in">fputs</span> ( <span class="string">&quot; sam&quot;</span> , pFile );</span><br><span class="line">fclose ( pFile );</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//This is a sample.</span></span><br></pre></td></tr></table></figure><h3 id="4-2-ftell"><a href="#4-2-ftell" class="headerlink" title="4.2 ftell"></a>4.2 ftell</h3><p>返回文件指针相对于起始位置的偏移量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">int</span> <span class="title function_">ftell</span> <span class="params">( FILE * stream )</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ftell example */</span></span><br><span class="line"><span class="comment">/* getting size of a file */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span>&#123;</span><br><span class="line">FILE * pFile;</span><br><span class="line"><span class="type">long</span> size;</span><br><span class="line">pFile = fopen (<span class="string">&quot;myfile.txt&quot;</span>,<span class="string">&quot;rb&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pFile==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        perror (<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">fseek (pFile, <span class="number">0</span>, SEEK_END);</span><br><span class="line">size=ftell (pFile);</span><br><span class="line">fclose (pFile);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;Size of myfile.txt: %ld bytes.\n&quot;</span>,size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-rewind"><a href="#4-3-rewind" class="headerlink" title="4.3 rewind"></a>4.3 rewind</h3><p>让文件指针的位置回到文件的起始位置  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rewind</span> <span class="params">( FILE * stream )</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* rewind example */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">FILE * pFile;</span><br><span class="line"><span class="type">char</span> buffer [<span class="number">27</span>];</span><br><span class="line">pFile = fopen (<span class="string">&quot;myfile.txt&quot;</span>,<span class="string">&quot;w+&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> ( n=<span class="string">&#x27;A&#x27;</span> ; n&lt;=<span class="string">&#x27;Z&#x27;</span> ; n++)</span><br><span class="line">fputc ( n, pFile);</span><br><span class="line">rewind (pFile);</span><br><span class="line">fread (buffer,<span class="number">1</span>,<span class="number">26</span>,pFile);</span><br><span class="line">fclose (pFile);</span><br><span class="line">buffer[<span class="number">26</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="built_in">puts</span> (buffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-文本文件和二进制文件"><a href="#5-文本文件和二进制文件" class="headerlink" title="5.文本文件和二进制文件"></a>5.文本文件和二进制文件</h2><p>根据数据的组织形式，数据文件被称为<strong>文本文件</strong>或者<strong>二进制文件</strong>。</p><p>数据在内存中以二进制的形式存储，如果不加转换的输出到外存，就是二进制文件。</p><p>如果要求在外存上以ASCII码的形式存储，则需要在存储前转换。<strong>以ASCII字符的形式存储的文件</strong>就是<strong>文本文件</strong>。</p><p><strong>一个数据在内存中是怎么存储的呢？</strong></p><blockquote><p>字符一律以ASCII形式存储，数值型数据既可以用ASCII形式存储，也可以使用二进制形式存储。</p><p>如有整数10000，如果以ASCII码的形式输出到磁盘，则磁盘中占用5个字节（每个字符一个字节），而二进制形式输出，则在磁盘上只占4个字节（VS2013测试）。  </p></blockquote><h2 id="6-文件读取结束的判定"><a href="#6-文件读取结束的判定" class="headerlink" title="6.文件读取结束的判定"></a>6.文件读取结束的判定</h2><p><strong>被错误使用的feof</strong></p><p>牢记：在文件读取过程中，不能用feof函数的返回值直接用来判断文件的是否结束。而是<strong>应用于当文件读取结束的时候，判断是读取失败结束，还是遇到文件尾结束</strong>。</p><p>文本文件读取是否结束，判断返回值是否为 EOF （ fgetc ），或者 NULL （ fgets ）</p><h2 id="7-文件缓冲区"><a href="#7-文件缓冲区" class="headerlink" title="7.文件缓冲区"></a>7.文件缓冲区</h2><p>ANSIC 标准采用“<strong>缓冲文件系统</strong>”处理的数据文件的，所谓缓冲文件系统是指系统自动地在内存中为程序中每一个正在使用的文件开辟一块“<strong>文件缓冲区</strong>”。从内存向磁盘输出数据会先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘上。如果从磁盘向计算机读入数据，则从磁盘文件中读取数据输入到内存缓冲区（充满缓冲区），然后再从缓冲区逐个地将数据送到程序数据区（程序变量等）。缓冲区的大小根据C编译系统决定的。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* example */</span></span><br><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">FILE*pf = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">&quot;abcdef&quot;</span>, pf);<span class="comment">//先将代码放在输出缓冲区</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;睡眠10秒-已经写数据了，打开test.txt文件，发现文件没有内容\n&quot;</span>);</span><br><span class="line">Sleep(<span class="number">10000</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;刷新缓冲区\n&quot;</span>);</span><br><span class="line">fflush(pf);<span class="comment">//刷新缓冲区时，才将输出缓冲区的数据写到文件（磁盘）</span></span><br><span class="line"><span class="comment">//注：fflush 在高版本的VS上不能使用了</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;再睡眠10秒-此时，再次打开test.txt文件，文件有内容了\n&quot;</span>);</span><br><span class="line">Sleep(<span class="number">10000</span>);</span><br><span class="line">fclose(pf);</span><br><span class="line"><span class="comment">//注：fclose在关闭文件的时候，也会刷新缓冲区</span></span><br><span class="line">pf = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为有缓冲区的存在，C语言在操作文件的时候，需要做刷新缓冲区或者在文件操作结束的时候关闭文件。如果不做，可能导致读写文件的问题。</p><h1 id="第八章、程序的编译"><a href="#第八章、程序的编译" class="headerlink" title="第八章、程序的编译"></a>第八章、程序的编译</h1><h2 id="1-程序的翻译环境和执行环境"><a href="#1-程序的翻译环境和执行环境" class="headerlink" title="1.程序的翻译环境和执行环境"></a>1.程序的翻译环境和执行环境</h2><p>在ANSI C的任何一种实现中，存在两个不同的环境。</p><p>第1种是翻译环境，在这个环境中源代码被转换为可执行的机器指令。</p><p>第2种是执行环境，它用于实际执行代码  </p><h2 id="2-详解编译-链接"><a href="#2-详解编译-链接" class="headerlink" title="2.详解编译+链接"></a>2.详解编译+链接</h2><h3 id="2-1-翻译环境"><a href="#2-1-翻译环境" class="headerlink" title="2.1 翻译环境"></a>2.1 翻译环境</h3><p>组成一个程序的每个源文件通过编译过程分别转换成目标代码（object code）。</p><p>每个目标文件由链接器（linker）捆绑在一起，形成一个单一而完整的可执行程序。（linux后缀**.o**     windows后缀**.obj**）</p><p>链接器同时也会引入标准C函数库中任何被该程序所用到的函数，而且它可以搜索程序员个人的程序库，将其需要的函数也链接到程序中。</p><p><strong>翻译环境</strong>本身又分为几个阶段：</p><ul><li><strong>预编译</strong>阶段</li></ul><blockquote><p>gcc  -E test.c -o test.i</p><p>文本操作</p><p>①头文件的包含#include；</p><p>②删除注释</p><p>③#define定义符号的替换</p></blockquote><ul><li><strong>编译</strong></li></ul><blockquote><p>gcc -S test.i</p><p>-&gt;test.s</p><p>把C语言转换成汇编代码</p><p>①语法分析</p><p>②词法分析</p><p>③语义分析</p><p>④符号汇总</p><p>推荐两本书《编译原理》，《程序员的自我修养》</p></blockquote><ul><li><strong>汇编</strong></li></ul><blockquote><p>gcc -c test.s</p><p>-&gt;test.o</p><p>把汇编代码转换成二进制的指令</p><p>①形成符号表</p></blockquote><ul><li><strong>链接</strong></li></ul><blockquote><p>gcc test.o xxx.o -o test</p><p>-&gt;test(可执行文件，如果不自定义的化，默认a.out)</p><p>生成可执行程序</p><p>①合并段表</p><p>②符号表的合并和符号表的重定位</p><p><strong>多个目标文件进行链接的时候会通过符号表来查看来自外部的符号是否存在</strong></p></blockquote><h3 id="2-2-运行环境"><a href="#2-2-运行环境" class="headerlink" title="2.2 运行环境"></a>2.2 运行环境</h3><p>程序执行的过程：</p><p>①程序必须载入内存中。在有操作系统的环境中：一般这个由操作系统完成。在独立的环境中，程序的载入必须由手工安排，也可能是通过可执行代码置入只读内存来完成。</p><p>②程序的执行便开始。接着便调用main函数。</p><p>③开始执行程序代码。这个时候程序将使用一个运行时堆栈（stack），存储函数的局部变量和返回地址。程序同时也可以使用静态（static）内存，存储于静态内存中的变量在程序的整个执行过程一直保留他们的值。</p><p>④终止程序。正常终止main函数；也有可能是意外终止。  </p><h2 id="3-预处理详解"><a href="#3-预处理详解" class="headerlink" title="3.预处理详解"></a>3.预处理详解</h2><h3 id="3-1-预定义符号"><a href="#3-1-预定义符号" class="headerlink" title="3.1 预定义符号"></a>3.1 预定义符号</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__FILE__ <span class="comment">//进行编译的源文件</span></span><br><span class="line">__LINE__ <span class="comment">//文件当前的行号</span></span><br><span class="line">__DATE__ <span class="comment">//文件被编译的日期</span></span><br><span class="line">__TIME__ <span class="comment">//文件被编译的时间</span></span><br><span class="line">__STDC__ <span class="comment">//如果编译器遵循ANSI C，其值为1，否则未定义</span></span><br></pre></td></tr></table></figure><p>这些预定义符号都是语言内置的，可以直接用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* example */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;file:%s line:%d\n&quot;</span>, __FILE__, __LINE__);</span><br></pre></td></tr></table></figure><h3 id="3-2-define"><a href="#3-2-define" class="headerlink" title="3.2 #define"></a>3.2 #define</h3><p><strong>#define 定义标识符</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* example */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reg register       <span class="comment">//为 register这个关键字，创建一个简短的名字</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> do_forever for(;;) <span class="comment">//用更形象的符号来替换一种实现</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASE break;case    <span class="comment">//在写case语句的时候自动把 break写上。</span></span></span><br><span class="line"><span class="comment">// 如果定义的 stuff过长，可以分成几行写，除了最后一行外，每行的后面都加一个反斜杠(续行符)。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_PRINT printf(<span class="string">&quot;file:%s\tline:%d\t \</span></span></span><br><span class="line"><span class="string"><span class="meta">date:%s\ttime:%s\n&quot;</span> ,\</span></span><br><span class="line"><span class="meta">__FILE__,__LINE__ , \</span></span><br><span class="line"><span class="meta">__DATE__,__TIME__ )</span></span><br></pre></td></tr></table></figure><p>注意：在define定义标识符时，不要在后面加上 <strong>;</strong> </p><p><strong>#define 定义宏</strong></p><p>#define 机制包括了一个规定，允许把参数替换到文本中，这种实现通常称为宏（macro）或定义宏（define macro）。</p><p>宏的申明方式：</p><blockquote><p>#define name( parament-list ) stuff</p><p>其中的 parament-list 是一个由逗号隔开的符号表，它们可能出现在stuff中  </p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* example */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) ((x) * (x))</span></span><br></pre></td></tr></table></figure><p>注意：</p><blockquote><p>参数列表的左括号必须与name紧邻。</p><p>如果两者之间有任何空白存在，参数列表就会被解释为stuff的一部分  </p><p>用于对数值表达式进行求值的宏定义都应该用加上括号，避免在使用宏时由于参数中的操作符或邻近操作符之间不可预料的相互作用。</p><p>约定俗成：把宏名全部大写；函数名不要全部大写  </p></blockquote><p><strong>#define 替换规则</strong></p><p>在程序中扩展#define定义符号和宏时，需要涉及几个步骤。</p><blockquote><p>①在调用宏时，首先对参数进行检查，看看是否包含任何由#define定义的符号。如果是，它们首先被替换。</p><p>②替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被他们的值所替换。</p><p>③最后，再次对结果文件进行扫描，看看它是否包含任何由#define定义的符号。如果是，就重复上述处理过程。</p></blockquote><p>注意：</p><blockquote><p>①宏参数和#define 定义中可以出现其他#define定义的符号。但是对于宏，不能出现递归。<br>②当预处理器搜索#define定义的符号的时候，字符串常量的内容并不被搜索 。</p></blockquote><p><strong>#和##</strong>  </p><ul><li>#的作用</li></ul><p>①当字符串作为宏参数的时候可以把字符串放在字符串中  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT(FORMAT, VALUE)\</span></span><br><span class="line"><span class="meta">printf(<span class="string">&quot;the value is &quot;</span>FORMAT<span class="string">&quot;\n&quot;</span>, VALUE)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">PRINT(<span class="string">&quot;%d&quot;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②使用 # ，可以把一个宏参数变成对应的字符串  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT(n) printf(<span class="string">&quot;the value of &quot;</span>#n<span class="string">&quot; is %d\n&quot;</span>,n)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    PRINT(a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>##的作用</li></ul><p>##可以把位于它两边的符号合成一个符号。</p><p>它允许宏定义从分离的文本片段创建标识符。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_TO_SUM(num, value) sum##num += value;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> sum5 = <span class="number">10</span>;</span><br><span class="line">ADD_TO_SUM(<span class="number">5</span>, <span class="number">10</span>);<span class="comment">//作用是：给sum5增加10.</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum5);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>带有副作用的宏参数</strong></p><p>当宏参数在宏的定义中出现超过一次的时候，如果参数带有副作用，那么你在使用这个宏的时候就可能出现危险，导致不可预测的后果。副作用就是表达式求值的时候出现的永久性效果。  </p><p>x+1;&#x2F;&#x2F;不带副作用<br>x++;&#x2F;&#x2F;带有副作用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//证明 具有副作用的参数所引起的问题 的例子</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) ( (a) &gt; (b) ? (a) : (b) )</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> z = MAX(x++, y++);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x=%d y=%d z=%d\n&quot;</span>, x, y, z);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//x=6 y=10 z=9</span></span><br></pre></td></tr></table></figure><p>3.3 宏和函数的对比</p><p>宏通常被应用于执行简单的运算  ，为什么不用函数来执行呢？</p><p>原因：</p><blockquote><p>①用于调用函数和从函数返回的代码可能比实际执行这个小型计算工作所需要的时间更多。</p><p><strong>所以宏比函数在程序的规模和速度方面更胜一筹。</strong></p><p>②更为重要的是函数的参数必须声明为特定的类型。</p><p>所以函数只能在类型合适的表达式上使用。反之这个宏怎可以适用于整形、长整型、浮点型等可以用于&gt;来比较的类型。</p><p><strong>宏是类型无关的。</strong>  </p></blockquote><p>宏有时候可以做函数做不到的事情。比如：宏的参数可以出现类型，但是函数做不到。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC(num, type)\</span></span><br><span class="line"><span class="meta">(type *)malloc(num * sizeof(type))</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">MALLOC(<span class="number">10</span>, <span class="type">int</span>);<span class="comment">//类型作为参数</span></span><br><span class="line"><span class="comment">//预处理器替换之后：</span></span><br><span class="line">(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure><p><strong>宏的缺点</strong>：当然和函数相比宏也有劣势的地方：</p><blockquote><p>①每次使用宏的时候，一份宏定义的代码将插入到程序中。除非宏比较短，否则可能大幅度增加程序的长度。</p><p>② 宏是没法调试的。  </p><p>③宏由于类型无关，也就不够严谨。</p><p>④宏可能会带来运算符优先级的问题，导致程容易出现错。  </p></blockquote><p><strong>宏和函数的对比</strong>：</p><table><thead><tr><th>属性</th><th>#define定义宏</th><th>函数</th></tr></thead><tbody><tr><td>代码长度</td><td>每次使用时，宏代码都会被插入到程序中。除了非常小的宏之外，程序的长度会大幅度增长</td><td>函数代码只出现于一个地方；每次使用这个函数时，都调用那个地方的同一份代码</td></tr><tr><td>执行速度</td><td>更快</td><td>存在函数的调用和返回的额外开销，所以相对慢一些</td></tr><tr><td>操作符优先</td><td>宏参数的求值是在所有周围表达式的上下文环境里， 除非加上括号，否则邻近操作符的优先级可能会产生不可预料的后果，所以建议宏在书写的时候多些括 号</td><td>函数参数只在函数调用的时候求值一次，它的结果值传递给函数。表达式的求值结果更容易预测</td></tr><tr><td>带有副作用的参数</td><td>参数可能被替换到宏体中的多个位置，所以带有副作用的参数求值可能会产生不可预料的结果。</td><td>函数参数只在传参的时候求值一 次，结果更容易控制。</td></tr><tr><td>参数类型</td><td>宏的参数与类型无关，只要对参数的操作是合法的， 它就可以使用于任何参数类型。</td><td>函数的参数是与类型有关的，如果参数的类型不同，就需要不同的函数，即使他们执行的任务是不同的。</td></tr><tr><td>调试</td><td>宏是不方便调试的</td><td>函数是可以逐语句调试的</td></tr><tr><td>递归</td><td>宏是不能递归的</td><td>函数是可以递归的</td></tr></tbody></table><h3 id="3-3-undef"><a href="#3-3-undef" class="headerlink" title="3.3 #undef"></a>3.3 #undef</h3><p>这条指令用于移除一个宏定义  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">undef</span> NAME</span></span><br><span class="line"><span class="comment">//如果现存的一个名字需要被重新定义，那么它的旧名字首先要被移除。</span></span><br></pre></td></tr></table></figure><h3 id="3-4-命令行定义"><a href="#3-4-命令行定义" class="headerlink" title="3.4 命令行定义"></a>3.4 命令行定义</h3><p>许多C 的编译器提供了一种能力，允许在命令行中定义符号。用于启动编译过程。</p><p>例如：当我们根据同一个源文件要编译出不同的一个程序的不同版本的时候，这个特性有点用处。（假定某个程序中声明了一个某个长度的数组，如果机器内存有限，我们需要一个很小的数组，但是另外一个机器内存大写，我们需要一个数组能够大写。）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span> [ARRAY_SIZE];</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; ARRAY_SIZE; i ++)&#123;</span><br><span class="line"><span class="built_in">array</span>[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; ARRAY_SIZE; i ++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span> ,<span class="built_in">array</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span> );</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译指令：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux 环境演示</span></span><br><span class="line">gcc -D ARRAY_SIZE=<span class="number">10</span> programe.c</span><br></pre></td></tr></table></figure><h3 id="3-5-条件编译"><a href="#3-5-条件编译" class="headerlink" title="3.5 条件编译"></a>3.5 条件编译</h3><p>在编译一个程序的时候我们如果要将一条语句（一组语句）编译或者放弃是很方便的。因为我们有条件编译指令。  </p><p>比如：</p><p>调试性的代码，删除可惜，保留又碍事，所以我们可以选择性的编译。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DEBUG__</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">arr[i] = i;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> __DEBUG__</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, arr[i]);<span class="comment">//为了观察数组是否赋值成功。</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//__DEBUG__</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>常见的条件编译指令</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 常量表达式</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//常量表达式由预处理器求值。</span></span><br><span class="line">如：</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DEBUG__ 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __DEBUG__</span></span><br><span class="line"><span class="comment">//..</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="number">2.</span>多个分支的条件编译</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 常量表达式</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> 常量表达式</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span>判断是否被定义</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(symbol)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> symbol</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(symbol)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> symbol</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>嵌套指令</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(OS_UNIX)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> OPTION1</span></span><br><span class="line">unix_version_option1();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> OPTION2</span></span><br><span class="line">unix_version_option2();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(OS_MSDOS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> OPTION2</span></span><br><span class="line">msdos_version_option2();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="3-6-文件包含"><a href="#3-6-文件包含" class="headerlink" title="3.6 文件包含"></a>3.6 文件包含</h3><p>#include 指令可以使另外一个文件被编译。预处理器会先删除这条指令，并用包含文件的内容替换。  </p><ul><li>本地文件包含</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;filename&quot;</span></span></span><br></pre></td></tr></table></figure><p>先在源文件所在目录下查找，如果该头文件未找到，编译器就像查找库函数头文件一样在标准位置查找头文件。如果找不到就提示编译错误。  </p><ul><li>库文件包含</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;filename.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>查找头文件直接去标准路径下去查找，如果找不到就提示编译错误。 所以对于库文件也可以使用 “ ” 的形式包含（但是这样效率低，也不容易区分本地文件和库文件） 。</p><ul><li>嵌套文件包含</li></ul><p>如果出现了嵌套文件包含，就容易造成文件内容的重复，为了解决这个问题，可以使用条件编译。</p><p>在每个头文件的开头写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __TEST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TEST_H__</span></span><br><span class="line"><span class="comment">//头文件的内容</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//__TEST_H__</span></span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br></pre></td></tr></table></figure><h2 id="4-其他预处理指令"><a href="#4-其他预处理指令" class="headerlink" title="4.其他预处理指令"></a>4.其他预处理指令</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">error</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">line</span></span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//内容较多，不做具体介绍，有兴趣可以自己去了解</span></span><br></pre></td></tr></table></figure><h2 id="5-小练习"><a href="#5-小练习" class="headerlink" title="5.小练习"></a>5.小练习</h2><ul><li>写一个宏，可以将一个整数的二进制位的奇数位和偶数位交换。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> SWAP_ODD_EVEN(NUM) ((((NUM) &amp; (0X55555555)) <span class="string">&lt;&lt; 1) | (((NUM) &amp; (0XAAAAAAAA)) &gt;</span>&gt; 1))</span></span><br></pre></td></tr></table></figure><ul><li>写一个宏，计算结构体中某变量相对于首地址的偏移，并给出说明</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  STRUCT_OFFSET(id, element)  ((unsigned long)&amp;((( struct id*)0)-&gt;element))</span></span><br></pre></td></tr></table></figure><p>假设结构体的首地址是0开始，把他转换成结构体指针类型，再用 -&gt; 获取他的成员，前面加 &amp; 就是为了获取这个成员的地址。，最后再强制转换成unsigned long, 这样就得到了偏移量。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言（基础）笔记</title>
      <link href="/2025/06/01/C%E8%AF%AD%E8%A8%80%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/06/01/C%E8%AF%AD%E8%A8%80%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章、初识C语言"><a href="#第一章、初识C语言" class="headerlink" title="第一章、初识C语言"></a>第一章、初识C语言</h1><p>先快速了解一下C语言的大概内容，点到为止，以后会具体介绍。</p><h2 id="1-什么是C语言"><a href="#1-什么是C语言" class="headerlink" title="1.什么是C语言"></a>1.什么是C语言</h2><p>C语言是一门面向过程的、抽象化的通用程序设计语言，广泛应用于底层开发。</p><h2 id="2-第一个C语言"><a href="#2-第一个C语言" class="headerlink" title="2.第一个C语言"></a>2.第一个C语言</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello,world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Ctrl+F5  VS运行代码快捷键</span></span><br></pre></td></tr></table></figure><h2 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3.数据类型"></a>3.数据类型</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>          <span class="comment">//字符数据类型</span></span><br><span class="line"><span class="type">short</span>         <span class="comment">//短整型</span></span><br><span class="line"><span class="type">int</span>           <span class="comment">//整型</span></span><br><span class="line"><span class="type">long</span>          <span class="comment">//长整型</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span>     <span class="comment">//更长的整形</span></span><br><span class="line"><span class="type">float</span>         <span class="comment">//单精度浮点数</span></span><br><span class="line"><span class="type">double</span>        <span class="comment">//双精度浮点数</span></span><br><span class="line"><span class="comment">//C语言中没有字符串类型</span></span><br><span class="line"><span class="comment">//在不同的系统上，这些类型占据的字节长度不同，具体可以用sizeof测试</span></span><br></pre></td></tr></table></figure><h2 id="4-常量与变量"><a href="#4-常量与变量" class="headerlink" title="4.常量与变量"></a>4.常量与变量</h2><p><strong>常量</strong>—不变的量</p><p><strong>变量</strong>—可变的量</p><h3 id="4-1-定义变量的方法"><a href="#4-1-定义变量的方法" class="headerlink" title="4.1 定义变量的方法"></a>4.1 定义变量的方法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age = <span class="number">150</span>;</span><br><span class="line"><span class="type">float</span> weight = <span class="number">45.5f</span>;</span><br><span class="line">cha ch = x;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两数相加</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> num1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> num2 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;num1, &amp;num2);</span><br><span class="line">sum = num1 + num2;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//#define _CRT_SECURE_NO_WARNINGS 1是为了避免编辑器因为使用strcpy,scanf等不安全的函数从而报警告和错误</span></span><br></pre></td></tr></table></figure><h3 id="4-2-变量的分类"><a href="#4-2-变量的分类" class="headerlink" title="4.2 变量的分类"></a>4.2 变量的分类</h3><p>全局变量；局部变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> year = <span class="number">1998</span>;<span class="comment">//全局变量 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;       </span><br><span class="line">    <span class="type">int</span> year = <span class="number">2021</span>;<span class="comment">//局部变量    </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;year = %d\n&quot;</span>, year);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当局部变量和全局变量同名的时候，局部变量优先使用。 </span></span><br></pre></td></tr></table></figure><h3 id="4-3-变量的作用域和生命周期"><a href="#4-3-变量的作用域和生命周期" class="headerlink" title="4.3 变量的作用域和生命周期"></a>4.3 变量的作用域和生命周期</h3><p><strong>作用域</strong>—作用域（scope）是程序设计概念，通常来说，一段程序代码中所用到的名字并不总是有效&#x2F;可用的，限定这个名字的可用性的代码范围就是这个名字的作用域。</p><ol><li>局部变量的作用域：变量所在的局部范围。 </li><li>全局变量的作用域：整个工程。</li></ol><p><strong>生命周期</strong>—变量的生命周期指的是变量的创建到变量的销毁之间的一个时间段。</p><ol><li>局部变量的生命周期：进入作用域生命周期开始，出作用域生命周期结束。</li><li>全局变量的生命周期：整个程序的生命周期。</li></ol><h3 id="4-4-常量"><a href="#4-4-常量" class="headerlink" title="4.4 常量"></a>4.4 常量</h3><p>C语言中的常量分为以下以下几种：</p><p>字面常量；const修饰的常变量；#define定义的标识符常量；枚举常量；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//举例</span></span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Sex</span>&#123;</span></span><br><span class="line">MALE,</span><br><span class="line">FEMALE,</span><br><span class="line">SECRET</span><br><span class="line">&#125;; <span class="comment">//括号中的MALE,FEMALE,SECRET是枚举常量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//字面常量演示</span></span><br><span class="line"><span class="number">3.14</span>;<span class="comment">//字面常量</span></span><br><span class="line"><span class="number">1000</span>;<span class="comment">//字面常量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const 修饰的常变量 </span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> pai = <span class="number">3.14f</span>;<span class="comment">//这里的pai是const修饰的常变量</span></span><br><span class="line"><span class="comment">//pai = 5.14;会报错</span></span><br><span class="line">    <span class="comment">//const 修饰的常变量在C语言中只是在语法层面限制了变量pai不能直接被改变，但是pai本质上还是一个变量，所以叫常变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//#define的标识符常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;max = %d\n&quot;</span>, MAX);</span><br><span class="line"></span><br><span class="line"><span class="comment">//枚举常量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, MALE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, FEMALE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, SECRET);</span><br><span class="line"><span class="comment">//注：枚举常量的默认是从0开始，依次向下递增1的</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-字符串-转义字符-注释"><a href="#5-字符串-转义字符-注释" class="headerlink" title="5.字符串+转义字符+注释"></a>5.字符串+转义字符+注释</h2><h3 id="5-1-字符串"><a href="#5-1-字符串" class="headerlink" title="5.1 字符串"></a>5.1 字符串</h3><p>字符串—由双引号（Double Quote）引起来的一串字符称为字符串字面值（String Literal）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;hello bit.\n&quot;</span></span><br></pre></td></tr></table></figure><p>注：字符串的结束标志是一个 \0 的转义字符。在计算字符串长度的时候 \0 是结束标志，不算作字符串内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> arr1[] = <span class="string">&quot;bit&quot;</span>;</span><br><span class="line"><span class="type">char</span> arr2[] = &#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;t&#x27;</span>&#125;;</span><br><span class="line"><span class="type">char</span> arr3[] = &#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, arr1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, arr2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, arr3);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//bit</span></span><br><span class="line"><span class="comment">//bit烫烫烫烫蘠it</span></span><br><span class="line"><span class="comment">//bit</span></span><br></pre></td></tr></table></figure><h3 id="5-2-转义字符"><a href="#5-2-转义字符" class="headerlink" title="5.2 转义字符"></a>5.2 转义字符</h3><table><thead><tr><th>转义字符</th><th>释义</th></tr></thead><tbody><tr><td>?</td><td>在书写连续多个问号时使用，防止他们被解析成三字母词</td></tr><tr><td>\‘</td><td>用于表示字符常量’</td></tr><tr><td>\“</td><td>用于表示一个字符串内部的双引号</td></tr><tr><td>\\</td><td>用于表示一个反斜杠，防止它被解释为一个转义序列符</td></tr><tr><td>\a</td><td>警告字符，蜂鸣</td></tr><tr><td>\b</td><td>退格符</td></tr><tr><td>\f</td><td>进纸符</td></tr><tr><td>\n</td><td>换行</td></tr><tr><td>\r</td><td>回车</td></tr><tr><td>\t</td><td>水平制表符</td></tr><tr><td>\v</td><td>垂直制表符</td></tr><tr><td>\ddd</td><td>ddd表示1~3个八进制的数字。 如： \130 X</td></tr><tr><td>\xdd</td><td>dd表示2个十六进制数字。 如： \x30 0</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//举例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, <span class="string">&#x27;\&#x27;&#x27;</span>);<span class="comment">//打印一个单引号</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;\&quot;&quot;</span>);<span class="comment">//打印一个双引号</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-注释"><a href="#5-3-注释" class="headerlink" title="5.3 注释"></a>5.3 注释</h3><p>代码中有不需要的代码可以直接删除，也可以注释掉</p><p>代码中有些代码比较难懂，可以加一下注释文字</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*xxxxx*/</span>   <span class="comment">//多行注释，不能嵌套注释</span></span><br><span class="line"><span class="comment">//xxxxx     //单行注释</span></span><br></pre></td></tr></table></figure><h2 id="6-选择语句"><a href="#6-选择语句" class="headerlink" title="6.选择语句"></a>6.选择语句</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> learn = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你会认真学习吗？（选择 1 or 0）：&quot;</span>)；</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;learn);</span><br><span class="line">    <span class="keyword">if</span>(learn == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;你会进步！\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;你会落后！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//if(表达式)&#123;代码块&#125;else&#123;代码块&#125;</span></span><br><span class="line"><span class="comment">//if(表达式1)&#123;代码块&#125;else if(表达式2)&#123;代码块&#125;else&#123;代码块&#125;</span></span><br></pre></td></tr></table></figure><h2 id="7-循环语句"><a href="#7-循环语句" class="headerlink" title="7.循环语句"></a>7.循环语句</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//while语句</span></span><br><span class="line">    <span class="keyword">while</span>(num &lt;= <span class="number">10</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//do...while语句</span></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line">        num++;</span><br><span class="line">    &#125;<span class="keyword">while</span>(num &lt;= <span class="number">10</span>);</span><br><span class="line">    <span class="comment">//for语句</span></span><br><span class="line">    <span class="keyword">for</span>(num=<span class="number">0</span>;num &lt;= <span class="number">10</span>;num++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//while语句在进入循环体之前要先判断条件是否成立，如果成立的话则进入循环体</span></span><br><span class="line"><span class="comment">//do…while语句则相反，先执行循环体，然后再判断条件是否成立，如果成立的话则进入循环体，也就是说对于do…while语句，不管条件是否成立都要先执行一遍</span></span><br></pre></td></tr></table></figure><h2 id="8-函数"><a href="#8-函数" class="headerlink" title="8.函数"></a>8.函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//创建加法函数Add()</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = x + y;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> num1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入两个数：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;num1,&amp;num2);</span><br><span class="line">    <span class="comment">//使用自己定义的加法函数Add()</span></span><br><span class="line">    sum=Add(num1,num2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum=%d&quot;</span>,sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数的特点就是简化代码，代码复用</span></span><br></pre></td></tr></table></figure><h2 id="9-数组"><a href="#9-数组" class="headerlink" title="9.数组"></a>9.数组</h2><h3 id="9-1-数组的定义"><a href="#9-1-数组的定义" class="headerlink" title="9.1 数组的定义"></a>9.1 数组的定义</h3><p>数组—一组相同类型元素的集合 。（c语言中的定义）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;<span class="comment">//定义一个最多放10个元素的整形数组</span></span><br></pre></td></tr></table></figure><h3 id="9-2-数组的下标"><a href="#9-2-数组的下标" class="headerlink" title="9.2  数组的下标"></a>9.2  数组的下标</h3><p>数组的每个元素都有一个下标，下标是从0开始的。<br>数组可以通过下标来访问的。</p><h2 id="10-操作符"><a href="#10-操作符" class="headerlink" title="10.操作符"></a>10.操作符</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算术操作符</span></span><br><span class="line">+  -  *  /  %</span><br><span class="line"></span><br><span class="line"><span class="comment">//移位操作符</span></span><br><span class="line">&gt;&gt;  &lt;&lt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//位操作符</span></span><br><span class="line">&amp;  ^  |</span><br><span class="line"><span class="comment">//&amp;（按位与）---对应的二进制全1才为1</span></span><br><span class="line"><span class="comment">//^（按位异或）---相同为0，不同为1</span></span><br><span class="line"><span class="comment">//|（按位或）---对应的二进制全0才为0</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//赋值操作符</span></span><br><span class="line">=  +=  -=  *=  /=  &amp;=  ^=  !=  &gt;&gt;=  &lt;&lt;=</span><br><span class="line">    </span><br><span class="line"><span class="comment">//单目操作符</span></span><br><span class="line">!  -  +  &amp;  <span class="keyword">sizeof</span>  ~  --  ++  *</span><br><span class="line">    </span><br><span class="line"><span class="comment">//关系操作符</span></span><br><span class="line">&gt;  &gt;=  &lt;  &lt;=  !=  ==</span><br><span class="line"></span><br><span class="line"><span class="comment">//逻辑操作符</span></span><br><span class="line">&amp;&amp;  ||</span><br><span class="line"></span><br><span class="line"><span class="comment">//条件操作符</span></span><br><span class="line">exp1 ? exp2 : exp3</span><br><span class="line"></span><br><span class="line"><span class="comment">//逗号表达式    </span></span><br><span class="line">exp1,exp2,exp3</span><br><span class="line">    </span><br><span class="line"><span class="comment">//下标引用、函数调用和结构成员</span></span><br><span class="line">[]  ()  .  -&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="11-常见关键词"><a href="#11-常见关键词" class="headerlink" title="11.常见关键词"></a>11.常见关键词</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>  <span class="keyword">break</span>  <span class="keyword">case</span>  <span class="type">char</span>  <span class="type">const</span>  <span class="keyword">continue</span>  <span class="keyword">default</span>  <span class="keyword">do</span>  <span class="type">double</span>  <span class="keyword">else</span>  <span class="keyword">enum</span>  <span class="keyword">extern</span>  <span class="type">float</span>  <span class="keyword">for</span>  <span class="keyword">goto</span>  <span class="keyword">if</span>  <span class="type">int</span>  <span class="type">long</span>  <span class="keyword">register</span>  <span class="keyword">return</span>  <span class="type">short</span>  <span class="type">signed</span>  <span class="keyword">sizeof</span>  <span class="type">static</span>  <span class="keyword">struct</span>  <span class="keyword">switch</span>  <span class="keyword">typedef</span>  <span class="keyword">union</span>  <span class="type">unsigned</span>  <span class="type">void</span>  <span class="keyword">volatile</span>  <span class="keyword">while</span></span><br></pre></td></tr></table></figure><p>注：先介绍下面几个，之后会详细介绍</p><h3 id="11-1-关键字-typedef"><a href="#11-1-关键字-typedef" class="headerlink" title="11.1 关键字 typedef"></a>11.1 关键字 typedef</h3><p>typedef—定义自己习惯的数据类型名称，来替代系统默认的基本类型名称、数组类型名称、指针类型名称与用户自定义的结构型名称、共用型名称、枚举型名称等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将unsigned int 重命名为uint_32</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> uint_32;</span><br></pre></td></tr></table></figure><h3 id="11-2-关键字-static"><a href="#11-2-关键字-static" class="headerlink" title="11.2 关键字 static"></a>11.2 关键字 static</h3><p>static是用来修饰变量和函数的。</p><h4 id="11-2-1-修饰局部变量"><a href="#11-2-1-修饰局部变量" class="headerlink" title="11.2.1 修饰局部变量"></a>11.2.1 修饰局部变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i = <span class="number">0</span>;<span class="comment">//static修饰局部变量</span></span><br><span class="line">    i++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        test2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p>1 1 1 1 1 1 1 1 1 1<br>1 2 3 4 5 6 7 8 9 10</p><p>结论：</p><p>static修饰局部变量改变了变量的生命周期，让静态局部变量出了作用域依然存在，到程序结束，生命周期才结束，也就是<strong>保持变量内容的持久性</strong>。</p><h4 id="11-2-2-修饰全局变量"><a href="#11-2-2-修饰全局变量" class="headerlink" title="11.2.2 修饰全局变量"></a>11.2.2 修饰全局变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add_1.c</span></span><br><span class="line"><span class="type">int</span> year_1 = <span class="number">2021</span>;</span><br><span class="line"><span class="comment">//add_2.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> year_2 = <span class="number">2021</span>;</span><br><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> year_1;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> year_2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,year_1);</span><br><span class="line">    <span class="comment">//printf(&quot;%d&quot;,year_2);  无法输出，会出现连接性错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个全局变量被static修饰，使得这个全局变量只能在本源文件内使用，不能在其他源文件内使用。 </span></span><br></pre></td></tr></table></figure><h4 id="11-2-3-修饰函数"><a href="#11-2-3-修饰函数" class="headerlink" title="11.2.3 修饰函数"></a>11.2.3 修饰函数</h4><p>修饰函数与修饰全局变量效果类似。</p><p>一个函数被static修饰，使得这个函数只能在本源文件内使用，不能在其他源文件内使用。</p><h2 id="12-define-定义常量和宏"><a href="#12-define-定义常量和宏" class="headerlink" title="12.#define 定义常量和宏"></a>12.#define 定义常量和宏</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//define定义标识符常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 1000</span></span><br><span class="line"><span class="comment">//define定义宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD(x,y) ((x)+(y))</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = ADD(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d   %d&quot;</span>,MAX,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//#define是预处理命令，在编译预处理的时候进行简单的替换</span></span><br><span class="line"><span class="comment">//typedef是在编译时处理的，它在自己的作用域内给一个已经存在的类型一个别名</span></span><br></pre></td></tr></table></figure><h2 id="13-指针"><a href="#13-指针" class="headerlink" title="13.指针"></a>13.指针</h2><p>每一个变量都有一个内存位置，每一个内存位置都定义了可使用&amp;运算符访问的地址，它表示了在内存中的一个地址。</p><p>指针也就是内存地址，指针变量是用来存放内存地址的变量。</p><p>指针大小在32位平台是4个字节，64位平台是8个字节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    p = &amp;num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num变量的地址：%p\n&quot;</span>,p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num变量的值：%d\n&quot;</span>,*p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p>num变量的地址：00A4F88C<br>num变量的值：100</p><h2 id="14-结构体"><a href="#14-结构体" class="headerlink" title="14.结构体"></a>14.结构体</h2><p>结构体是C语言中特别重要的知识点，结构体使得C语言有能力描述复杂类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> sex[<span class="number">5</span>];</span><br><span class="line">    <span class="type">char</span> id[<span class="number">15</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结构体信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">s</span> =</span> &#123;<span class="string">&quot;小白&quot;</span>,<span class="number">20</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;20210101&quot;</span>&#125;;</span><br><span class="line"><span class="comment">//.为结构成员访问操作符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;name = %s;age = %d&quot;</span>, s.name, s.age); </span><br><span class="line"><span class="comment">//-&gt;操作符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> *<span class="title">ps</span> =</span> &amp;s;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;name = %s;age = %d&quot;</span>, ps-&gt;name, ps-&gt;age); </span><br></pre></td></tr></table></figure><h1 id="第二章、分支和循环语句"><a href="#第二章、分支和循环语句" class="headerlink" title="第二章、分支和循环语句"></a>第二章、分支和循环语句</h1><h2 id="1-什么是语句"><a href="#1-什么是语句" class="headerlink" title="1.什么是语句"></a>1.什么是语句</h2><p>C语句可分为以下五类：</p><blockquote><p>表达式语句</p></blockquote><blockquote><p>函数调用语句</p></blockquote><blockquote><p>控制语句</p></blockquote><blockquote><p>复合语句</p></blockquote><blockquote><p>空语句</p></blockquote><p>本节介绍的是<strong>控制语句</strong>。</p><p>控制语句用于控制程序的执行流程，以实现程序的各种结构方式，它们由特定的语句定义符组成，C语言有九种控制语句。 可分成以下三类：</p><blockquote><p>条件判断语句也叫分支语句：if语句、switch语句； </p></blockquote><blockquote><p>循环执行语句：do while语句、while语句、for语句；</p></blockquote><blockquote><p>转向语句：break语句、goto语句、continue语句、return语句。</p></blockquote><h2 id="2-分支语句（选择语句）"><a href="#2-分支语句（选择语句）" class="headerlink" title="2.分支语句（选择语句）"></a>2.分支语句（选择语句）</h2><h3 id="2-1-if语句"><a href="#2-1-if语句" class="headerlink" title="2.1 if语句"></a>2.1 if语句</h3><p>语法结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式)&#123;   <span class="comment">//C语言中0表示假，非0表示真</span></span><br><span class="line">    语句；    <span class="comment">//满足表达式，执行语句</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(表达式)&#123;</span><br><span class="line">    语句<span class="number">1</span>；</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    语句<span class="number">2</span>；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(表达式<span class="number">1</span>)&#123;</span><br><span class="line">    语句<span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(表达式<span class="number">2</span>)&#123;</span><br><span class="line">    语句<span class="number">2</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    语句<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a比较大&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a&lt;b)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;b比较大&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a与b值相同&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-switch语句"><a href="#2-2-switch语句" class="headerlink" title="2.2 switch语句"></a>2.2 switch语句</h3><p>switch语句也是一种分支语句，常常用于多分支的情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(整型表达式)&#123;</span><br><span class="line">    <span class="keyword">case</span> 整型常量表达式:</span><br><span class="line">        语句;</span><br><span class="line"><span class="comment">//当 switch 表达式的值并不匹配所有 case 标签的值时，这个 default 子句后面的语句就会执行。</span></span><br><span class="line">    dafault:   </span><br><span class="line">        语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> day = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;星期一\n&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;星期二\n&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;星期三\n&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;星期四\n&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;星期五\n&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;星期六\n&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;星期日\n&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数值范围应该在1~7&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-循环语句"><a href="#3-循环语句" class="headerlink" title="3.循环语句"></a>3.循环语句</h2><h3 id="3-1-while循环"><a href="#3-1-while循环" class="headerlink" title="3.1 while循环"></a>3.1 while循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(表达式)&#123;</span><br><span class="line">循环语句;    <span class="comment">//满足表达式就执行该循环语句，直至不满足表达式为止</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印1-10</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-do…while循环"><a href="#3-2-do…while循环" class="headerlink" title="3.2 do…while循环"></a>3.2 do…while循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">循环语句;</span><br><span class="line">&#125;<span class="keyword">while</span>(表达式);</span><br></pre></td></tr></table></figure><p>do…while循环和while循环类似，区别在于do…while循环先执行循环语句再判断，while循环则是先判断再循环，也就是说<strong>do…while循环至少执行一次</strong>。</p><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印1-10</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;<span class="keyword">while</span>(i&lt;=<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-for循环"><a href="#3-3-for循环" class="headerlink" title="3.3 for循环"></a>3.3 for循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式<span class="number">1</span>;表达式<span class="number">2</span>;表达式<span class="number">3</span>)&#123;</span><br><span class="line">循环语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>表达式1——<strong>初始化</strong>部分</p><p>初始化循环变量；</p></blockquote><blockquote><p>表达式2——<strong>条件判断</strong>部分</p><p>满足条件，则执行循环语句（判断循环何时终止） </p></blockquote><blockquote><p>表达式3——<strong>调整</strong>部分</p><p>一次循环结束后执行表达式3（用于循环变量的调整）</p></blockquote><p>注：for循环中的初始化部分，条件判断部分，调整部分是可以省略的</p><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印1-10</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-break和continue"><a href="#3-4-break和continue" class="headerlink" title="3.4 break和continue"></a>3.4 break和continue</h3><p>break——在循环中只要遇到break，就直接终止循环。</p><p>注：如果是循环嵌套的情况下，break只会结束一层循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    inr i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=<span class="number">3</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i=<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d*%d=%d   &quot;</span>,i,j,i*j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：1*1=1   1*2=2   1*3=3   3*1=3   3*2=6   3*3=9</span></span><br></pre></td></tr></table></figure><p>continue——用于终止本次循环的，也就是本次循环中continue后边的代码不会再执行， 直接跳转到循环语句的判断部分。进行下一次循环的条件判断。</p><h3 id="3-5-goto语句"><a href="#3-5-goto语句" class="headerlink" title="3.5 goto语句"></a>3.5 goto语句</h3><p>C语言中提供了可以随意滥用的 goto语句和标记跳转的标号。</p><p>从理论上 goto语句是没有必要的，实践中没有goto语句也可以很容易的写出代码。</p><p>但是某些场合下goto语句还是用得着的，常见的用法就是终止程序在某些深度嵌套的结构的处理过程。</p><p>例如：一次跳出两层或多层循环。多层循环这种情况使用break是达不到目的的，它只能从内层循环退出到上一层的循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//goto语言适合的场景</span></span><br><span class="line"><span class="keyword">for</span>(...)&#123;</span><br><span class="line">    <span class="keyword">for</span>(...)&#123;</span><br><span class="line">        <span class="keyword">for</span>(...)&#123;</span><br><span class="line">            <span class="keyword">if</span>(disaster)&#123;</span><br><span class="line">                <span class="keyword">goto</span> error;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">error:</span><br><span class="line"><span class="keyword">if</span>(diaster)&#123;</span><br><span class="line">        <span class="comment">//处理错误情况</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="第三章、函数"><a href="#第三章、函数" class="headerlink" title="第三章、函数"></a>第三章、函数</h1><h2 id="1-函数是什么"><a href="#1-函数是什么" class="headerlink" title="1.函数是什么"></a>1.函数是什么</h2><p>在计算机科学中，子程序（英语：Subroutine, procedure, function, routine, method, subprogram, callable unit），是一个大型程序中的某部份代码，由一个或多个语句块组成。它负责完成某项特定任务，而且相较于其他代码，具备相对的独立性。</p><p>一般会有输入参数并有返回值，提供对过程的封装和细节的隐藏。这些代码通常被集成为软件库。</p><p>函数在面向过程的语言中已经出现。是结构（Struct）和类（Class）的前身。本身就是对具有相关性语句的归类和对某过程的抽象。</p><h2 id="2-库函数"><a href="#2-库函数" class="headerlink" title="2.库函数"></a>2.库函数</h2><p>有许多基础功能，它们不是业务性的代码，我们在开发的过程中每个程序员都可能用的到，为了支持可移植性和提高程序的效率，所以C语言的基础库中提供了一系列类似的库函数，方便程序员进行软件开发。</p><p><a href="http://www.cplusplus.com/">www.cplusplus.com</a></p><p><a href="http://en.cppreference.com(英文版)/">http://en.cppreference.com（英文版）</a></p><p><a href="http://zh.cppreference.com(中文版)/">http://zh.cppreference.com（中文版）</a></p><p>该网站有各个函数、语法的实例代码。</p><blockquote><p>使用库函数，必须包含 #include 对应的头文件。</p></blockquote><h2 id="3-自定义函数"><a href="#3-自定义函数" class="headerlink" title="3.自定义函数"></a>3.自定义函数</h2><p>自定义函数和库函数一样，有函数名，返回值类型和函数参数。这些我们都可以自己来设计，这给了我们一个很大的发挥空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数的组成</span></span><br><span class="line">ret_type <span class="title function_">fun_name</span><span class="params">(para1, * )</span>&#123;</span><br><span class="line">    statement;<span class="comment">//语句项</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ret_type  返回类型</span></span><br><span class="line"><span class="comment">//fun_name  函数名</span></span><br><span class="line"><span class="comment">//para1     函数参数</span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换两个数的值</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span>&amp;y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前，num1=%d，num2=%d\n&quot;</span>,num1,num2);</span><br><span class="line">    swap(num1,num2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换前，num1=%d，num2=%d\n&quot;</span>,num1,num2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-函数参数"><a href="#4-函数参数" class="headerlink" title="4.函数参数"></a>4.函数参数</h2><h3 id="4-1-实际参数（实参）"><a href="#4-1-实际参数（实参）" class="headerlink" title="4.1 实际参数（实参）"></a>4.1 实际参数（实参）</h3><p>真实传给函数的参数，叫实参。</p><p>实参可以是：常量、变量、表达式、函数等。</p><p>无论实参是何种类型的量，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形参。 </p><h3 id="4-2-形式参数（形参）"><a href="#4-2-形式参数（形参）" class="headerlink" title="4.2 形式参数（形参）"></a>4.2 形式参数（形参）</h3><p>形式参数是指函数名后括号中的变量，因为形式参数只有在函数被调用的过程中才实例化（分配内存单元），所以叫形式参数。</p><p>形式参数当函数调用完成之后就自动销毁了。</p><p>因此形式参数只在函数中有效。</p><p>注：我们可以简单的认为，<strong>形参实例化之后其实相当于实参的一份临时拷贝</strong>。</p><h2 id="5-函数调用"><a href="#5-函数调用" class="headerlink" title="5.函数调用"></a>5.函数调用</h2><h3 id="5-1-传值调用"><a href="#5-1-传值调用" class="headerlink" title="5.1 传值调用"></a>5.1 传值调用</h3><p>函数的形参和实参分别占有不同内存块，对形参的修改不会影响实参。 </p><h3 id="5-2-传址调用"><a href="#5-2-传址调用" class="headerlink" title="5.2 传址调用"></a>5.2 传址调用</h3><p>传址调用是把函数外部创建变量的内存地址传递给函数参数的一种调用函数的方式。 </p><p>这种传参方式可以让函数和函数外边的变量建立起真正的联系，也就是函数内部可以直接操作函数外部的变量。 </p><h2 id="6-函数的嵌套调用和链式访问"><a href="#6-函数的嵌套调用和链式访问" class="headerlink" title="6.函数的嵌套调用和链式访问"></a>6.函数的嵌套调用和链式访问</h2><p>函数和函数之间可以根据实际的需求进行组合的，也就是互相调用的。 </p><h3 id="6-1-嵌套调用"><a href="#6-1-嵌套调用" class="headerlink" title="6.1 嵌套调用"></a>6.1 嵌套调用</h3><p>函数可以嵌套调用，但是不能嵌套定义。</p><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印九九乘法表</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">multiply</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span>&#123;   <span class="comment">//乘法函数</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    num = x*y;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> &amp;i)</span>&#123;    <span class="comment">//打印九九乘法表的第n行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d*%d=%2d\t&quot;</span>,i,j,multiply(i,j));   <span class="comment">//%2d就是宽度为2，右对齐</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        show(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment">1*1= 1</span></span><br><span class="line"><span class="comment">2*1= 2  2*2= 4</span></span><br><span class="line"><span class="comment">3*1= 3  3*2= 6  3*3= 9</span></span><br><span class="line"><span class="comment">4*1= 4  4*2= 8  4*3=12  4*4=16</span></span><br><span class="line"><span class="comment">5*1= 5  5*2=10  5*3=15  5*4=20  5*5=25</span></span><br><span class="line"><span class="comment">6*1= 6  6*2=12  6*3=18  6*4=24  6*5=30  6*6=36</span></span><br><span class="line"><span class="comment">7*1= 7  7*2=14  7*3=21  7*4=28  7*5=35  7*6=42  7*7=49</span></span><br><span class="line"><span class="comment">8*1= 8  8*2=16  8*3=24  8*4=32  8*5=40  8*6=48  8*7=56  8*8=64</span></span><br><span class="line"><span class="comment">9*1= 9  9*2=18  9*3=27  9*4=36  9*5=45  9*6=54  9*7=63  9*8=72  9*9=81</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="6-2-链式访问"><a href="#6-2-链式访问" class="headerlink" title="6.2 链式访问"></a>6.2 链式访问</h3><p>把一个函数的返回值作为另外一个函数的参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> arr[<span class="number">20</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="comment">//strlen 函数用来求字符串的长度</span></span><br><span class="line">    <span class="comment">//strcat函数用来复制一个字符串,将这个字符串拼接在另一个字符串后面</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">strlen</span>(<span class="built_in">strcat</span>(arr,<span class="string">&quot;world&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ret);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//10</span></span><br></pre></td></tr></table></figure><h2 id="7-函数的声明和定义"><a href="#7-函数的声明和定义" class="headerlink" title="7.函数的声明和定义"></a>7.函数的声明和定义</h2><h3 id="7-1-函数声明"><a href="#7-1-函数声明" class="headerlink" title="7.1 函数声明"></a>7.1 函数声明</h3><p>告诉编译器有一个函数叫什么，参数是什么，返回类型是什么，但是具体是否存在，函数声明无法决定。</p><p>函数的声明一般出现在函数的使用之前。要满足先声明后使用。</p><p>函数的声明一般要放在头文件中的。</p><h3 id="7-2-函数定义"><a href="#7-2-函数定义" class="headerlink" title="7.2 函数定义"></a>7.2 函数定义</h3><p>函数的定义是指函数的具体实现，交待函数的功能实现。</p><h2 id="8-函数递归"><a href="#8-函数递归" class="headerlink" title="8.函数递归"></a>8.函数递归</h2><h3 id="8-1-什么是递归"><a href="#8-1-什么是递归" class="headerlink" title="8.1 什么是递归"></a>8.1 什么是递归</h3><p><strong>程序调用自身</strong>的编程技巧称为递归（ recursion），递归做为一种算法在程序设计语言中广泛应用。 </p><p>一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。</p><p><strong>递归的主要思考方式在于：大事化小</strong> </p><h3 id="8-2-递归的两个必要条件"><a href="#8-2-递归的两个必要条件" class="headerlink" title="8.2 递归的两个必要条件"></a>8.2 递归的两个必要条件</h3><p>存在限制条件，当满足这个限制条件的时候，递归便不再继续。</p><p>每次递归调用之后越来越接近这个限制条件</p><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//n的阶乘</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">factaoial</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n*factaoial(n<span class="number">-1</span>);   <span class="comment">//调用自身</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d!=%d\n&quot;</span>,n,factaoial(n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//6!=720</span></span><br></pre></td></tr></table></figure><p>在调试 factorial 函数的时候，如果你的参数比较大，那就会报错： stack overflow（栈溢出）这样的信息。</p><p>系统分配给程序的栈空间是有限的，但是如果出现了死循环，或者（死递归），这样有可能导致一直开辟栈空间，最终产生栈空间耗尽的情况，这样的现象我们称为栈溢出。</p><p>解决方法：</p><p>1.将递归改写成非递归。 </p><p>2.使用static对象替代 non-static 局部对象。</p><p>在递归函数设计中，可以使用 static 对象替代 non-static 局部对象（即栈对象），这不仅可以减少每次递归调用和返回时产生和释放 non-static 对象的开销，而且 static 对象还可以保存递归调用的中间状态，并且可为各个调用层所访问</p><h1 id="第四章、数组"><a href="#第四章、数组" class="headerlink" title="第四章、数组"></a>第四章、数组</h1><h2 id="1-一维数组的创建和初始化"><a href="#1-一维数组的创建和初始化" class="headerlink" title="1.一维数组的创建和初始化"></a>1.一维数组的创建和初始化</h2><h3 id="1-1-一维数组的创建"><a href="#1-1-一维数组的创建" class="headerlink" title="1.1 一维数组的创建"></a>1.1 一维数组的创建</h3><p>数组是一组相同类型元素的集合。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">type_t</span> arr_name[conse_n]</span><br><span class="line"><span class="comment">//type_t 是指数组的元素类型</span></span><br><span class="line"><span class="comment">//const_n 是一个常量表达式，用来指定数组的大小</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//实例</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><blockquote><p>注：</p><p>数组创建，在C99标准之前，[]中要给一个常量才可以，不能使用变量。</p><p>在C99标准支持了变长数组的概念。</p></blockquote><h3 id="1-2-一维数组的初始化"><a href="#1-2-一维数组的初始化" class="headerlink" title="1.2 一维数组的初始化"></a>1.2 一维数组的初始化</h3><p>数组的<strong>初始化</strong>是指在创建数组的同时给数组的内容一些合理初始值。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr1[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> arr2[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> arr3[<span class="number">5</span>] = &#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>，<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">char</span> arr4[<span class="number">3</span>] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="number">98</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="type">char</span> arr5[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="type">char</span> arr6[] = <span class="string">&quot;abcdef&quot;</span>;</span><br></pre></td></tr></table></figure><p>数组在创建的时候如果想不指定数组的确定的大小就得初始化。数组的元素个数根据初始化的内容来确定。</p><h2 id="2-一维数组在内存中的存储"><a href="#2-一维数组在内存中的存储" class="headerlink" title="2.一维数组在内存中的存储"></a>2.一维数组在内存中的存储</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(<span class="built_in">array</span>)/<span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&amp;array[%d] = %p\n&quot;</span>,i,&amp;<span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*结果：</span></span><br><span class="line"><span class="comment">&amp;array[0] = 00B8F908</span></span><br><span class="line"><span class="comment">&amp;array[1] = 00B8F90C</span></span><br><span class="line"><span class="comment">&amp;array[2] = 00B8F910</span></span><br><span class="line"><span class="comment">&amp;array[3] = 00B8F914</span></span><br><span class="line"><span class="comment">&amp;array[4] = 00B8F918</span></span><br><span class="line"><span class="comment">&amp;array[5] = 00B8F91C</span></span><br><span class="line"><span class="comment">&amp;array[6] = 00B8F920</span></span><br><span class="line"><span class="comment">&amp;array[7] = 00B8F924</span></span><br><span class="line"><span class="comment">&amp;array[8] = 00B8F928</span></span><br><span class="line"><span class="comment">&amp;array[9] = 00B8F92C</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>随着数组下标的增长，元素的地址，也在有规律的递增。</p><p>由此可以得出结论：数组在内存中是连续存放的。</p><h2 id="3-二维数组的创建和初始化"><a href="#3-二维数组的创建和初始化" class="headerlink" title="3.二维数组的创建和初始化"></a>3.二维数组的创建和初始化</h2><h3 id="3-1-二维数组的创建"><a href="#3-1-二维数组的创建" class="headerlink" title="3.1 二维数组的创建"></a>3.1 二维数组的创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">5</span>][<span class="number">6</span>];</span><br><span class="line"><span class="type">char</span> <span class="built_in">array</span>[<span class="number">5</span>][<span class="number">6</span>];</span><br><span class="line"><span class="type">double</span> <span class="built_in">array</span>[<span class="number">5</span>][<span class="number">6</span>];</span><br></pre></td></tr></table></figure><h3 id="3-2-二维数组的初始化"><a href="#3-2-二维数组的初始化" class="headerlink" title="3.2 二维数组的初始化"></a>3.2 二维数组的初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> arr[][<span class="number">4</span>] = &#123;&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//二维数组如果有初始化，行可以省略，列不能省略</span></span><br></pre></td></tr></table></figure><h2 id="4-二维数组在内存中的存储"><a href="#4-二维数组在内存中的存储" class="headerlink" title="4.二维数组在内存中的存储"></a>4.二维数组在内存中的存储</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[<span class="number">3</span>][<span class="number">4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j ++ ) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;&amp;array[%d][%d] = %p\n&quot;</span>, i,j, &amp;<span class="built_in">array</span>[i][j]);</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*结果：</span></span><br><span class="line"><span class="comment">&amp;array[0][0] = 00DEF96C</span></span><br><span class="line"><span class="comment">&amp;array[0][1] = 00DEF970</span></span><br><span class="line"><span class="comment">&amp;array[0][2] = 00DEF974</span></span><br><span class="line"><span class="comment">&amp;array[0][3] = 00DEF978</span></span><br><span class="line"><span class="comment">&amp;array[1][0] = 00DEF97C</span></span><br><span class="line"><span class="comment">&amp;array[1][1] = 00DEF980</span></span><br><span class="line"><span class="comment">&amp;array[1][2] = 00DEF984</span></span><br><span class="line"><span class="comment">&amp;array[1][3] = 00DEF988</span></span><br><span class="line"><span class="comment">&amp;array[2][0] = 00DEF98C</span></span><br><span class="line"><span class="comment">&amp;array[2][1] = 00DEF990</span></span><br><span class="line"><span class="comment">&amp;array[2][2] = 00DEF994</span></span><br><span class="line"><span class="comment">&amp;array[2][3] = 00DEF998</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>二维数组在内存中也是连续存储的。</p><h2 id="5-数组越界"><a href="#5-数组越界" class="headerlink" title="5.数组越界"></a>5.数组越界</h2><p>数组的下标是有范围限制的。</p><p>数组的下规定是从0开始的，如果数组有n个元素，最后一个元素的下标就是n-1。</p><p>所以数组的下标如果小于0，或者大于n-1，就是数组越界访问了，超出了数组合法空间的访问。 </p><p>C语言本身是不做数组下标的越界检查，编译器也不一定报错，但是编译器不报错，并不意味着程序就是正确的，</p><p>二维数组的行和列也可能存在越界。</p><h2 id="6-数组练习：三子棋"><a href="#6-数组练习：三子棋" class="headerlink" title="6.数组练习：三子棋"></a>6.数组练习：三子棋</h2><h3 id="6-1-简介"><a href="#6-1-简介" class="headerlink" title="6.1 简介"></a>6.1 简介</h3><p>三子棋，在一个3*3组成的棋盘上，只要一方将自己的三个棋子走成一条线，就算胜利，如果棋盘上下满棋子却没有分出胜负则算平局。</p><h3 id="6-2-思路"><a href="#6-2-思路" class="headerlink" title="6.2 思路"></a>6.2 思路</h3><p>用一个3*3的二维数组来存储玩家与电脑下棋数据；</p><p>用”*“表示玩家下的棋子，”#”表示电脑下的棋子；</p><p>电脑下棋用rand函数模拟；</p><h3 id="6-3-代码"><a href="#6-3-代码" class="headerlink" title="6.3 代码"></a>6.3 代码</h3><p><strong>ThreeChess.h</strong>（函数声明）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROW 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COL 3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitBoard</span><span class="params">(<span class="type">char</span> board[ROW][COL], <span class="type">int</span> row, <span class="type">int</span> col)</span>;<span class="comment">//初始化棋盘</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisplayBoard</span><span class="params">(<span class="type">char</span> board[ROW][COL], <span class="type">int</span> row, <span class="type">int</span> col)</span>;<span class="comment">//打印棋盘</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PlayerMove</span><span class="params">(<span class="type">char</span> board[ROW][COL], <span class="type">int</span> row, <span class="type">int</span> col)</span>;<span class="comment">//玩家下子</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ComputerMove</span><span class="params">(<span class="type">char</span> board[ROW][COL], <span class="type">int</span> row, <span class="type">int</span> col)</span>;<span class="comment">//电脑下子</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">CheckWin</span><span class="params">(<span class="type">char</span> board[ROW][COL], <span class="type">int</span> row, <span class="type">int</span> col)</span>;<span class="comment">//判断输赢</span></span><br></pre></td></tr></table></figure><p><strong>ThreeChess.cpp</strong>（游戏的函数具体实现）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ThreeChess.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitBoard</span><span class="params">(<span class="type">char</span> board[ROW][COL], <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">board[i][j] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisplayBoard</span><span class="params">(<span class="type">char</span> board[ROW][COL], <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line"><span class="comment">//打印数据</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; %c &quot;</span>, board[i][j]);</span><br><span class="line"><span class="keyword">if</span> (j &lt; col - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;|&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="comment">//打印分割行</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; row - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;---&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (j &lt; col - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;|&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PlayerMove</span><span class="params">(<span class="type">char</span> board[ROW][COL], <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;玩家走\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入坐标:&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line"><span class="keyword">if</span> (x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= row &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; y &lt;= col) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[x - <span class="number">1</span>][y - <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">board[x - <span class="number">1</span>][y - <span class="number">1</span>] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;该坐标被占用,请重新输入！\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;该坐标非法,请重新输入！\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ComputerMove</span><span class="params">(<span class="type">char</span> board[ROW][COL], <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;电脑走\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">x = rand() % row;</span><br><span class="line">y = rand() % col;</span><br><span class="line"><span class="keyword">if</span> (board[x][y] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">board[x][y] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isFull</span><span class="params">(<span class="type">char</span> board[ROW][COL], <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[i][j] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">CheckWin</span><span class="params">(<span class="type">char</span> board[ROW][COL], <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[i][<span class="number">0</span>] == board[i][<span class="number">1</span>] &amp;&amp; board[i][<span class="number">1</span>] == board[i][<span class="number">2</span>] &amp;&amp; board[i][<span class="number">0</span>] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> board[i][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">0</span>][j] == board[<span class="number">1</span>][j] &amp;&amp; board[<span class="number">1</span>][j] == board[<span class="number">2</span>][j] &amp;&amp; board[<span class="number">0</span>][j] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> board[<span class="number">0</span>][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">0</span>][<span class="number">0</span>] == board[<span class="number">1</span>][<span class="number">1</span>] &amp;&amp; board[<span class="number">1</span>][<span class="number">1</span>] == board[<span class="number">2</span>][<span class="number">2</span>] &amp;&amp; board[<span class="number">0</span>][<span class="number">0</span>] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> board[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">2</span>][<span class="number">2</span>] == board[<span class="number">1</span>][<span class="number">1</span>] &amp;&amp; board[<span class="number">1</span>][<span class="number">1</span>] == board[<span class="number">2</span>][<span class="number">0</span>] &amp;&amp; board[<span class="number">2</span>][<span class="number">2</span>] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> board[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isFull(board, row, col) == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;q&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>test.cpp</strong>（测试）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ThreeChess.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;****************************************\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;**********       1. play      **********\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;**********       0. exit      **********\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;****************************************\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">threeChess</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> board[ROW][COL] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">InitBoard(board, ROW, COL);</span><br><span class="line">DisplayBoard(board, ROW, COL);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">PlayerMove(board, ROW, COL);</span><br><span class="line">DisplayBoard(board, ROW, COL);</span><br><span class="line">ret = CheckWin(board, ROW, COL);</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="string">&#x27;c&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">ComputerMove(board, ROW, COL);</span><br><span class="line">DisplayBoard(board, ROW, COL);</span><br><span class="line">ret = CheckWin(board, ROW, COL);</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="string">&#x27;c&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;玩家赢了\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;电脑赢了\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="string">&#x27;q&#x27;</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;平局\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> input = <span class="number">0</span>;</span><br><span class="line">srand((<span class="type">unsigned</span> <span class="type">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">menu();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请选择：&gt;&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line"><span class="keyword">switch</span> (input) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">threeChess();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;退出游戏\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;选择错误\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (input);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-数组练习：扫雷"><a href="#7-数组练习：扫雷" class="headerlink" title="7.数组练习：扫雷"></a>7.数组练习：扫雷</h2><h3 id="7-1-简介"><a href="#7-1-简介" class="headerlink" title="7.1 简介"></a>7.1 简介</h3><p>扫雷，一款经典的小游戏。</p><h3 id="7-2-思路"><a href="#7-2-思路" class="headerlink" title="7.2 思路"></a>7.2 思路</h3><p>用两个二维数组来分别存储布置好的地雷数据和排查出来的地雷数据；</p><p>在存储<strong>布置地雷数据</strong>的二维数组中，用“0”表示没有地雷，用“1”表示布置了地雷；</p><p>在存储<strong>排查地雷数据</strong>的二维数组中，用“*”表示还没有排查的位置，用“0”-“9”表示排查位置周围地雷的数量；</p><p>布置地雷用rand函数模拟；</p><h3 id="7-3-代码"><a href="#7-3-代码" class="headerlink" title="7.3 代码"></a>7.3 代码</h3><p><strong>Minesweeper.h</strong>（函数声明）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROW 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROWS ROW+2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COL 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COLS COL+2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitBoard</span><span class="params">(<span class="type">char</span> board[ROWS][COLS], <span class="type">int</span> rows, <span class="type">int</span> cols,<span class="type">char</span> <span class="built_in">set</span>)</span>;<span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisplayBoard</span><span class="params">(<span class="type">char</span> board[ROWS][COLS], <span class="type">int</span> row, <span class="type">int</span> col)</span>;<span class="comment">//打印</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SetMine</span><span class="params">(<span class="type">char</span> board[ROWS][COLS], <span class="type">int</span> row, <span class="type">int</span> col,<span class="type">int</span> count)</span>;<span class="comment">//布置地雷</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FindMine</span><span class="params">(<span class="type">char</span> mine[ROWS][COLS], <span class="type">char</span> show[ROWS][COLS], <span class="type">int</span> row, <span class="type">int</span> col,<span class="type">int</span> num)</span>;<span class="comment">//探查地雷</span></span><br></pre></td></tr></table></figure><p><strong>Minesweeper.cpp</strong>（游戏的函数具体实现）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Minesweeper.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitBoard</span><span class="params">(<span class="type">char</span> board[ROWS][COLS], <span class="type">int</span> rows, <span class="type">int</span> cols,<span class="type">char</span> <span class="built_in">set</span>)</span> &#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">board[i][j] = <span class="built_in">set</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisplayBoard</span><span class="params">(<span class="type">char</span> board[ROWS][COLS], <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;-----------------------------------------\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= col; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= row; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= col; j++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, board[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;-----------------------------------------\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SetMine</span><span class="params">(<span class="type">char</span> board[ROWS][COLS], <span class="type">int</span> row, <span class="type">int</span> col,<span class="type">int</span> count)</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (count) &#123;</span><br><span class="line"><span class="type">int</span> x = rand() % row+<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> y = rand() % col+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (board[x][y] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">board[x][y] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">count--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetMineCount</span><span class="params">(<span class="type">char</span> mine[ROWS][COLS], <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = x - <span class="number">1</span>; i &lt;= x + <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = y - <span class="number">1</span>; j &lt;= y + <span class="number">1</span>; j++) &#123;</span><br><span class="line">sum += mine[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum - <span class="number">9</span> * <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowMine</span><span class="params">(<span class="type">char</span> mine[ROWS][COLS],<span class="type">char</span> show[ROWS][COLS],<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line"><span class="type">int</span> count = GetMineCount(mine, x, y);</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">show[x][y] = count + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = x - <span class="number">1</span>; i &lt;= x + <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = y - <span class="number">1</span>; j &lt;= y + <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= <span class="number">1</span> &amp;&amp; i &lt;= ROW &amp;&amp; j &gt;= <span class="number">1</span> &amp;&amp; j &lt;= COL &amp;&amp; show[i][j] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">ShowMine(mine, show, i, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">show[x][y] = count + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">FindMine</span><span class="params">(<span class="type">char</span> mine[ROWS][COLS], <span class="type">char</span> show[ROWS][COLS], <span class="type">int</span> row, <span class="type">int</span> col,<span class="type">int</span> num)</span> &#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> win = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (win&lt;row*col-num) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入要排查的坐标：&gt;&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line"><span class="keyword">if</span> (x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= row &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; y &lt;= col) &#123;</span><br><span class="line"><span class="keyword">if</span> (mine[x][y] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n很遗憾，你被炸死了!\n&quot;</span>);</span><br><span class="line">DisplayBoard(mine, row, col);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ShowMine(mine, show, x, y);</span><br><span class="line">DisplayBoard(show, row, col);</span><br><span class="line">win++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;坐标非法！\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (win == row * col - num) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;恭喜你，排雷成功\n&quot;</span>);</span><br><span class="line">DisplayBoard(mine, row, col);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>test.cpp</strong>（测试）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Minesweeper.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;****************************************\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;**********       1. play      **********\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;**********       0. exit      **********\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;****************************************\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Minesweeper</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> mine[ROWS][COLS] = &#123;<span class="number">0</span>&#125;;<span class="comment">//存放布置好的雷</span></span><br><span class="line"><span class="type">char</span> show[ROWS][COLS] = &#123;<span class="number">0</span>&#125;;<span class="comment">//存放排查出来的雷的信息</span></span><br><span class="line">InitBoard(mine, ROWS, COLS,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">InitBoard(show, ROWS, COLS,<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">SetMine(mine, ROW, COL, <span class="number">10</span>);</span><br><span class="line">DisplayBoard(show, ROW, COL);</span><br><span class="line">FindMine(mine, show, ROW, COL,<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> input = <span class="number">0</span>;</span><br><span class="line">srand((<span class="type">unsigned</span> <span class="type">int</span>)time(<span class="literal">NULL</span>));<span class="comment">//用时间戳设置随机数的生成起点</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">menu();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请选择：&gt;&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line"><span class="keyword">switch</span> (input) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">Minesweeper();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;退出游戏\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;选择错误\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (input);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第五章、操作符详解"><a href="#第五章、操作符详解" class="headerlink" title="第五章、操作符详解"></a>第五章、操作符详解</h1><h2 id="1-操作符分类"><a href="#1-操作符分类" class="headerlink" title="1.操作符分类"></a>1.操作符分类</h2><blockquote><p>算术操作符</p><p>移位操作符</p><p>位操作符</p><p>赋值操作符</p><p>单目操作符</p><p>关系操作符</p><p>逻辑操作符</p><p>条件操作符</p><p>逗号表达式</p><p>下标引用、函数调用和结构成员 </p></blockquote><h2 id="2-算术操作符"><a href="#2-算术操作符" class="headerlink" title="2.算术操作符"></a>2.算术操作符</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+   <span class="comment">//加</span></span><br><span class="line">-   <span class="comment">//减</span></span><br><span class="line">*   <span class="comment">//乘</span></span><br><span class="line">/   <span class="comment">//除</span></span><br><span class="line">%   <span class="comment">//取余</span></span><br></pre></td></tr></table></figure><ol><li>除了 % 操作符之外，其他的几个操作符可以作用于整数和浮点数。 </li><li>对于 &#x2F; 操作符如果两个操作数都为整数，执行整数除法。而只要有浮点数执行的就是浮点数除法。 </li><li>% 操作符的两个操作数必须为整数，返回的是整除之后的余数。</li></ol><h2 id="3-移位操作符"><a href="#3-移位操作符" class="headerlink" title="3.移位操作符"></a>3.移位操作符</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;   <span class="comment">//左移操作符</span></span><br><span class="line">&gt;&gt;   <span class="comment">//右移操作符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//移位操作符的操作数只能是整数</span></span><br></pre></td></tr></table></figure><p><strong>左移操作符</strong>移位规则：</p><p>运算符将其左侧操作数向左移动右侧操作数定义的位数，<strong>左边抛弃、右边补0</strong>。</p><p><strong>右移操作符</strong>移位规则：</p><p>运算符将其左侧操作数向右移动右侧操作数定义的位数。</p><p>右移运算有2种：</p><blockquote><p>1.<strong>逻辑</strong>移位—左边用0填充，右边丢弃</p><p>2.<strong>算术</strong>移位—左边用原该值的符号位填充，右边丢弃</p></blockquote><p><strong>警告</strong>：对于移位运算符，不要移动负数位，这个是标准未定义的。</p><h2 id="4-位操作符"><a href="#4-位操作符" class="headerlink" title="4.位操作符"></a>4.位操作符</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&amp;   <span class="comment">//按位与（按二进制位进行“与”运算）</span></span><br><span class="line">|   <span class="comment">//按位或（按二进制位进行“或”运算）</span></span><br><span class="line">^   <span class="comment">//按位异或（按二进制位进行“异或”运算）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//负数按补码形式参加（负整数的补码就是除符号位外的所有位取反后加一）</span></span><br><span class="line"><span class="comment">//例：-5 原码（10000101）—取反—&gt;（11111010）—加一—&gt;补码（11111011）</span></span><br><span class="line"><span class="comment">//操作数必须是整数</span></span><br></pre></td></tr></table></figure><p>一道有趣的面试题：</p><p>不能创建临时变量（第三个变量），实现两个数的交换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">20</span>;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">    b = a ^ b;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d   b=%d\n&quot;</span>,a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-赋值操作符"><a href="#5-赋值操作符" class="headerlink" title="5.赋值操作符"></a>5.赋值操作符</h2><p>赋值操作符可以给不满意的值重新赋值。</p><p>复合赋值符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+=   -=   *=   /=   %=</span><br><span class="line">&gt;&gt;=  &lt;&lt;=  &amp;=   |=   ^= </span><br></pre></td></tr></table></figure><p>赋值符使用时要注意两边的数据类型</p><h2 id="6-单目操作符"><a href="#6-单目操作符" class="headerlink" title="6.单目操作符"></a>6.单目操作符</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">!           <span class="comment">//逻辑反操作</span></span><br><span class="line">-           <span class="comment">//负值</span></span><br><span class="line">+           <span class="comment">//正值</span></span><br><span class="line">&amp;           <span class="comment">//取地址</span></span><br><span class="line"><span class="keyword">sizeof</span>      <span class="comment">//操作数的类型长度（以字节为单位）</span></span><br><span class="line">~           <span class="comment">//对一个数的二进制按位取反</span></span><br><span class="line">--          <span class="comment">//前置、后置（前置则先自减再使用，后置则相反）</span></span><br><span class="line">++          <span class="comment">//前置、后置（前置则先自增再使用，后置则相反）</span></span><br><span class="line">*           <span class="comment">//间接访问操作符(解引用操作符)</span></span><br><span class="line">(type)      <span class="comment">//强制类型转换</span></span><br></pre></td></tr></table></figure><h2 id="7-关系操作符"><a href="#7-关系操作符" class="headerlink" title="7.关系操作符"></a>7.关系操作符</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;   &gt;=   &lt;   &lt;=   !=   ==</span><br></pre></td></tr></table></figure><p>在编程过程中，要小心将 &#x3D;&#x3D; 和 &#x3D; 写错</p><h2 id="8-逻辑操作符"><a href="#8-逻辑操作符" class="headerlink" title="8.逻辑操作符"></a>8.逻辑操作符</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp;          <span class="comment">//逻辑与</span></span><br><span class="line">||          <span class="comment">//逻辑或</span></span><br></pre></td></tr></table></figure><h2 id="9-条件操作符"><a href="#9-条件操作符" class="headerlink" title="9.条件操作符"></a>9.条件操作符</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">exp1 ? exp2 : exp3</span><br><span class="line"></span><br><span class="line"><span class="comment">//例子(二者等价)</span></span><br><span class="line"><span class="keyword">if</span>(a&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    b=<span class="number">10</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    b=<span class="number">-10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a&gt;<span class="number">0</span>?b=<span class="number">10</span>:b=<span class="number">-10</span>;</span><br></pre></td></tr></table></figure><h2 id="10-逗号表达式"><a href="#10-逗号表达式" class="headerlink" title="10.逗号表达式"></a>10.逗号表达式</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exp1, exp2, exp3, …expN</span><br></pre></td></tr></table></figure><p>逗号表达式，就是用逗号隔开的多个表达式。 </p><p>从左向右依次执行，整个表达式的结果是最后一个表达式的结果。</p><h2 id="11-下标引用、函数调用和结构成员"><a href="#11-下标引用、函数调用和结构成员" class="headerlink" title="11.下标引用、函数调用和结构成员"></a>11.下标引用、函数调用和结构成员</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[]        <span class="comment">//下标引用操作符 </span></span><br><span class="line">()        <span class="comment">//函数调用操作符 </span></span><br><span class="line">.         <span class="comment">//成员选择（对象）  对象.成员名</span></span><br><span class="line">-&gt;        <span class="comment">//成员选择（指针）  对象指针-&gt;成员名</span></span><br></pre></td></tr></table></figure><h2 id="12-表达式求值"><a href="#12-表达式求值" class="headerlink" title="12.表达式求值"></a>12.表达式求值</h2><p>表达式求值的顺序一部分是由操作符的优先级和结合性决定。</p><p>有些表达式的操作数在求值的过程中可能需要转换为其他类型。</p><h3 id="12-1-隐式类型转换"><a href="#12-1-隐式类型转换" class="headerlink" title="12.1 隐式类型转换"></a>12.1 隐式类型转换</h3><p>C的整型算术运算总是至少以缺省整型类型的精度来进行的。</p><p>为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，这种转换称为<strong>整型提升</strong>。</p><p><strong>整型提升的意义</strong>：</p><blockquote><p>表达式的整型运算要在CPU的相应运算器件内执行，CPU内整型运算器(ALU)的操作数的字节长度一般就是int的字节长度，同时也是CPU的通用寄存器的长度。</p><p>因此，即使两个char类型的相加，在CPU执行时实际上也要先转换为CPU内整型操作数的标准度。</p><p>通用CPU（general-purpose CPU）是难以直接实现两个8比特字节直接相加运算（虽然机器指令中可能有这种字节相加指令）。</p><p>所以，表达式中各种长度可能小于int长度的整型值，都必须先转换为int或unsigned int，然后才能送入CPU去执行运算。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="type">char</span> a,b,c;</span><br><span class="line">...</span><br><span class="line">a = b + c;</span><br></pre></td></tr></table></figure><p>b和c的值被提升为普通整型，然后再执行加法运算，加法运算完成之后，结果将被截断，然后再存储于a中。</p><p><strong>如何进行整形提升</strong>：</p><p>整形提升是按照变量的数据类型的符号位来提升的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//负数的整形提升</span></span><br><span class="line"><span class="type">char</span> c1 = <span class="number">-1</span>;</span><br><span class="line">变量c1的二进制位(补码)中只有<span class="number">8</span>个比特位： <span class="number">1111111</span></span><br><span class="line">因为 <span class="type">char</span> 为有符号的 <span class="type">char</span></span><br><span class="line">所以整形提升的时候，高位补充符号位，即为<span class="number">1</span></span><br><span class="line">提升之后的结果是： <span class="number">11111111111111111111111111111111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正数的整形提升</span></span><br><span class="line"><span class="type">char</span> c2 = <span class="number">1</span>;</span><br><span class="line">变量c2的二进制位(补码)中只有<span class="number">8</span>个比特位： <span class="number">00000001</span></span><br><span class="line">因为 <span class="type">char</span> 为有符号的 <span class="type">char</span></span><br><span class="line">所以整形提升的时候，高位补充符号位，即为<span class="number">0</span></span><br><span class="line">提升之后的结果是： <span class="number">00000000000000000000000000000001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//无符号整形提升，高位补0</span></span><br></pre></td></tr></table></figure><h3 id="12-2-算术转换"><a href="#12-2-算术转换" class="headerlink" title="12.2 算术转换"></a>12.2 算术转换</h3><p>如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数的转换为另一个操作数的类型，否则操作就无法进行。</p><h3 id="12-3-操作符的属性"><a href="#12-3-操作符的属性" class="headerlink" title="12.3 操作符的属性"></a>12.3 操作符的属性</h3><p>复杂表达式的求值有三个影响的因素。</p><ol><li>操作符的优先级 </li><li>操作符的结合性 </li><li>是否控制求值顺序。</li></ol><p>两个相邻的操作符先执行哪个取决于他们的优先级。</p><p>如果两者的优先级相同，取决于他们的结合性。</p><p>在编程中，要尽量避免编写<strong>非法表达式</strong>，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">i = i-- - --i * ( i = <span class="number">-3</span> ) * i++ + ++i;</span><br></pre></td></tr></table></figure><p>上述表达式在不同编译器有不同的结果，原因是该表达式不能通过操作符的属性确定唯一的计算路径，是有歧义的。</p><h1 id="第六章、指针"><a href="#第六章、指针" class="headerlink" title="第六章、指针"></a>第六章、指针</h1><h2 id="1-指针的概念"><a href="#1-指针的概念" class="headerlink" title="1.指针的概念"></a>1.指针的概念</h2><p><strong>指针</strong>是内存中一个最小单元的编号，也就是地址。</p><p>平时口语中说的指针，通常指的是指针变量，是用来存放内存地址的变量。</p><p><strong>指针变量</strong>，用来存放地址的变量。</p><p>我们可以通过&amp;（取地址操作符）取出变量的内存其实地址，把地址可以存放到一个变量中，这个变量就是指针变量。</p><h2 id="2-指针的定义"><a href="#2-指针的定义" class="headerlink" title="2.指针的定义"></a>2.指针的定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type + *</span><br><span class="line"><span class="comment">//例子：</span></span><br><span class="line"><span class="type">char</span>  *pc = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span>   *pi = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">short</span> *ps = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>char*类型的指针是为了存放char类型变量的地址。</p><p>int*类型的指针是为了存放int类型变量的地址。</p><p>指针的类型决定了指针向前或者向后走一步有多大（距离）。 </p><p>指针的类型决定了，对指针解引用的时候有多大的权限。（比如： char*的指针解引用就只能访问一个字节，而 int* 的指针的解引用就能访问四个字节。）</p><h2 id="3-野指针"><a href="#3-野指针" class="headerlink" title="3.野指针"></a>3.野指针</h2><p>野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的） </p><p><strong>野指针的成因</strong>：</p><p>1.指针未初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p; <span class="comment">//指针未初始化，默认为随机值</span></span><br></pre></td></tr></table></figure><p>2.指针越界访问</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">array</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">    *(p++) = i;   <span class="comment">//当指针指向的范围超出数组array的范围时，p就是野指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.指针指向的空间释放</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = test();</span><br><span class="line">    *p = <span class="number">20</span>;   <span class="comment">//此时a已经被销毁，再去赋值，已经越界</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>野指针的规避方法：</strong></p><p>1.指针初始化</p><p>2.小心指针越界</p><p>3.指针指向空间释放即使置NULL</p><p>4.避免返回局部变量的地址</p><p>5.指针使用之前检查有效性</p><h2 id="4-指针运算"><a href="#4-指针运算" class="headerlink" title="4.指针运算"></a>4.指针运算</h2><p>因为两个地址相加无意义也可能越界，所以规定不允许指针相加</p><p>4.1 指针+-整数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[NUM];</span><br><span class="line"><span class="type">int</span>* p;</span><br><span class="line">    <span class="comment">//数组初始化，每个元素均为0</span></span><br><span class="line"><span class="keyword">for</span> (p = &amp;<span class="built_in">array</span>[<span class="number">0</span>]; p &lt; &amp;<span class="built_in">array</span>[NUM];) &#123;</span><br><span class="line">*p++ = <span class="number">0</span>;   <span class="comment">//指针+整数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.2 指针-指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_strlen</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line"><span class="type">char</span>* p = s;</span><br><span class="line"><span class="keyword">while</span> (*p != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">p++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p - s;   <span class="comment">//指针-指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.3 指针的关系运算</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (p = &amp;<span class="built_in">array</span>[<span class="number">0</span>]; p &lt; &amp;<span class="built_in">array</span>[<span class="number">10</span>];) &#123;</span><br><span class="line">*p++ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以修改如下：</span></span><br><span class="line"><span class="keyword">for</span> (p = &amp;<span class="built_in">array</span>[<span class="number">0</span>]; p &lt; &amp;<span class="built_in">array</span>[<span class="number">10</span>];p++) &#123;</span><br><span class="line">*p = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//标准规定：</span></span><br><span class="line"><span class="comment">//允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针比较，但是不允许与指向第一个元素之前的那个内存位置的指针进行比较。</span></span><br></pre></td></tr></table></figure><h2 id="5-指针和数组"><a href="#5-指针和数组" class="headerlink" title="5.指针和数组"></a>5.指针和数组</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, <span class="built_in">array</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line"><span class="comment">//004FFB2C</span></span><br><span class="line"><span class="comment">//004FFB2C</span></span><br></pre></td></tr></table></figure><p>数组名表示的是数组首元素的地址。</p><blockquote><p>注：两种情况除外</p><p>1.sizeof(数组名)：数组名表示整个数组，计算的是整个数组的大小，单位是字节</p><p>2.&amp;数组名：数组名代表整个数组，返回的是整个数组的地址</p></blockquote><h2 id="6-二级指针"><a href="#6-二级指针" class="headerlink" title="6.二级指针"></a>6.二级指针</h2><p>指针变量也是变量，是变量就有地址。</p><p>那指针变量的地址存放在哪里，这就是<strong>二级指针</strong>（指向指针的指针）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;num;        <span class="comment">//a的地址存放在p中，p是一级指针</span></span><br><span class="line"><span class="type">int</span>** pp = &amp;p;        <span class="comment">//p的地址存放在pp中，pp是二级指针</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第七章、结构体"><a href="#第七章、结构体" class="headerlink" title="第七章、结构体"></a>第七章、结构体</h1><h2 id="1-结构体的声明"><a href="#1-结构体的声明" class="headerlink" title="1.结构体的声明"></a>1.结构体的声明</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line">&#125;p1;             <span class="comment">//声明类型的同时定义变量p1 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">p2</span>;</span>   <span class="comment">//定义结构体变量p2</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">p</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;n1=&#123;<span class="number">10</span>,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,<span class="literal">NULL</span>&#125;;   <span class="comment">//结构体嵌套初始化</span></span><br></pre></td></tr></table></figure><h2 id="2-结构体成员的访问"><a href="#2-结构体成员的访问" class="headerlink" title="2.结构体成员的访问"></a>2.结构体成员的访问</h2><ul><li>结构体变量访问成员</li></ul><p>结构变量的成员是通过点操作符 <strong>.</strong> 访问的。点操作符接受两个操作数。 </p><ul><li>结构体指针访问指向变量的成员</li></ul><p>有时候我们可以得到一个指向一个结构体的指针，可以通过 <strong>-&gt;</strong> 访问。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">p1</span> =</span> &#123; <span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>* <span class="title">ps</span> =</span> &amp;p1;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x = %d ; y = %d\n&quot;</span>, p1.x, p1.y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x = %d ; y = %d\n&quot;</span>, ps-&gt;x, ps-&gt;y); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-结构体传参"><a href="#3-结构体传参" class="headerlink" title="3.结构体传参"></a>3.结构体传参</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">s</span> =</span> &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;, <span class="number">1000</span>&#125;;</span><br><span class="line"><span class="comment">//结构体传参</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print1</span><span class="params">(<span class="keyword">struct</span> S s)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s.num);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//结构体地址传参</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print2</span><span class="params">(<span class="keyword">struct</span> S* ps)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ps-&gt;num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    print1(s);  <span class="comment">//传结构体</span></span><br><span class="line">    print2(&amp;s); <span class="comment">//传地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>上面的 print1 和 print2 函数哪个好些？</p><p>答案：首选print2函数。</p><p>原因：函数传参的时候，参数是需要压栈的。如果传递一个结构体对象的时候，结构体过大，参数压栈的的系统开销比较大，所以会导致性能的下降。</p><p><strong>结论</strong>：结构体传参的时候，要传结构体的地址。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
