<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C语言（进阶）笔记 | 普通博客</title><meta name="author" content="Pudding"><meta name="copyright" content="Pudding"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第一章、数据的存储1.整型在内存中的存储1.1 原码、反码和补码1int a &#x3D; 10;  计算机中的整数有三种表示方法，即原码、反码和补码。 三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位负整数的三种表示方法各不相同。  原码—直接将二进制按照正负数的形式翻译成二进制就可以。 反码—将原码的符号位不变，其他位依次按位取反就可以得到了。 补码—反码+1即为">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言（进阶）笔记">
<meta property="og:url" content="https://pudding1108.github.io/2025/06/01/C%E8%AF%AD%E8%A8%80%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="普通博客">
<meta property="og:description" content="第一章、数据的存储1.整型在内存中的存储1.1 原码、反码和补码1int a &#x3D; 10;  计算机中的整数有三种表示方法，即原码、反码和补码。 三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位负整数的三种表示方法各不相同。  原码—直接将二进制按照正负数的形式翻译成二进制就可以。 反码—将原码的符号位不变，其他位依次按位取反就可以得到了。 补码—反码+1即为">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pudding1108.github.io/image/avatar.jpg">
<meta property="article:published_time" content="2025-06-01T04:05:00.000Z">
<meta property="article:modified_time" content="2025-05-26T10:17:58.211Z">
<meta property="article:author" content="Pudding">
<meta property="article:tag" content="C">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pudding1108.github.io/image/avatar.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "C语言（进阶）笔记",
  "url": "https://pudding1108.github.io/2025/06/01/C%E8%AF%AD%E8%A8%80%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89%E7%AC%94%E8%AE%B0/",
  "image": "https://pudding1108.github.io/image/avatar.jpg",
  "datePublished": "2025-06-01T04:05:00.000Z",
  "dateModified": "2025-05-26T10:17:58.211Z",
  "author": [
    {
      "@type": "Person",
      "name": "Pudding",
      "url": "https://pudding1108.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/image/favicon.png"><link rel="canonical" href="https://pudding1108.github.io/2025/06/01/C%E8%AF%AD%E8%A8%80%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C语言（进阶）笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/image/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/image/background.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">普通博客</span></a><a class="nav-page-title" href="/"><span class="site-name">C语言（进阶）笔记</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">C语言（进阶）笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-01T04:05:00.000Z" title="发表于 2025-06-01 12:05:00">2025-06-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-26T10:17:58.211Z" title="更新于 2025-05-26 18:17:58">2025-05-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">19.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>77分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="第一章、数据的存储"><a href="#第一章、数据的存储" class="headerlink" title="第一章、数据的存储"></a>第一章、数据的存储</h1><h2 id="1-整型在内存中的存储"><a href="#1-整型在内存中的存储" class="headerlink" title="1.整型在内存中的存储"></a>1.整型在内存中的存储</h2><h3 id="1-1-原码、反码和补码"><a href="#1-1-原码、反码和补码" class="headerlink" title="1.1 原码、反码和补码"></a>1.1 原码、反码和补码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>计算机中的整数有三种表示方法，即原码、反码和补码。</p>
<p>三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而<strong>数值位负整数的三种表示方法各不相同</strong>。</p>
<blockquote>
<p>原码—直接将二进制按照正负数的形式翻译成二进制就可以。</p>
<p>反码—将原码的符号位不变，其他位依次按位取反就可以得到了。</p>
<p>补码—反码+1即为补码</p>
</blockquote>
<p><strong>数值位正整数的原码、反码、补码都相同</strong>。</p>
<p><strong>对于整型来说，数据存放内存中其实存放的是补码。</strong></p>
<p>原因：在计算机系统中，数值一律用补码来表示和存储。原因在于使用补码可以将符号位和数值域统 一处理；</p>
<p>同时，加法和减法也可以统一处理（CPU只有加法器），另一方面，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。</p>
<h3 id="1-2-大端和小端"><a href="#1-2-大端和小端" class="headerlink" title="1.2 大端和小端"></a>1.2 大端和小端</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">-10</span>;</span><br><span class="line"><span class="comment">//原码：10000000 00000000 00000000 00001010</span></span><br><span class="line"><span class="comment">//反码：11111111 11111111 11111111 11110101</span></span><br><span class="line"><span class="comment">//补码：11111111 11111111 11111111 11110110</span></span><br><span class="line"><span class="comment">//       f   f    f   f    f   f    f   6</span></span><br><span class="line"><span class="comment">//0x ff ff ff f6</span></span><br><span class="line"><span class="comment">//但是在vs中，a的地址却是f6 ff ff ff</span></span><br></pre></td></tr></table></figure>

<p>大小端是什么：</p>
<blockquote>
<p>大端（存储）模式，是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中；</p>
<p>小端（存储）模式，是指数据的低位保存在内存的低地址中，而数据的高位，保存在内存的高地址中。</p>
</blockquote>
<p>为什么会有大端和小端：</p>
<blockquote>
<p>这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8bit。</p>
<p>但是在C语言中除了8 bit的char之外，还有16 bit的short型，32 bit的long型（要看具体的编译器），另外，对于位数大于8位 的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如何将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。</p>
<p>例如：一个 16bit 的 short 型 x ，在内存中的地址为 0x0010 ， x 的值为 0x1122 ，那么 0x11 为高字节， 0x22 为低字节。</p>
<p>对于大端模式，就将 0x11 放在低地址中，即 0x0010 中， 0x22 放在高地址中，即 0x0011 中。小端模式则刚好相反。</p>
<p>我们常用的 X86 结构是小端模式，而 KEIL C51 则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。</p>
</blockquote>
<p>举一个例题：</p>
<p>请简述大端字节序和小端字节序的概念，设计一个小程序来判断当前机器的字节序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">check_sys</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (*(<span class="type">char</span> *)&amp;i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = check_sys();</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小端\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大端\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码2 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">check_sys</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">    &#125;un;</span><br><span class="line">    un.i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> un.c;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h2 id="2-浮点型在内存中的存储"><a href="#2-浮点型在内存中的存储" class="headerlink" title="2.浮点型在内存中的存储"></a>2.浮点型在内存中的存储</h2><h3 id="2-1-浮点数存储的例子"><a href="#2-1-浮点数存储的例子" class="headerlink" title="2.1 浮点数存储的例子"></a>2.1 浮点数存储的例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">9</span>;</span><br><span class="line">    <span class="type">float</span> *pFloat = (<span class="type">float</span> *)&amp;n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n的值为：%d\n&quot;</span>,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*pFloat的值为：%f\n&quot;</span>,*pFloat);</span><br><span class="line">    </span><br><span class="line">    *pFloat = <span class="number">9.0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num的值为：%d\n&quot;</span>,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*pFloat的值为：%f\n&quot;</span>,*pFloat);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p>n的值为：9</p>
<p>*pFloat的值为：0.000000</p>
<p>num的值为：1091567616</p>
<p>*pFloat的值为：9.000000</p>
<h3 id="2-2-浮点数存储规则"><a href="#2-2-浮点数存储规则" class="headerlink" title="2.2 浮点数存储规则"></a>2.2 浮点数存储规则</h3><p>num 和 *pFloat 在内存中明明是同一个数，为什么浮点数和整数的解读结果会差别这么大？</p>
<p>要理解这个结果，一定要搞懂浮点数在计算机内部的表示方法。</p>
<p>详细解读：</p>
<p>根据国际标准IEEE（电气和电子工程协会） 754，任意一个二进制浮点数V可以表示成下面的形式：</p>
<blockquote>
<p>(-1)^S * M * 2^E</p>
<p>(-1)^s表示符号位，当s&#x3D;0，V为正数；当s&#x3D;1，V为负数。</p>
<p>M表示有效数字，大于等于1，小于2。</p>
<p>2^E表示指数位。</p>
</blockquote>
<p>举例：</p>
<p>十进制的5.0，写成二进制是 101.0 ，相当于 1.01×2^2 。</p>
<p>那么，按照上面V的格式，可以得出s&#x3D;0，M&#x3D;1.01，E&#x3D;2。</p>
<p>十进制的-5.0，写成二进制是-101.0 ，相当于-1.01×2^2 。</p>
<p>那么，s&#x3D;1，M&#x3D;1.01，E&#x3D;2。</p>
<p><strong>IEEE 754规定：</strong></p>
<p>对于32位的浮点数，最高的1位是符号位s，接着的8位是指数E，剩下的23位为有效数字M。 </p>
<p>对于64位的浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。</p>
<p><strong>IEEE 754对有效数字M和指数E，还有一些特别规定：</strong></p>
<p>前面说过， 1≤M&lt;2 ，也就是说，M可以写成 1.xxxxxx 的形式，其中xxxxxx表示小数部分。</p>
<p>IEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分。</p>
<p>比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的是为了节省1位有效数字。</p>
<p>以32位浮点数为例，留给M只有23位， 将第一位的1舍去以后，等于可以保存24位有效数字。</p>
<p><strong>至于指数E，情况就比较复杂：</strong></p>
<p>首先，E为一个无符号整数（unsigned int）。</p>
<p>这意味着，如果E为8位，它的取值范围为0<del>255；如果E为11位，它的取值范围为0</del>2047。</p>
<p>但是，我们知道，科学计数法中的E是可以出现负数的，所以IEEE 754规定，存入内存时E的真实值必须再加上一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。</p>
<p>比如，2^10的E是10，所以保存成32位浮点数时，必须保存成10+127&#x3D;137，即10001001。</p>
<p><strong>然后，指数E从内存中取出还可以再分成三种情况：</strong> </p>
<p>①E不全为0或不全为1</p>
<blockquote>
<p>这时，浮点数就采用下面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1。</p>
<p>比如：</p>
<p>0.5（1&#x2F;2）的二进制形式为0.1，由于规定正数部分必须为1，即将小数点右移1位，则为 1.0*2^(-1)，其阶码为-1+127&#x3D;126，表示为 01111110，而尾数1.0去掉整数部分为0，补齐0到23位00000000000000000000000，则其二进制表示形式为:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">01111110</span> <span class="number">00000000000000000000000</span> </span><br></pre></td></tr></table></figure>

<p>②E全为0</p>
<blockquote>
<p>这时，浮点数的指数E等于1-127（或者1-1023）即为真实值，有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。</p>
</blockquote>
<p>③E全为1</p>
<blockquote>
<p>这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）；</p>
</blockquote>
<p><strong>解释一开始的例子：</strong></p>
<p>为什么 0x00000009 还原成浮点数，就成了 0.000000 ？</p>
<p>首先，将 0x00000009 拆分，得到第一位符号位s&#x3D;0，后面8位的指数 E&#x3D;00000000 ，最后23位的有效数字M&#x3D;000 0000 0000 0000 0000 1001。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span> -&gt; <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1001</span></span><br></pre></td></tr></table></figure>

<p>由于指数E全为0，所以符合上一节的第二种情况。因此，浮点数V就写成：</p>
<p>  V&#x3D;(-1)^0 × 0.00000000000000000001001×2^(-126)&#x3D;1.001×2^(-146)</p>
<p>显然，V是一个很小的接近于0的正数，所以用十进制小数表示就是0.000000。</p>
<p>浮点数9.0，如何用二进制表示？还原成十进制又是多少？</p>
<p>首先，浮点数9.0等于二进制的1001.0，即1.001×2^3</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9.0</span> -&gt; <span class="number">1001.0</span> -&gt;(<span class="number">-1</span>)^<span class="number">01.0012</span>^<span class="number">3</span> -&gt; s=<span class="number">0</span>, M=<span class="number">1.001</span>,E=<span class="number">3</span>+<span class="number">127</span>=<span class="number">130</span></span><br></pre></td></tr></table></figure>

<p>那么，第一位的符号位s&#x3D;0，有效数字M等于001后面再加20个0，凑满23位，指数E等于3+127&#x3D;130， 即10000010。所以，写成二进制形式，应该是s+E+M，即</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">10000010</span> <span class="number">001</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> </span><br></pre></td></tr></table></figure>

<p>这个32位的二进制数，还原成十进制，正是1091567616 。</p>
<h1 id="第二章、指针的进阶"><a href="#第二章、指针的进阶" class="headerlink" title="第二章、指针的进阶"></a>第二章、指针的进阶</h1><h2 id="1-字符指针"><a href="#1-字符指针" class="headerlink" title="1.字符指针"></a>1.字符指针</h2><p>在指针的类型中我们知道有一种指针类型为字符指针 char* ;</p>
<blockquote>
<p>注意：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* pstr = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这里并不是把字符串 hello 放到字符指针 pstr 里了，本质是把字符串 hello 首字符的地址放到了 pstr 中。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str1[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str3 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str4 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(str1 ==str2)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;str1 and str2 are same\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;str1 and str2 are not same\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(str3 ==str4)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;str3 and str4 are same\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;str3 and str4 are not same\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//str1 and str2 are not same</span></span><br><span class="line"><span class="comment">//str3 and str4 are same</span></span><br></pre></td></tr></table></figure>

<p>这里str3和str4指向的是一个同一个常量字符串。</p>
<p>C&#x2F;C++会把常量字符串存储到单独的一个内存区域，当几个指针。指向同一个字符串的时候，他们实际会指向同一块内存。但是用相同的常量字符串去初始化不同的数组的时候就会开辟出不同的内存块。</p>
<p>所以str1和str2不同，str3和str4相同。</p>
<h2 id="2-指针数组"><a href="#2-指针数组" class="headerlink" title="2.指针数组"></a>2.指针数组</h2><p>指针数组是一个存放指针的数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* arr1[<span class="number">10</span>]; <span class="comment">//整形指针的数组</span></span><br><span class="line"><span class="type">char</span>* arr2[<span class="number">10</span>]; <span class="comment">//一级字符指针的数组</span></span><br><span class="line"><span class="type">char</span>** arr3[<span class="number">10</span>];<span class="comment">//二级字符指针的数组</span></span><br></pre></td></tr></table></figure>



<h2 id="3-数组指针"><a href="#3-数组指针" class="headerlink" title="3.数组指针"></a>3.数组指针</h2><h3 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h3><p>数组指针是<strong>指针</strong>，是能够指向数组的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//解释：p先和*结合，说明p是一个指针变量，然后指着指向的是一个大小为10个整型的数组。所以p是一个指针，指向一个数组，叫数组指针。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里要注意：[]的优先级要高于*号的，所以必须加上（）来保证p先和*结合。</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-“数组名”-vs-“-数组名”"><a href="#3-2-“数组名”-vs-“-数组名”" class="headerlink" title="3.2 “数组名” vs “&amp;数组名”"></a>3.2 “数组名” vs “&amp;数组名”</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p>arr 和 &amp;arr 是一样的东西吗？</p>
<p>举个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arr = %p\n&quot;</span>, arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arr+1 = %p\n&quot;</span>, arr+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;arr= %p\n&quot;</span>, &amp;arr); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;arr+1= %p\n&quot;</span>, &amp;arr+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>结果：</p>
<blockquote>
<p>arr &#x3D; 012FF6EC</p>
<p>arr+1 &#x3D; 012FF6F0</p>
<p>&amp;arr&#x3D; 012FF6EC</p>
<p>&amp;arr+1&#x3D; 012FF714</p>
</blockquote>
<p>从上面代码的结果可知：&amp;arr和arr，有同样的数值，但本质上是不同的。</p>
<p><strong>实际上：</strong></p>
<p>arr是数组名，数组名表示数组首元素的地址。</p>
<p>&amp;arr 表示的是数组的地址，而不是数组首元素的地址。</p>
<p>本例中 &amp;arr 的类型是： int(*)[10] ，是一种数组指针类型</p>
<p>数组的地址+1，跳过整个数组的大小，所以 &amp;arr+1 相对于 &amp;arr 的差值是40.</p>
<h2 id="4-函数指针"><a href="#4-函数指针" class="headerlink" title="4.函数指针"></a>4.函数指针</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, test);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;test);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<blockquote>
<p>003A1474</p>
<p>003A1474</p>
</blockquote>
<p>输出了两个地址，这两个地址是 test 函数的地址。那么，如何保存函数的地址呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hehe\n&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">void</span> (*pfun)(); <span class="comment">//pfun是指针，指向一个函数</span></span><br></pre></td></tr></table></figure>

<p>补充两段有趣的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码1</span></span><br><span class="line">( *( <span class="type">void</span> (*)() )<span class="number">0</span> )();</span><br><span class="line"><span class="comment">//把0强制转换成无参无返回值的函数指针类型，然后将0解引用后调用</span></span><br><span class="line"><span class="comment">//就是调用0地址处的函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//代码2</span></span><br><span class="line"><span class="type">void</span> ( *signal( <span class="type">int</span> , <span class="type">void</span>(*)(<span class="type">int</span>) ) )(<span class="type">int</span>);</span><br><span class="line"><span class="comment">//signal是一个函数声明</span></span><br><span class="line"><span class="comment">//这个函数参数有2个，一个是int，另一个是函数指针，该指针指向的函数参数为int，返回类型是void</span></span><br><span class="line"><span class="comment">//signal函数的返回类型也是函数指针，该指针指向的函数参数int，返回类型是void</span></span><br><span class="line"><span class="comment">//简化版本</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(* <span class="type">pfun_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">pfun_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span>,<span class="type">pfun_t</span>)</span>;</span><br></pre></td></tr></table></figure>



<h2 id="5-函数指针数组"><a href="#5-函数指针数组" class="headerlink" title="5.函数指针数组"></a>5.函数指针数组</h2><p>数组是一个存放相同类型数据的存储空间，指针数组是一个存放指针的数组。</p>
<p>那如果把函数的地址存到一个数组中，这个数组就叫函数指针数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*parr[<span class="number">10</span>])();</span><br></pre></td></tr></table></figure>



<p>函数指针数组的用途：<strong>转移表</strong></p>
<p>实例：</p>
<p>使用函数指针数组实现计算器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a/b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">int</span> input = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>(*p[<span class="number">5</span>])(<span class="type">int</span> x, <span class="type">int</span> y) = &#123; <span class="number">0</span>, add, sub, mul, div &#125;; <span class="comment">//转移表     </span></span><br><span class="line">    <span class="keyword">while</span> (input)&#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;*************************\n&quot;</span> );</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;  1:add           2:sub  \n&quot;</span> );</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;  3:mul           4:div  \n&quot;</span> );</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;*************************\n&quot;</span> );</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;请选择：&quot;</span> );</span><br><span class="line">        <span class="built_in">scanf</span>( <span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">        <span class="keyword">if</span> ((input &lt;= <span class="number">4</span> &amp;&amp; input &gt;= <span class="number">1</span>))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入操作数：&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">            ret = (*p[input])(x, y);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>( <span class="string">&quot;输入有误\n&quot;</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-指向函数指针数组的指针"><a href="#6-指向函数指针数组的指针" class="headerlink" title="6.指向函数指针数组的指针"></a>6.指向函数指针数组的指针</h2><p>指向函数指针数组的指针是一个指针</p>
<p>指针指向一个数组 ，数组的元素都是函数指针  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">//函数指针pfun</span></span><br><span class="line">	<span class="type">void</span> (*pfun)(<span class="type">const</span> <span class="type">char</span>*) = test;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//函数指针的数组pfunArr</span></span><br><span class="line">	<span class="type">void</span> (*pfunArr[<span class="number">5</span>])(<span class="type">const</span> <span class="type">char</span>* str);</span><br><span class="line">	pfunArr[<span class="number">0</span>] = test;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//指向函数指针数组pfunArr的指针ppfunArr</span></span><br><span class="line">	<span class="type">void</span> (*(*ppfunArr)[<span class="number">5</span>])(<span class="type">const</span> <span class="type">char</span>*) = &amp;pfunArr;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7-回调函数"><a href="#7-回调函数" class="headerlink" title="7.回调函数"></a>7.回调函数</h2><p>回调函数就是一个通过函数指针调用的函数。</p>
<p>如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。</p>
<p>回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。  </p>
<p>举个例子：</p>
<p>首先先演示一下qsort函数（快速排序）的使用：</p>
<p>qsot函数可以排序任意类型的数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//qosrt函数的使用者须实现一个比较函数</span></span><br><span class="line"><span class="comment">//void*是一种无具体类型的指针</span></span><br><span class="line"><span class="comment">//void*的指针变量可以存放任意类型的地址</span></span><br><span class="line"><span class="comment">//void*的指针不能直接进行解引用、 +-*/ 操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">int_cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> * p1, <span class="type">const</span> <span class="type">void</span> * p2)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (*( <span class="type">int</span> *)p1 - *(<span class="type">int</span> *) p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	qsort(arr, <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), <span class="keyword">sizeof</span> (<span class="type">int</span>), int_cmp);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i&lt; <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>( <span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用回调函数，模拟实现qsort（采用冒泡的方式）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//比较函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">int_cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> * p1, <span class="type">const</span> <span class="type">void</span> * p2)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (*( <span class="type">int</span> *)p1 - *(<span class="type">int</span> *) p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> _swap(<span class="type">void</span> *p1, <span class="type">void</span> * p2, <span class="type">int</span> size)&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i&lt; size; i++)&#123;</span><br><span class="line">		<span class="type">char</span> tmp = *((<span class="type">char</span> *)p1 + i);</span><br><span class="line">		*(( <span class="type">char</span> *)p1 + i) = *((<span class="type">char</span> *) p2 + i);</span><br><span class="line">		*(( <span class="type">char</span> *)p2 + i) = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bubble</span><span class="params">(<span class="type">void</span> *base, <span class="type">int</span> count , <span class="type">int</span> size, <span class="type">int</span>(*cmp )(<span class="type">void</span> *, <span class="type">void</span> *))</span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt; count - <span class="number">1</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;count-i<span class="number">-1</span>; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (cmp ((<span class="type">char</span> *) base + j*size , (<span class="type">char</span> *)base + (j + <span class="number">1</span>)*size) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">				_swap(( <span class="type">char</span> *)base + j*size, (<span class="type">char</span> *)base + (j + <span class="number">1</span>)*size, size);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="comment">//char *arr[] = &#123;&quot;aaaa&quot;,&quot;dddd&quot;,&quot;cccc&quot;,&quot;bbbb&quot;&#125;;</span></span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	bubble(arr, <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), <span class="keyword">sizeof</span> (<span class="type">int</span>), int_cmp);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i&lt; <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>( <span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="8-指针和数组的笔试题"><a href="#8-指针和数组的笔试题" class="headerlink" title="8.指针和数组的笔试题"></a>8.指针和数组的笔试题</h2><p>X86环境</p>
<p>（X86环境下地址大小为4，X64环境下地址大小为8）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一维数组</span></span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(a));        <span class="comment">//16（数组名a单独放在sizeof内部，计算整个数组的大小）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(a+<span class="number">0</span>));      <span class="comment">//4 （a表示首元素的地址，a+0同样表示首元素的地址）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(*a));       <span class="comment">//4 （*a表示对首元素地址的解引用）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(a+<span class="number">1</span>));      <span class="comment">//4 （a表示首元素的地址，a+1表示第二个元素的地址）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(a[<span class="number">1</span>]));     <span class="comment">//4 （a[1]是数组的第二个元素）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;a));       <span class="comment">//4 （&amp;a表示数组的地址）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(*&amp;a));      <span class="comment">//16（*&amp;a表示对数组的地址的解引用）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;a+<span class="number">1</span>));     <span class="comment">//4 （&amp;a+1跳过整个数组后的地址）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;a[<span class="number">0</span>]));    <span class="comment">//4 （&amp;a[0]表示数组第一个元素的地址）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;a[<span class="number">0</span>]+<span class="number">1</span>));  <span class="comment">//4 （&amp;a[0]+1表示数组第二个元素的地址）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符数组</span></span><br><span class="line"><span class="type">char</span> arr[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr));        <span class="comment">//6</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr+<span class="number">0</span>));      <span class="comment">//4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(*arr));       <span class="comment">//1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr[<span class="number">1</span>]));     <span class="comment">//1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr));       <span class="comment">//4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr+<span class="number">1</span>));     <span class="comment">//4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr[<span class="number">0</span>]+<span class="number">1</span>));  <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(arr));        <span class="comment">//随机值，因为末尾没有&#x27;\0&#x27;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(arr+<span class="number">0</span>));      <span class="comment">//随机值，因为末尾没有&#x27;\0&#x27;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(*arr));       <span class="comment">//报错，strlen会把97（&#x27;a&#x27;的ascii值）作为起始地址统计字符串，内存访问冲突</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(arr[<span class="number">1</span>]));     <span class="comment">//报错，同上</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;arr));       <span class="comment">//报错，&amp;arr是arr数组的地址，与形参参数 类型不符合</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;arr+<span class="number">1</span>));     <span class="comment">//报错，同上</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;arr[<span class="number">0</span>]+<span class="number">1</span>));  <span class="comment">//随机值，因为末尾没有&#x27;\0&#x27;</span></span><br><span class="line"><span class="comment">//sizeof是操作符，任意类型均可</span></span><br><span class="line"><span class="comment">//sizeof获取了数据在内存中所占用的存储空间，以字节为单位来计数</span></span><br><span class="line"><span class="comment">//strlen是库函数，针对字符串</span></span><br><span class="line"><span class="comment">//strlen关注字符串中&#x27;\0&#x27;的位置，计算的是&#x27;\0&#x27;前出现了多少个字符</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> arr[] = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr));        <span class="comment">//7</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr+<span class="number">0</span>));      <span class="comment">//4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(*arr));       <span class="comment">//1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr[<span class="number">1</span>]));     <span class="comment">//1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr));       <span class="comment">//4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr+<span class="number">1</span>));     <span class="comment">//4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr[<span class="number">0</span>]+<span class="number">1</span>));  <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(arr));        <span class="comment">//6</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(arr+<span class="number">0</span>));      <span class="comment">//6</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(*arr));       <span class="comment">//报错，strlen会把97（&#x27;a&#x27;的ascii值）作为起始地址统计字符串，内存访问冲突</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(arr[<span class="number">1</span>]));     <span class="comment">//报错，同上</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;arr));       <span class="comment">//报错，&amp;arr是arr数组的地址，与形参参数 类型不符合</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;arr+<span class="number">1</span>));     <span class="comment">//报错，同上</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;arr[<span class="number">0</span>]+<span class="number">1</span>));  <span class="comment">//5</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *p = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(p));          <span class="comment">//4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(p+<span class="number">1</span>));        <span class="comment">//4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(*p));         <span class="comment">//1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(p[<span class="number">0</span>]));       <span class="comment">//1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;p));         <span class="comment">//4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;p+<span class="number">1</span>));       <span class="comment">//4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;p[<span class="number">0</span>]+<span class="number">1</span>));    <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(p));          <span class="comment">//6</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(p+<span class="number">1</span>));        <span class="comment">//5</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(*p));         <span class="comment">//报错</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(p[<span class="number">0</span>]));       <span class="comment">//报错</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;p));         <span class="comment">//报错</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;p+<span class="number">1</span>));       <span class="comment">//报错</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;p[<span class="number">0</span>]+<span class="number">1</span>));    <span class="comment">//5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二维数组</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(a));           <span class="comment">//48</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(a[<span class="number">0</span>][<span class="number">0</span>]));     <span class="comment">//4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(a[<span class="number">0</span>]));        <span class="comment">//16</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(a[<span class="number">0</span>]+<span class="number">1</span>));      <span class="comment">//4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(*(a[<span class="number">0</span>]+<span class="number">1</span>)));   <span class="comment">//4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(a+<span class="number">1</span>));         <span class="comment">//4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(*(a+<span class="number">1</span>)));      <span class="comment">//16</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;a[<span class="number">0</span>]+<span class="number">1</span>));     <span class="comment">//4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(*(&amp;a[<span class="number">0</span>]+<span class="number">1</span>)));  <span class="comment">//16</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(*a));          <span class="comment">//16</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(a[<span class="number">3</span>]));        <span class="comment">//16</span></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>：<br><strong>数组名</strong>的<strong>意义</strong>：</p>
<blockquote>
<ol>
<li>sizeof(数组名)，这里的数组名表示整个数组，计算的是整个数组的大小。</li>
<li>&amp;数组名，这里的数组名表示整个数组，取出的是整个数组的地址。</li>
<li>除此之外所有的数组名都表示首元素的地址。</li>
</ol>
</blockquote>
<h2 id="9-指针笔试题"><a href="#9-指针笔试题" class="headerlink" title="9.指针笔试题"></a>9.指针笔试题</h2><blockquote>
<p>笔试题1</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">	<span class="type">int</span> *ptr = (<span class="type">int</span> *)(&amp;a + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>( <span class="string">&quot;%d,%d&quot;</span>, *(a + <span class="number">1</span>), *(ptr - <span class="number">1</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2,5</span></span><br></pre></td></tr></table></figure>



<p>笔试题2</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> Num;</span><br><span class="line">	<span class="type">char</span> *pcName;</span><br><span class="line">	<span class="type">short</span> sDate;</span><br><span class="line">	<span class="type">char</span> cha[<span class="number">2</span>];</span><br><span class="line">	<span class="type">short</span> sBa[<span class="number">4</span>];</span><br><span class="line">&#125;*p;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, p + <span class="number">0x1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)p + <span class="number">0x1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>*)p + <span class="number">0x1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//00000014</span></span><br><span class="line"><span class="comment">//00000001</span></span><br><span class="line"><span class="comment">//00000004</span></span><br></pre></td></tr></table></figure>



<p>笔试题3</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">4</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line">	<span class="type">int</span> *ptr1 = (<span class="type">int</span> *)(&amp;a + <span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> *ptr2 = (<span class="type">int</span> *)((<span class="type">int</span>)a + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>( <span class="string">&quot;%x,%x&quot;</span>, ptr1[<span class="number">-1</span>], *ptr2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4,2000000</span></span><br></pre></td></tr></table></figure>



<p>笔试题4</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">3</span>][<span class="number">2</span>] = &#123; (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>) &#125;;</span><br><span class="line">	<span class="type">int</span> *p;</span><br><span class="line">	p = a[<span class="number">0</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure>



<p>笔试题5</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line">	<span class="type">int</span>(*p)[<span class="number">4</span>];</span><br><span class="line">	p = a;</span><br><span class="line">	<span class="built_in">printf</span>( <span class="string">&quot;%p,%d\n&quot;</span>, &amp;p[<span class="number">4</span>][<span class="number">2</span>] - &amp;a[<span class="number">4</span>][<span class="number">2</span>], &amp;p[<span class="number">4</span>][<span class="number">2</span>] - &amp;a[<span class="number">4</span>][<span class="number">2</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//FFFFFFFC,-4</span></span><br></pre></td></tr></table></figure>



<p>笔试题6</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> aa[<span class="number">2</span>][<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line">	<span class="type">int</span> *ptr1 = (<span class="type">int</span> *)(&amp;aa + <span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> *ptr2 = (<span class="type">int</span> *)(*(aa + <span class="number">1</span>));</span><br><span class="line">	<span class="built_in">printf</span>( <span class="string">&quot;%d,%d&quot;</span>, *(ptr1 - <span class="number">1</span>), *(ptr2 - <span class="number">1</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//10,5</span></span><br></pre></td></tr></table></figure>



<p>笔试题7</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span> *a[] = &#123;<span class="string">&quot;work&quot;</span>,<span class="string">&quot;at&quot;</span>,<span class="string">&quot;alibaba&quot;</span>&#125;;</span><br><span class="line">	<span class="type">char</span>**pa = a;</span><br><span class="line">	pa++;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *pa);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//at</span></span><br></pre></td></tr></table></figure>



<p>笔试题8</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span> *c[] = &#123;<span class="string">&quot;ENTER&quot;</span>,<span class="string">&quot;NEW&quot;</span>,<span class="string">&quot;POINT&quot;</span>,<span class="string">&quot;FIRST&quot;</span>&#125;;</span><br><span class="line">	<span class="type">char</span>**cp[] = &#123;c+<span class="number">3</span>,c+<span class="number">2</span>,c+<span class="number">1</span>,c&#125;;</span><br><span class="line">	<span class="type">char</span>***cpp = cp;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, **++cpp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *--*++cpp+<span class="number">3</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *cpp[<span class="number">-2</span>]+<span class="number">3</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, cpp[<span class="number">-1</span>][<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//POINT</span></span><br><span class="line"><span class="comment">//ER</span></span><br><span class="line"><span class="comment">//ST</span></span><br><span class="line"><span class="comment">//EW</span></span><br></pre></td></tr></table></figure>



<h2 id="10-附录（qsort的使用）"><a href="#10-附录（qsort的使用）" class="headerlink" title="10.附录（qsort的使用）"></a>10.附录（qsort的使用）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span><span class="comment">//qsort的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">50</span>];	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">int_cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *(<span class="type">int</span>*)a - *(<span class="type">int</span>*)b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">char_cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *(<span class="type">char</span>*)a - *(<span class="type">char</span>*)b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">double_cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *(<span class="type">double</span>*)a &gt; *(<span class="type">double</span>*)b ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">struct_cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> ((<span class="keyword">struct</span> Student*)a)-&gt;id - ((<span class="keyword">struct</span> Student*)b)-&gt;id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">str_cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span>(*(<span class="type">char</span>**)a, *(<span class="type">char</span>**)b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//int排序</span></span><br><span class="line">	<span class="type">int</span> num[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">2</span> &#125;;</span><br><span class="line">	qsort(num, <span class="keyword">sizeof</span>(num) / <span class="keyword">sizeof</span>(num[<span class="number">0</span>]), <span class="keyword">sizeof</span>(num[<span class="number">0</span>]), int_cmp);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(num) / <span class="keyword">sizeof</span>(num[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, num[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="comment">//char排序</span></span><br><span class="line">	<span class="type">char</span> word[<span class="number">5</span>] = <span class="string">&quot;CADB&quot;</span>;</span><br><span class="line">	qsort(word, <span class="keyword">sizeof</span>(word) / <span class="keyword">sizeof</span>(word[<span class="number">0</span>]), <span class="keyword">sizeof</span>(word[<span class="number">0</span>]), char_cmp);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(word) / <span class="keyword">sizeof</span>(word[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, word[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="comment">//double排序</span></span><br><span class="line">	<span class="type">double</span> in[<span class="number">5</span>] = &#123; <span class="number">1.23</span>,<span class="number">3.14159</span>,<span class="number">2.6</span>,<span class="number">5.74</span>,<span class="number">4.11</span> &#125;;</span><br><span class="line">	qsort(in, <span class="keyword">sizeof</span>(in) / <span class="keyword">sizeof</span>(in[<span class="number">0</span>]), <span class="keyword">sizeof</span>(in[<span class="number">0</span>]), double_cmp);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(in) / <span class="keyword">sizeof</span>(in[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lf &quot;</span>, in[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="comment">//struct排序</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu</span>[3] =</span> &#123; &#123;<span class="number">2</span>,<span class="string">&quot;小明&quot;</span>&#125;,&#123;<span class="number">1</span>,<span class="string">&quot;小李&quot;</span>&#125;,&#123;<span class="number">3</span>,<span class="string">&quot;小红&quot;</span>&#125; &#125;;</span><br><span class="line">	qsort(stu, <span class="keyword">sizeof</span>(stu) / <span class="keyword">sizeof</span>(stu[<span class="number">0</span>]), <span class="keyword">sizeof</span>(stu[<span class="number">0</span>]), struct_cmp);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(stu) / <span class="keyword">sizeof</span>(stu[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d%s &quot;</span>, stu[i].id,stu[i].name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="comment">//string排序</span></span><br><span class="line">	<span class="type">char</span> *str[<span class="number">5</span>] = &#123; <span class="string">&quot;AAA&quot;</span>,<span class="string">&quot;EEE&quot;</span>,<span class="string">&quot;CCC&quot;</span>,<span class="string">&quot;BBB&quot;</span>,<span class="string">&quot;DDD&quot;</span> &#125;;</span><br><span class="line">	qsort(str, <span class="keyword">sizeof</span>(str) / <span class="keyword">sizeof</span>(str[<span class="number">0</span>]), <span class="keyword">sizeof</span>(str[<span class="number">0</span>]), str_cmp);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(str) / <span class="keyword">sizeof</span>(str[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, str[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="第三章、字符串-内存函数"><a href="#第三章、字符串-内存函数" class="headerlink" title="第三章、字符串+内存函数"></a>第三章、字符串+内存函数</h1><p>C语言中对字符和字符串的处理很是频繁，但是C语言本身是没有字符串类型的，字符串通常放在<strong>常量字符串</strong>或者<strong>字符数组</strong>中。<br><strong>字符串常量</strong>适用于那些对它不做修改的字符串函数.  </p>
<h2 id="1-函数介绍"><a href="#1-函数介绍" class="headerlink" title="1.函数介绍"></a>1.函数介绍</h2><h3 id="1-1-strlen"><a href="#1-1-strlen" class="headerlink" title="1.1 strlen"></a>1.1 strlen</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * str )</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>strlen函数返回的是字符串中’\0’前面出现的字符个数（不包含’\0’）</p>
</li>
<li><p>strlen函数的返回值为size_t，是无符号的</p>
</li>
</ul>
<blockquote>
<p>size_t的真实类型与操作系统有关，</p>
<p>在32位架构中被普遍定义为：typedef  unsigned int size_t;&#x2F;&#x2F;4字节</p>
<p>而在64位架构中被定义为：typedef  unsigned long size_t;&#x2F;&#x2F;8字节</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* str1 = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* str2 = <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strlen</span>(str2)-<span class="built_in">strlen</span>(str1)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;str2&gt;str1\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;srt1&gt;str2\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//str2&gt;str1</span></span><br><span class="line"><span class="comment">//因为strlen函数返回值为size_t,strlen(str2)-strlen(str1)的结果也是size_t，所以输出str2&gt;str1</span></span><br></pre></td></tr></table></figure>



<h3 id="1-2-strcpy"><a href="#1-2-strcpy" class="headerlink" title="1.2 strcpy"></a>1.2 strcpy</h3><p>字符串复制</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> * dest, <span class="type">const</span> <span class="type">char</span> * src )</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Copies the C string pointed by source into the array pointed by destination, including the terminating null character (and stopping at that point).</p>
</li>
<li><p>源字符串必须以 ‘\0’ 结束。</p>
</li>
<li><p>会将源字符串中的 ‘\0’ 拷贝到目标空间。</p>
</li>
<li><p>目标空间必须足够大，以确保能存放源字符串。</p>
</li>
<li><p>目标空间必须可变</p>
</li>
</ul>
<h3 id="1-3-strcat"><a href="#1-3-strcat" class="headerlink" title="1.3 strcat"></a>1.3 strcat</h3><p>字符串连接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">strcat</span> <span class="params">( <span class="type">char</span> * dest, <span class="type">const</span> <span class="type">char</span> * src )</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Appends a copy of the source string to the destination string. The terminating null character in destination is overwritten by the first character of source, and a null-character is included at the end of the new string formed by the concatenation of both in destination.</p>
</li>
<li><p>源字符串必须以 ‘\0’ 结束。</p>
</li>
<li><p>目标空间必须有足够的大，能容纳下源字符串的内容。</p>
</li>
<li><p>目标空间必须可修改。</p>
</li>
</ul>
<h3 id="1-4-strcmp"><a href="#1-4-strcmp" class="headerlink" title="1.4 strcmp"></a>1.4 strcmp</h3><p>字符串比较</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * str1, <span class="type">const</span> <span class="type">char</span> * str2 )</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>This function starts comparing the first character of each string. If they are equal to each other, it continues with the following pairs until the characters differ or until a terminating null-character is reached.  </p>
</li>
<li><p>第一个字符串大于第二个字符串，则返回大于0的数字；</p>
</li>
<li><p>第一个字符串等于第二个字符串，则返回0；</p>
</li>
<li><p>第一个字符串小于第二个字符串，则返回小于0的数字。</p>
</li>
</ul>
<h3 id="1-5-strncpy"><a href="#1-5-strncpy" class="headerlink" title="1.5 strncpy"></a>1.5 strncpy</h3><p>将指定长度的字符串复制到字符数组中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">strncpy</span> <span class="params">( <span class="type">char</span> * destination, <span class="type">const</span> <span class="type">char</span> * source, <span class="type">size_t</span> num )</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Copies the first num characters of source to destination. If the end of the source C string (which is signaled by a null-character) is found before num characters have been copied, destination is padded with zeros until a total of num characters have been written to it.</p>
</li>
<li><p>拷贝num个字符从源字符串到目标空间。</p>
</li>
<li><p>如果源字符串的长度小于num，则拷贝完源字符串之后，在目标的后边追加0，直到num个。</p>
</li>
</ul>
<h3 id="1-6-strncat"><a href="#1-6-strncat" class="headerlink" title="1.6 strncat"></a>1.6 strncat</h3><p>在字符串的结尾追加n个字符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">strncat</span> <span class="params">( <span class="type">char</span> * destination, <span class="type">const</span> <span class="type">char</span> * source, <span class="type">size_t</span> num )</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>Appends the first num characters of source to destination, plus a terminating null-character.</p>
</li>
<li><p>If the length of the C string in source is less than num, only the content up to the terminating null-character is copied.</p>
</li>
</ul>
<h3 id="1-7-strncmp"><a href="#1-7-strncmp" class="headerlink" title="1.7 strncmp"></a>1.7 strncmp</h3><p>比较字符串前 n 个字节</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strncmp</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * str1, <span class="type">const</span> <span class="type">char</span> * str2, <span class="type">size_t</span> num )</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>比较到出现另个字符不一样或者一个字符串结束或者num个字符全部比较完 。</p>
</li>
<li><table>
<thead>
<tr>
<th>return value</th>
<th>indicates</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;0</td>
<td>the first character that does not match has a <strong>lower</strong> value in str1 than in str2</td>
</tr>
<tr>
<td>0</td>
<td>the contents of both strings are equal</td>
</tr>
<tr>
<td>&gt;0</td>
<td>the first character that does not match has a <strong>greater</strong> value in str1 than in str2</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="1-8-strstr"><a href="#1-8-strstr" class="headerlink" title="1.8 strstr"></a>1.8 strstr</h3><p>返回字符串中首次出现子串的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">strstr</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> * str2)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>Returns a pointer to the first occurrence of str2 in str1, or a null pointer if str2 is not part of str1.</li>
</ul>
<h3 id="1-9-strtok"><a href="#1-9-strtok" class="headerlink" title="1.9 strtok"></a>1.9 strtok</h3><p>分解字符串</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">strtok</span> <span class="params">( <span class="type">char</span> * str, <span class="type">const</span> <span class="type">char</span> * sep )</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>sep参数是个字符串，定义了用作分隔符的字符集合。</p>
</li>
<li><p>第一个参数指定一个字符串，它包含了0个或者多个由sep字符串中一个或者多个分隔符分割的标记。  </p>
</li>
<li><p>strtok函数找到str中的下一个标记，并将其用 \0 结尾，返回一个指向这个标记的指针。（注：strtok函数会改变被操作的字符串，所以在使用strtok函数切分的字符串一般都是临时拷贝的内容并且可修改。）</p>
</li>
<li><p>strtok函数的第一个参数不为 NULL ，函数将找到str中第一个标记，strtok函数将保存它在字符串中的位置。</p>
</li>
<li><p>strtok函数的第一个参数为 NULL ，函数将在同一个字符串中被保存的位置开始，查找下一个标记。</p>
</li>
<li><p>如果字符串中不存在更多的标记，则返回 NULL 指针。</p>
</li>
</ul>
<h3 id="1-10-strerror"><a href="#1-10-strerror" class="headerlink" title="1.10 strerror"></a>1.10 strerror</h3><p>返回一个指向错误字符串的指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">strerror</span> <span class="params">( <span class="type">int</span> errnum )</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回错误码，所对应的错误信息。</li>
</ul>
<p>实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span>&#123;</span><br><span class="line">   FILE *fp;</span><br><span class="line">   fp = fopen(<span class="string">&quot;file.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span>( fp == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Error: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">   &#125; </span><br><span class="line">  <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//让我们编译并运行上面的程序，这将产生以下结果，因为我们尝试打开一个不存在的文件：</span></span><br><span class="line"><span class="comment">//Error: No such file or directory</span></span><br></pre></td></tr></table></figure>



<h3 id="1-11-memcpy"><a href="#1-11-memcpy" class="headerlink" title="1.11 memcpy"></a>1.11 memcpy</h3><p>内存拷贝函数，从源内存地址的起始位置开始拷贝若干个字节到目标内存地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">memcpy</span> <span class="params">( <span class="type">void</span> * destination, <span class="type">const</span> <span class="type">void</span> * source, <span class="type">size_t</span> num )</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数memcpy从source的位置开始向后复制num个字节的数据到destination的内存位置。</li>
<li>这个函数在遇到 ‘\0’ 的时候并不会停下来。</li>
<li><strong>如果source和destination有任何的重叠，复制的结果都是未定义的。</strong>  </li>
<li>c语言规定，memcpy支持不重叠拷贝就够了，但是<strong>在vs，memcpy也能支持重叠拷贝</strong>。</li>
</ul>
<h3 id="1-12-memmove"><a href="#1-12-memmove" class="headerlink" title="1.12 memmove"></a>1.12 memmove</h3><p>拷贝字节</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">memmove</span> <span class="params">( <span class="type">void</span> * destination, <span class="type">const</span> <span class="type">void</span> * source, <span class="type">size_t</span> num )</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>和memcpy的差别就是memmove函数处理的源内存块和目标内存块是可以重叠的。</li>
<li><strong>如果源空间和目标空间出现重叠，就得使用memmove函数处理。</strong></li>
</ul>
<h3 id="1-13-memcmp"><a href="#1-13-memcmp" class="headerlink" title="1.13 memcmp"></a>1.13 memcmp</h3><p>把存储区 ptr1 和存储区 ptr2 的前 n 个字节进行比较</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span> <span class="params">( <span class="type">const</span> <span class="type">void</span> * ptr1,</span></span><br><span class="line"><span class="params">			 <span class="type">const</span> <span class="type">void</span> * ptr2,</span></span><br><span class="line"><span class="params">			 <span class="type">size_t</span> num )</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>比较从ptr1和ptr2指针开始的num个字节。</p>
</li>
<li><table>
<thead>
<tr>
<th>return value</th>
<th>indicates</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;0</td>
<td>the first byte that does not match in both memory blocks has a <strong>lower</strong> value in ptr1 than in ptr2 (if evaluated as unsigned char values)</td>
</tr>
<tr>
<td>0</td>
<td>the contents of both memory blocks are equal</td>
</tr>
<tr>
<td>&gt;0</td>
<td>the first byte that does not match in both memory blocks has a <strong>greater</strong> value in ptr1 than in ptr2 (if evaluated as unsigned char values)</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="2-函数的模拟实现"><a href="#2-函数的模拟实现" class="headerlink" title="2.函数的模拟实现"></a>2.函数的模拟实现</h2><h3 id="2-1-模拟实现strlen"><a href="#2-1-模拟实现strlen" class="headerlink" title="2.1 模拟实现strlen"></a>2.1 模拟实现strlen</h3><p>三种方式</p>
<p>方式1（计数器）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(*str)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式2（无临时变量的计数器，递归）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*str==<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+my_strlen(str+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式3（指针-指针）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">    <span class="type">char</span> *p = s;</span><br><span class="line">    <span class="keyword">while</span>(*p != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p-s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-模拟实现strcpy"><a href="#2-2-模拟实现strcpy" class="headerlink" title="2.2 模拟实现strcpy"></a>2.2 模拟实现strcpy</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src )</span>&#123;</span><br><span class="line">    <span class="type">char</span> *ret = dest;</span><br><span class="line">    assert(dest &amp;&amp; src);</span><br><span class="line">    <span class="keyword">while</span>(*dest++ = *src++);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-3-模拟实现strcat"><a href="#2-3-模拟实现strcat" class="headerlink" title="2.3 模拟实现strcat"></a>2.3 模拟实现strcat</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strcat</span> <span class="params">( <span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src )</span>&#123;</span><br><span class="line">    <span class="type">char</span> *ret = dest;</span><br><span class="line">    assert(dest &amp;&amp; src);</span><br><span class="line">    <span class="keyword">while</span>(*dest)&#123;</span><br><span class="line">        dest++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*dest++ = *src++);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-4-模拟实现strstr"><a href="#2-4-模拟实现strstr" class="headerlink" title="2.4 模拟实现strstr"></a>2.4 模拟实现strstr</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strstr</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span>&#123;</span><br><span class="line">    <span class="type">char</span> *cp = (<span class="type">char</span> *)str1;</span><br><span class="line">    <span class="type">char</span> *s1,*s2;</span><br><span class="line">    <span class="keyword">if</span>(!*str2)&#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="type">char</span> *)str1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(*cp)&#123;</span><br><span class="line">        s1 = cp;</span><br><span class="line">        s2 = (<span class="type">char</span> *)str2;</span><br><span class="line">        <span class="keyword">while</span>( *s1 &amp;&amp; *s2 &amp;&amp; !(*s1-*s2) )&#123;</span><br><span class="line">            s1++;</span><br><span class="line">            s2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!*str2)&#123;</span><br><span class="line">        	<span class="keyword">return</span> ((<span class="type">char</span> *)str1);</span><br><span class="line">    	&#125;</span><br><span class="line">        cp++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-5-模拟实现strcmp"><a href="#2-5-模拟实现strcmp" class="headerlink" title="2.5 模拟实现strcmp"></a>2.5 模拟实现strcmp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_strcmp</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> * src, <span class="type">const</span> <span class="type">char</span> * dst)</span>&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">	assert(dst &amp;&amp; src);</span><br><span class="line">	<span class="keyword">while</span>( ! (ret = *(<span class="type">unsigned</span> <span class="type">char</span> *)src - *(<span class="type">unsigned</span> <span class="type">char</span> *)dst) &amp;&amp; *dst)&#123;</span><br><span class="line">        src++;</span><br><span class="line">        dst++;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span> ( ret &lt; <span class="number">0</span> )</span><br><span class="line">		ret = <span class="number">-1</span> ;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ( ret &gt; <span class="number">0</span> )</span><br><span class="line">		ret = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-6-模拟实现memcpy"><a href="#2-6-模拟实现memcpy" class="headerlink" title="2.6 模拟实现memcpy"></a>2.6 模拟实现memcpy</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">memcpy</span> <span class="params">( <span class="type">void</span> * dst, <span class="type">const</span> <span class="type">void</span> * src, <span class="type">size_t</span> count)</span>&#123;</span><br><span class="line">	<span class="type">void</span> * ret = dst;</span><br><span class="line">	assert(dst &amp;&amp; src);</span><br><span class="line">	<span class="keyword">while</span> (count--) &#123;</span><br><span class="line">		*(<span class="type">char</span> *)dst = *(<span class="type">char</span> *)src;</span><br><span class="line">		dst = (<span class="type">char</span> *)dst + <span class="number">1</span>;</span><br><span class="line">		src = (<span class="type">char</span> *)src + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2.7 模拟实现memmove</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">memmove</span> <span class="params">( <span class="type">void</span> * dst, <span class="type">const</span> <span class="type">void</span> * src, <span class="type">size_t</span> count)</span>&#123;</span><br><span class="line">	<span class="type">void</span> * ret = dst;</span><br><span class="line">	<span class="keyword">if</span> (dst &lt;= src || (<span class="type">char</span> *)dst &gt;= ((<span class="type">char</span> *)src + count)) &#123;</span><br><span class="line">		<span class="keyword">while</span> (count--) &#123;</span><br><span class="line">			*(<span class="type">char</span> *)dst = *(<span class="type">char</span> *)src;</span><br><span class="line">			dst = (<span class="type">char</span> *)dst + <span class="number">1</span>;</span><br><span class="line">			src = (<span class="type">char</span> *)src + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		dst = (<span class="type">char</span> *)dst + count - <span class="number">1</span>;</span><br><span class="line">		src = (<span class="type">char</span> *)src + count - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (count--) &#123;</span><br><span class="line">			*(<span class="type">char</span> *)dst = *(<span class="type">char</span> *)src;</span><br><span class="line">			dst = (<span class="type">char</span> *)dst - <span class="number">1</span>;</span><br><span class="line">			src = (<span class="type">char</span> *)src - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="第四章、自定义类型详解"><a href="#第四章、自定义类型详解" class="headerlink" title="第四章、自定义类型详解"></a>第四章、自定义类型详解</h1><h2 id="1-结构体"><a href="#1-结构体" class="headerlink" title="1.结构体"></a>1.结构体</h2><p>结构是一些值的集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量。  </p>
<h3 id="1-1-结构的声明"><a href="#1-1-结构的声明" class="headerlink" title="1.1 结构的声明"></a>1.1 结构的声明</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个描述学生的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">20</span>];  <span class="comment">//名字</span></span><br><span class="line">	<span class="type">int</span> age;        <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">char</span> sex[<span class="number">5</span>];    <span class="comment">//性别</span></span><br><span class="line">	<span class="type">char</span> id[<span class="number">20</span>];    <span class="comment">//学号</span></span><br><span class="line">&#125;;                  <span class="comment">//分号不能丢</span></span><br></pre></td></tr></table></figure>

<p>在声明结构的时候，可以不完全的声明（省略结构体的标签）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">char</span> b;</span><br><span class="line">	<span class="type">float</span> c;</span><br><span class="line">&#125;x;</span><br></pre></td></tr></table></figure>



<h3 id="1-2-结构的自引用"><a href="#1-2-结构的自引用" class="headerlink" title="1.2  结构的自引用"></a>1.2  结构的自引用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="1-3-结构体变量的定义与初始化"><a href="#1-3-结构体变量的定义与初始化" class="headerlink" title="1.3 结构体变量的定义与初始化"></a>1.3 结构体变量的定义与初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">&#125;p1;                <span class="comment">//声明类型的同时定义变量p1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">p2</span>;</span>    <span class="comment">//定义结构体变量p2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化：定义变量的同时赋初值。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">p3</span> =</span> &#123;x, y&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">15</span>];  <span class="comment">//名字</span></span><br><span class="line">	<span class="type">int</span> age;        <span class="comment">//年龄</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">s</span> =</span> &#123;<span class="string">&quot;zhangsan&quot;</span>, <span class="number">20</span>&#125;;     <span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">p</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;n1 = &#123;<span class="number">10</span>, &#123;<span class="number">4</span>,<span class="number">5</span>&#125;, <span class="literal">NULL</span>&#125;;            <span class="comment">//结构体嵌套初始化</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">n2</span> =</span> &#123;<span class="number">20</span>, &#123;<span class="number">5</span>, <span class="number">6</span>&#125;, <span class="literal">NULL</span>&#125;;<span class="comment">//结构体嵌套初始化</span></span><br></pre></td></tr></table></figure>



<h3 id="1-4-结构体内存对齐"><a href="#1-4-结构体内存对齐" class="headerlink" title="1.4 结构体内存对齐"></a>1.4 结构体内存对齐</h3><p>结构体中元素是按照定义顺序一个一个放到内存中去的，但并不是紧密排列的。</p>
<p><strong>结构体的对齐规则</strong>：</p>
<p>1.<strong>第一个成员在与结构体变量偏移量为0的地址处。</strong></p>
<p>2.<strong>其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。</strong></p>
<p>（对齐数 &#x3D; 编译器默认的一个对齐数 与 该成员大小的较小值）</p>
<p>3.结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍。</p>
<p>4.如果<strong>嵌套了结构体</strong>的情况，嵌套的结构体对齐到<strong>自己的最大对齐数的整数倍</strong>处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。  </p>
<p><strong>为什么存在内存对齐？</strong></p>
<p>大部份资料都是这样说的</p>
<p>1.<strong>平台</strong>原因(移植原因)：</p>
<p>不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。 </p>
<p>2.<strong>性能</strong>原因：</p>
<p>数据结构(尤其是栈)应该尽可能地在自然边界上对齐。</p>
<p>原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问  </p>
<blockquote>
<p>总体来说，结构体的内存对齐是<strong>拿空间来换取时间</strong>的做法。  </p>
<p>所以我们在设计结构体时，应该<strong>让占用空间小的成员尽量集中在一起</strong>。  </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//练习1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> c1;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">char</span> c2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> S1));</span><br><span class="line"><span class="comment">//12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//练习2</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> c1;</span><br><span class="line">	<span class="type">char</span> c2;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> S2));</span><br><span class="line"><span class="comment">//8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//练习3</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S3</span>&#123;</span></span><br><span class="line">	<span class="type">double</span> d;</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> S3));</span><br><span class="line"><span class="comment">//16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//练习4-结构体嵌套问题</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S4</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> c1;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">S3</span> <span class="title">s3</span>;</span></span><br><span class="line">	<span class="type">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> S4));</span><br><span class="line"><span class="comment">//32</span></span><br></pre></td></tr></table></figure>



<h3 id="1-5-修改默认对齐数"><a href="#1-5-修改默认对齐数" class="headerlink" title="1.5 修改默认对齐数"></a>1.5 修改默认对齐数</h3><p>不知道大家是否见过 #pragma 这个预处理指令，这里使用可以改变我们的默认对齐数。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(8)<span class="comment">//设置默认对齐数为8</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> c1;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">char</span> c2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()<span class="comment">//取消设置的默认对齐数，还原为默认</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)<span class="comment">//设置默认对齐数为1</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> c1;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">char</span> c2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()<span class="comment">//取消设置的默认对齐数，还原为默认</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//输出的结果是什么？</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> S1));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> S2));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结论</strong>：结构在对齐方式不合适的时候，我么可以自己更改默认对齐数。  </p>
<h3 id="1-6-结构体传参"><a href="#1-6-结构体传参" class="headerlink" title="1.6 结构体传参"></a>1.6 结构体传参</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data[<span class="number">1000</span>];</span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">s</span> =</span> &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;, <span class="number">1000</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体传参</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print1</span><span class="params">(<span class="keyword">struct</span> S s)</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s.num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体地址传参</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print2</span><span class="params">(<span class="keyword">struct</span> S* ps)</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ps-&gt;num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	print1(s); <span class="comment">//传结构体</span></span><br><span class="line">	print2(&amp;s); <span class="comment">//传地址</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的 print1 和 print2 函数哪个好些？</p>
<p>答案：首选print2函数。  </p>
<p><strong>结构体传参的时候，要传结构体的地址。</strong>  </p>
<blockquote>
<p>原因：</p>
<p>函数传参的时候，参数是需要压栈，会有时间和空间上的系统开销。</p>
<p>如果传递一个结构体对象的时候，结构体过大，参数压栈的的系统开销比较大，所以会导致性能的下降。  </p>
</blockquote>
<h2 id="2-位段"><a href="#2-位段" class="headerlink" title="2.位段"></a>2.位段</h2><h3 id="2-1-什么是位段"><a href="#2-1-什么是位段" class="headerlink" title="2.1 什么是位段"></a>2.1 什么是位段</h3><p>位段的声明和结构是类似的，有两个不同：</p>
<p>1.位段的成员必须是 int、unsigned int 或signed int 。</p>
<p>2.位段的成员名后边有一个冒号和一个数字。  </p>
<p>实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="comment">//4byte</span></span><br><span class="line">	<span class="type">int</span> _a:<span class="number">2</span>;  <span class="comment">//剩30bit</span></span><br><span class="line">	<span class="type">int</span> _b:<span class="number">5</span>;  <span class="comment">//剩25bit</span></span><br><span class="line">	<span class="type">int</span> _c:<span class="number">10</span>; <span class="comment">//剩15bit</span></span><br><span class="line">    <span class="comment">//4byte（vs上不会使用之前剩余的15bit）</span></span><br><span class="line">	<span class="type">int</span> _d:<span class="number">30</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//A就是一个位段类型</span></span><br><span class="line"><span class="comment">//位段A的大小 8字节</span></span><br></pre></td></tr></table></figure>



<h3 id="2-2-位段的内存分配"><a href="#2-2-位段的内存分配" class="headerlink" title="2.2 位段的内存分配"></a>2.2 位段的内存分配</h3><p>1.位段的成员可以是 int unsigned int signed int 或者是 char （属于整形家族）类型</p>
<p>2.位段的空间上是按照需要以**4个字节（ int ）<strong>或者</strong>1个字节（ char ）**的方式来开辟的。</p>
<p>3.位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段  </p>
<h3 id="2-3-位段的跨平台问题"><a href="#2-3-位段的跨平台问题" class="headerlink" title="2.3 位段的跨平台问题"></a>2.3 位段的跨平台问题</h3><p>1.int 位段被当成有符号数还是无符号数是不确定的。</p>
<p>2.位段中最大位的数目不能确定。（16位机器最大16，32位机器最大32，写成27，在16位机器会出问题。</p>
<p>3.位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义。</p>
<p>4.当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是舍弃剩余的位还是利用，这是不确定的。</p>
<p><strong>总结</strong>：跟结构相比，位段可以达到同样的效果，但是可以很好的节省空间，但是有跨平台的问题存在。  </p>
<h2 id="3-枚举"><a href="#3-枚举" class="headerlink" title="3.枚举"></a>3.枚举</h2><h3 id="3-1-枚举类型的定义"><a href="#3-1-枚举类型的定义" class="headerlink" title="3.1 枚举类型的定义"></a>3.1 枚举类型的定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//星期</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Day</span>&#123;</span></span><br><span class="line">	Mon,</span><br><span class="line">	Tues,</span><br><span class="line">	Wed,</span><br><span class="line">	Thur,</span><br><span class="line">	Fri,</span><br><span class="line">	Sat,</span><br><span class="line">	Sun</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//性别</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Sex</span>&#123;</span></span><br><span class="line">	MALE,</span><br><span class="line">	FEMALE,</span><br><span class="line">	SECRET</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="comment">//颜色</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span>&#123;</span></span><br><span class="line">	RED,</span><br><span class="line">	GREEN,</span><br><span class="line">	BLUE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上定义的 enum Day ， enum Sex ， enum Color 都是枚举类型。</p>
<p>{}中的内容是枚举类型的可能取值，也叫 枚举常量 。</p>
<p>这些可能取值都是有值的，默认从0开始，一次递增1，当然在定义的时候也可以赋初值。  </p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//颜色</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span>&#123;</span></span><br><span class="line">	RED = <span class="number">1</span>,</span><br><span class="line">	GREEN = <span class="number">2</span>,</span><br><span class="line">	BLUE = <span class="number">4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="3-2-枚举的优点"><a href="#3-2-枚举的优点" class="headerlink" title="3.2 枚举的优点"></a>3.2 枚举的优点</h3><p>1.增加代码的可读性和可维护性</p>
<p>2.和#define定义的标识符比较，枚举有类型检查，更加严谨。</p>
<p>3.防止了命名污染（封装）</p>
<p>4.便于调试</p>
<p>5.使用方便，一次可以定义多个常量 </p>
<h3 id="3-3-枚举的应用"><a href="#3-3-枚举的应用" class="headerlink" title="3.3 枚举的应用"></a>3.3 枚举的应用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span>&#123;</span></span><br><span class="line">	RED=<span class="number">1</span>,</span><br><span class="line">	GREEN=<span class="number">2</span>,</span><br><span class="line">	BLUE=<span class="number">4</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> <span class="title">clr</span> =</span> GREEN;<span class="comment">//只能拿枚举常量给枚举变量赋值，才不会出现类型的差异。</span></span><br></pre></td></tr></table></figure>



<h2 id="4-联合（共用体）"><a href="#4-联合（共用体）" class="headerlink" title="4.联合（共用体）"></a>4.联合（共用体）</h2><h3 id="4-1-联合类型的定义"><a href="#4-1-联合类型的定义" class="headerlink" title="4.1 联合类型的定义"></a>4.1 联合类型的定义</h3><p>联合也是一种特殊的自定义类型</p>
<p>这种类型定义的变量也包含一系列的成员，特征是这些成员公用同一块空间（所以联合也叫共用体）。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//联合类型的声明</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Un</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//联合变量的定义</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Un</span> <span class="title">un</span>;</span></span><br></pre></td></tr></table></figure>



<h3 id="4-2-联合的特点"><a href="#4-2-联合的特点" class="headerlink" title="4.2 联合的特点"></a>4.2 联合的特点</h3><p>联合的成员是共用同一块内存空间的，这样一个联合变量的大小，至少是最大成员的大小（因为联合至少得有能力保存最大的那个成员）  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Un</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Un</span> <span class="title">un</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面输出的结果是一样的吗？</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, &amp;(un.i));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, &amp;(un.c));</span><br><span class="line"><span class="comment">//结果是一样的（说明同一时间只能用一个）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面输出的结果是什么？</span></span><br><span class="line">un.i = <span class="number">0x11223344</span>;</span><br><span class="line">un.c = <span class="number">0x55</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, un.i);</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>



<h3 id="4-3-联合大小的计算"><a href="#4-3-联合大小的计算" class="headerlink" title="4.3 联合大小的计算"></a>4.3 联合大小的计算</h3><p>联合的大小至少是最大成员的大小。</p>
<p>当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Un1</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> c[<span class="number">5</span>];</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Un2</span>&#123;</span></span><br><span class="line">	<span class="type">short</span> c[<span class="number">7</span>];</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//下面输出的结果是什么？</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">union</span> Un1));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">union</span> Un2));</span><br></pre></td></tr></table></figure>



<h3 id="4-4-面试题"><a href="#4-4-面试题" class="headerlink" title="4.4 面试题"></a>4.4 面试题</h3><p>判断当前计算机的大小端存储</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">check_sys</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">    &#125;un;</span><br><span class="line">    un.i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> un.c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果返回1，表示小端</span></span><br><span class="line"><span class="comment">//如果返回0，表示大端</span></span><br></pre></td></tr></table></figure>







<h1 id="第五章、动态内存管理"><a href="#第五章、动态内存管理" class="headerlink" title="第五章、动态内存管理"></a>第五章、动态内存管理</h1><h2 id="1-动态内存分配的必要性"><a href="#1-动态内存分配的必要性" class="headerlink" title="1.动态内存分配的必要性"></a>1.动态内存分配的必要性</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">20</span>;        <span class="comment">//在栈空间上开辟四个字节</span></span><br><span class="line"><span class="type">char</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">//在栈空间上开辟10个字节的连续空间</span></span><br></pre></td></tr></table></figure>

<p>上述开辟空间方式有两个特点：</p>
<p>1.空间开辟大小是固定的。</p>
<p>2.数组在申明的时候，必须指定数组的长度，它所需要的内存在编译时分配  </p>
<p>但是对于空间的需求，不仅仅是上述的情况。有时候我们需要的空间大小在程序运行的时候才能知道，那数组的编译时开辟空间的方式就不能满足了。这时候就只能试试动态存开辟了  </p>
<h2 id="2-动态内存函数的介绍"><a href="#2-动态内存函数的介绍" class="headerlink" title="2.动态内存函数的介绍"></a>2.动态内存函数的介绍</h2><h3 id="2-1-malloc-和-free"><a href="#2-1-malloc-和-free" class="headerlink" title="2.1 malloc 和 free"></a>2.1 malloc 和 free</h3><p>malloc和free都声明在 stdlib.h 头文件中  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">malloc</span> <span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针。</p>
<ul>
<li><p>如果开辟成功，则返回一个指向开辟好空间的指针。</p>
</li>
<li><p>如果开辟失败，则返回一个NULL指针，因此malloc的返回值一定要做检查。</p>
</li>
<li><p>返回值的类型是 void* ，所以malloc函数并不知道开辟空间的类型，具体在使用的时候使用者自己来决定。</p>
</li>
<li><p>如果参数 size 为0，malloc的行为是标准是未定义的，取决于编译器。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span> <span class="params">(<span class="type">void</span>* ptr)</span>;</span><br></pre></td></tr></table></figure>

<p>free函数用来释放动态开辟的内存。</p>
<ul>
<li><p>如果参数 ptr 指向的空间不是动态开辟的，那free函数的行为是未定义的。</p>
</li>
<li><p>如果参数 ptr 是NULL指针，则函数什么事都不做。</p>
</li>
</ul>
<h3 id="2-2-calloc"><a href="#2-2-calloc" class="headerlink" title="2.2 calloc"></a>2.2 calloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">calloc</span> <span class="params">(<span class="type">size_t</span> num, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>函数的功能是为 num 个大小为 size 的元素开辟一块空间，并且把空间的每个字节初始化为0。</p>
</li>
<li><p>与函数 malloc 的区别只在于 calloc 会在返回地址之前把申请的空间的每个字节初始化为全0。</p>
</li>
</ul>
<h3 id="2-3-realloc"><a href="#2-3-realloc" class="headerlink" title="2.3 realloc"></a>2.3 realloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">realloc</span> <span class="params">(<span class="type">void</span>* ptr, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>ptr 是要调整的内存地址</p>
</li>
<li><p>size 调整之后新大小</p>
</li>
<li><p>返回值为调整之后的内存起始位置。</p>
</li>
<li><p>这个函数调整原内存空间大小的基础上，还会将原来内存中的数据移动到新的空间。</p>
</li>
</ul>
<p><strong>realloc</strong>在<strong>调整内存空间</strong>的是存在<strong>两种情况</strong> ：</p>
<p><strong>第一种情况</strong>：原有空间之后有足够大的空间 </p>
<p>扩展内存就直接在原有内存之后直接追加空间，原来空间的数据不发生变化。  </p>
<p><strong>第二种情况</strong>：原有空间之后没有足够大的空间 </p>
<p>在堆空间上另找一个合适大小的连续空间来使用。这样函数返回的是一个新的内存地址  </p>
<p><strong>realloc如果调整失败，会返回一个空指针</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p=(<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="number">10</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="type">int</span>* ptr=(<span class="type">int</span>*)<span class="built_in">realloc</span>(p,<span class="number">80</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> != ptr)&#123;<span class="comment">//避免realloc调整失败后返回空指针覆盖p</span></span><br><span class="line">    p=ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line">ptr=<span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p=<span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>



<h2 id="3-常见的动态内存错误"><a href="#3-常见的动态内存错误" class="headerlink" title="3.常见的动态内存错误"></a>3.常见的动态内存错误</h2><h3 id="3-1-对NULL指针的解引用操作"><a href="#3-1-对NULL指针的解引用操作" class="headerlink" title="3.1 对NULL指针的解引用操作"></a>3.1 对NULL指针的解引用操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(INT_MAX);</span><br><span class="line">	*p = <span class="number">20</span>;              <span class="comment">//如果p的值是NULL，就会有问题</span></span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-2-对动态开辟空间的越界访问"><a href="#3-2-对动态开辟空间的越界访问" class="headerlink" title="3.2 对动态开辟空间的越界访问"></a>3.2 对动态开辟空间的越界访问</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == p)&#123;</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;=<span class="number">10</span>; i++)&#123;</span><br><span class="line">		*(p+i) = i;       <span class="comment">//当i是10的时候越界访问</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-3-对非动态开辟内存使用free释放"><a href="#3-3-对非动态开辟内存使用free释放" class="headerlink" title="3.3 对非动态开辟内存使用free释放"></a>3.3 对非动态开辟内存使用free释放</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> *p = &amp;a;</span><br><span class="line">	<span class="built_in">free</span>(p);<span class="comment">//ok?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-4-使用free释放一块动态开辟内存的一部分"><a href="#3-4-使用free释放一块动态开辟内存的一部分" class="headerlink" title="3.4 使用free释放一块动态开辟内存的一部分"></a>3.4 使用free释放一块动态开辟内存的一部分</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">	p++;</span><br><span class="line">	<span class="built_in">free</span>(p);              <span class="comment">//p不再指向动态内存的起始位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-5-对同一块动态内存多次释放"><a href="#3-5-对同一块动态内存多次释放" class="headerlink" title="3.5 对同一块动态内存多次释放"></a>3.5 对同一块动态内存多次释放</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="built_in">free</span>(p);              <span class="comment">//重复释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-6-动态开辟-内存忘记释放（内存泄漏）"><a href="#3-6-动态开辟-内存忘记释放（内存泄漏）" class="headerlink" title="3.6 动态开辟 内存忘记释放（内存泄漏）"></a>3.6 动态开辟 内存忘记释放（内存泄漏）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> != p)&#123;</span><br><span class="line">		*p = <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//忘记释放，就会出现内存泄漏的问题</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	test();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>动态开辟的空间一定要释放，并且正确释放。</strong></p>
<h2 id="4-经典的笔试题"><a href="#4-经典的笔试题" class="headerlink" title="4.经典的笔试题"></a>4.经典的笔试题</h2><p><strong>题目1</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GetMemory</span><span class="params">(<span class="type">char</span> *p)</span>&#123;</span><br><span class="line">	p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">	GetMemory(str);</span><br><span class="line">	<span class="built_in">strcpy</span>(str, <span class="string">&quot;hello world&quot;</span>);  <span class="comment">//str仍然是空指针，会非法访问内存，程序会崩溃</span></span><br><span class="line">	<span class="built_in">printf</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问运行Test 函数会有什么样的结果？  </p>
<p>程序崩溃</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改后</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetMemory</span><span class="params">(<span class="type">char</span>** p)</span>&#123;</span><br><span class="line">	*p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">	GetMemory(&amp;str);</span><br><span class="line">	<span class="built_in">strcpy</span>(str, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(str);</span><br><span class="line">    <span class="built_in">free</span>(str);</span><br><span class="line">    str = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>题目2</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">GetMemory</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">char</span> p[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">	str = GetMemory();</span><br><span class="line">	<span class="built_in">printf</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问运行Test 函数会有什么样的结果？  </p>
<p>会出现一段乱码，函数结束后空间会回收。</p>
<p><strong>题目3</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GetMemory</span><span class="params">(<span class="type">char</span> **p, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">	*p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">	GetMemory(&amp;str, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问运行Test 函数会有什么样的结果？</p>
<p>存在内存泄漏，没有释放内存。</p>
<p><strong>题目4</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">char</span> *str = (<span class="type">char</span> *) <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(str);    <span class="comment">//free不会让str指向空，需要主动把str指向NULL</span></span><br><span class="line">	<span class="keyword">if</span>(str != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(str, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问运行Test 函数会有什么样的结果？</p>
<p>非法访问内存，str指向的空间释放后不能再次使用。</p>
<h2 id="5-C-C-程序的内存开辟"><a href="#5-C-C-程序的内存开辟" class="headerlink" title="5.C&#x2F;C++程序的内存开辟"></a>5.C&#x2F;C++程序的内存开辟</h2><p>C&#x2F;C++程序内存分配的几个区域：</p>
<p>1.<strong>内核空间</strong>：用户代码不能读写</p>
<p>2.<strong>栈区（stack）</strong>（向下增长）：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 栈区主要存放运行函数而分配的局部变量、函数参数、返回数据、返回地址等。</p>
<p>3.<strong>堆区（heap）</strong>（向上增长）：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。分配方式类似于链表。</p>
<p>4.<strong>数据段（静态区）</strong>（static）存放<strong>全局变量</strong>、<strong>静态数据</strong>。程序结束后由系统释放。</p>
<p>5.<strong>代码段</strong>：存放函数体（类成员函数和全局函数）的二进制代码&#x2F;只读常量</p>
<h2 id="6-柔性数组"><a href="#6-柔性数组" class="headerlink" title="6.柔性数组"></a>6.柔性数组</h2><p>C99 中，结构中的最后一个元素允许是未知大小的数组，这就叫做『柔性数组』（flexible array）成员。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">st_type</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> a[];     <span class="comment">//柔性数组成员</span></span><br><span class="line">&#125;type_a;</span><br></pre></td></tr></table></figure>

<h3 id="6-1-柔性数组的特点"><a href="#6-1-柔性数组的特点" class="headerlink" title="6.1 柔性数组的特点"></a>6.1 柔性数组的特点</h3><ul>
<li><p>结构中的柔性数组成员前面必须至少一个其他成员。</p>
</li>
<li><p>sizeof 返回的这种结构大小不包括柔性数组的内存。</p>
</li>
<li><p><strong>包含柔性数组成员的结构用malloc ()函数进行内存的动态分配</strong>，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小。</p>
</li>
</ul>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">st_type</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> a[];                   <span class="comment">//柔性数组成员</span></span><br><span class="line">&#125;type_a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(type_a)); <span class="comment">//输出的是4</span></span><br></pre></td></tr></table></figure>



<h3 id="6-2-柔性数组的使用"><a href="#6-2-柔性数组的使用" class="headerlink" title="6.2 柔性数组的使用"></a>6.2 柔性数组的使用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码1</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">type_a *p = (type_a*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(type_a)+<span class="number">100</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">//业务处理</span></span><br><span class="line">p-&gt;i = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">	p-&gt;a[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure>

<p>这样柔性数组成员a，相当于获得了100个整型元素的连续空间。</p>
<h3 id="6-3-柔性数组的优势"><a href="#6-3-柔性数组的优势" class="headerlink" title="6.3 柔性数组的优势"></a>6.3 柔性数组的优势</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">st_type</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> *p_a;</span><br><span class="line">&#125;type_a;</span><br><span class="line">type_a *p = (type_a *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(type_a));</span><br><span class="line">p-&gt;i = <span class="number">100</span>;</span><br><span class="line">p-&gt;p_a = (<span class="type">int</span> *)<span class="built_in">malloc</span>(p-&gt;i*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务处理</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">	p-&gt;p_a[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放空间</span></span><br><span class="line"><span class="built_in">free</span>(p-&gt;p_a);</span><br><span class="line">p-&gt;p_a = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>上述 代码1 和 代码2 可以完成同样的功能，但是 方法1 的实现有两个好处：</p>
<ul>
<li>方便内存释放</li>
</ul>
<p>如果我们的代码是在一个给别人用的函数中，你在里面做了二次内存分配，并把整个结构体返回给用户。用户调用free可以释放结构体，但是用户并不知道这个结构体内的成员也需要free，所以你不能指望用户来发现这个事。所以，如果我们把结构体的内存以及其成员要的内存一次性分配好了，并返回给用户一个结构体指针，用户做一次free就可以把所有的内存也给释放掉。 </p>
<ul>
<li>有利于提高访问速度</li>
</ul>
<p> 连续的内存有益于提高访问速度，也有益于减少内存碎片。（其实，我个人觉得也没多高了，反正你跑不了要用做偏移量的加法来寻址）  </p>
<h1 id="第六章、小练习：通讯录"><a href="#第六章、小练习：通讯录" class="headerlink" title="第六章、小练习：通讯录"></a>第六章、小练习：通讯录</h1><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>通讯录（暂时不考虑名字相同）</p>
<p>1.可以存放1000个人的信息</p>
<p>2.人的信息：名字，年龄，电话，住址，性别</p>
<p>3.增、删、改、查联系人</p>
<p>动态增加</p>
<p>查询根据联系人的电话查询</p>
<p>4.排序（根据年龄排序）</p>
<h2 id="二、完整代码"><a href="#二、完整代码" class="headerlink" title="二、完整代码"></a>二、完整代码</h2><p><strong>contact.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAME_MAX 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEX_MAX 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADDR_MAX 30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TELE_MAX 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULE_SZ 10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">option</span> &#123;</span></span><br><span class="line">	EXIT,</span><br><span class="line">	ADD,</span><br><span class="line">	DEL,</span><br><span class="line">	SEARCH,</span><br><span class="line">	MODIFY,</span><br><span class="line">	SORT,</span><br><span class="line">	SHOW,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PeoInfo</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> name[NAME_MAX];</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">char</span> sex[SEX_MAX];</span><br><span class="line">	<span class="type">char</span> addr[ADDR_MAX];</span><br><span class="line">	<span class="type">char</span> tele[TELE_MAX];</span><br><span class="line">&#125;PeoInfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Contact</span> &#123;</span></span><br><span class="line">	PeoInfo* data;<span class="comment">//存放数据</span></span><br><span class="line">	<span class="type">int</span> sz;<span class="comment">//通讯录中有效信息的个数</span></span><br><span class="line">	<span class="type">int</span> capacity;<span class="comment">//通讯录的最大容量</span></span><br><span class="line">&#125;Contact;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化通讯录</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitContact</span><span class="params">(Contact* pc)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁通讯录</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyContact</span><span class="params">(Contact* pc)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加联系人</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AddContact</span><span class="params">(Contact* pc)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印所有通讯录信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowContact</span><span class="params">(<span class="type">const</span> Contact* pc)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印一条通讯录信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowOneContact</span><span class="params">(<span class="type">const</span> Contact* pc, <span class="type">int</span> index)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按电话查找</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FindByTele</span><span class="params">(<span class="type">const</span> Contact* pc,<span class="type">char</span> tele[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除联系人</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DeleteContact</span><span class="params">(Contact* pc)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找联系人</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SearchContact</span><span class="params">(Contact* pc)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改联系人</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ModifyContact</span><span class="params">(Contact* pc)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//联系人排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SortContact</span><span class="params">(Contact* pc)</span>;</span><br></pre></td></tr></table></figure>



<p><strong>contact.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;contact.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitContact</span><span class="params">(Contact* pc)</span> &#123;</span><br><span class="line">	assert(pc);</span><br><span class="line">	pc-&gt;sz = <span class="number">0</span>;</span><br><span class="line">	PeoInfo* tmp = (PeoInfo*)<span class="built_in">malloc</span>(DEFAULE_SZ * <span class="keyword">sizeof</span>(PeoInfo));</span><br><span class="line">	<span class="keyword">if</span> (tmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		pc-&gt;data = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;InitContact()::%s\n&quot;</span>,strerror(errno));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pc-&gt;capacity = DEFAULE_SZ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_capacity</span><span class="params">(Contact* pc)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (pc-&gt;sz == pc-&gt;capacity) &#123;</span><br><span class="line">		<span class="comment">//增加容量</span></span><br><span class="line">		PeoInfo* tmp = (PeoInfo*)<span class="built_in">realloc</span>(pc-&gt;data, (pc-&gt;capacity + <span class="number">2</span>) * <span class="keyword">sizeof</span>(PeoInfo));</span><br><span class="line">		<span class="keyword">if</span> (tmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			pc-&gt;data = tmp;</span><br><span class="line">			pc-&gt;capacity += <span class="number">2</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;增容成功\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;check_capacity()::%s\n&quot;</span>, strerror(errno));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyContact</span><span class="params">(Contact* pc)</span> &#123;</span><br><span class="line">	<span class="built_in">free</span>(pc-&gt;data);</span><br><span class="line">	pc-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">	pc-&gt;sz = <span class="number">0</span>;</span><br><span class="line">	pc-&gt;capacity = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AddContact</span><span class="params">(Contact* pc)</span> &#123;</span><br><span class="line">	assert(pc);</span><br><span class="line">	check_capacity(pc);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//输入联系人</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入名字：&gt;&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, pc-&gt;data[pc-&gt;sz].name);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入年龄：&gt;&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(pc-&gt;data[pc-&gt;sz].age));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入性别：&gt;&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, pc-&gt;data[pc-&gt;sz].sex);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入电话：&gt;&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, pc-&gt;data[pc-&gt;sz].tele);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入地址：&gt;&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, pc-&gt;data[pc-&gt;sz].addr);</span><br><span class="line"></span><br><span class="line">	pc-&gt;sz++;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;增加联系人成功\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowContact</span><span class="params">(<span class="type">const</span> Contact* pc)</span> &#123;</span><br><span class="line">	assert(pc);</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%-10s\t%-5s\t%-5s\t%-13s\t%-20s\n&quot;</span>, <span class="string">&quot;名字&quot;</span>, <span class="string">&quot;年龄&quot;</span>, <span class="string">&quot;性别&quot;</span>, <span class="string">&quot;电话&quot;</span>, <span class="string">&quot;地址&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pc-&gt;sz; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%-10s\t%-5d\t%-5s\t%-13s\t%-20s\n&quot;</span>,</span><br><span class="line">			pc-&gt;data[i].name, pc-&gt;data[i].age, pc-&gt;data[i].sex, pc-&gt;data[i].tele, pc-&gt;data[i].addr);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowOneContact</span><span class="params">(<span class="type">const</span> Contact* pc, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">	assert(pc);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%-10s\t%-5s\t%-5s\t%-13s\t%-20s\n&quot;</span>, <span class="string">&quot;名字&quot;</span>, <span class="string">&quot;年龄&quot;</span>, <span class="string">&quot;性别&quot;</span>, <span class="string">&quot;电话&quot;</span>, <span class="string">&quot;地址&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%-10s\t%-5d\t%-5s\t%-13s\t%-20s\n&quot;</span>,</span><br><span class="line">		pc-&gt;data[i].name, pc-&gt;data[i].age, pc-&gt;data[i].sex, pc-&gt;data[i].tele, pc-&gt;data[i].addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">FindByTele</span><span class="params">(<span class="type">const</span> Contact* pc,<span class="type">char</span> tele[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pc-&gt;sz; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(pc-&gt;data[i].tele, tele) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DeleteContact</span><span class="params">(Contact* pc)</span> &#123;</span><br><span class="line">	assert(pc);</span><br><span class="line">	<span class="type">char</span> tele[TELE_MAX] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">if</span> (pc-&gt;sz == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;通讯录空了，无法删除\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入要删除人的电话：&gt;&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, tele);</span><br><span class="line">	<span class="type">int</span> pos = FindByTele(pc, tele);</span><br><span class="line">	<span class="keyword">if</span> (pos == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;要删除的人不存在\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (j = pos; j &lt; pc-&gt;sz<span class="number">-1</span>; j++) &#123;</span><br><span class="line">			pc-&gt;data[j] = pc-&gt;data[j + <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		pc-&gt;sz--;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;删除指定联系人成功\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SearchContact</span><span class="params">(Contact* pc)</span> &#123;</span><br><span class="line">	assert(pc);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入要查找人的电话：&gt;&quot;</span>);</span><br><span class="line">	<span class="type">char</span> tele[TELE_MAX] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, tele);</span><br><span class="line">	<span class="type">int</span> index = FindByTele(pc, tele);</span><br><span class="line">	<span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;通讯录里没有此人\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;查找成功\n&quot;</span>);</span><br><span class="line">		ShowOneContact(pc, index);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ModifyContact</span><span class="params">(Contact* pc)</span> &#123;</span><br><span class="line">	assert(pc);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入要修改人的电话：&gt;&quot;</span>);</span><br><span class="line">	<span class="type">char</span> tele[TELE_MAX] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, tele);</span><br><span class="line">	<span class="type">int</span> index = FindByTele(pc, tele);</span><br><span class="line">	<span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;要修改的人不存在\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		ShowOneContact(pc, index);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入名字：&gt;&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, pc-&gt;data[index].name);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入年龄：&gt;&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(pc-&gt;data[index].age));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入性别：&gt;&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, pc-&gt;data[index].sex);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入电话：&gt;&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, pc-&gt;data[index].tele);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入地址：&gt;&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, pc-&gt;data[index].addr);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;修改成功\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SortContact</span><span class="params">(Contact* pc)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pc-&gt;sz; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; pc-&gt;sz - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (pc-&gt;data[j].age &lt; pc-&gt;data[j + <span class="number">1</span>].age) &#123;</span><br><span class="line">				PeoInfo temp = pc-&gt;data[j];</span><br><span class="line">				pc-&gt;data[j] = pc-&gt;data[j + <span class="number">1</span>];</span><br><span class="line">				pc-&gt;data[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ShowContact(pc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>test.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;contact.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;**********************************************\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;********     1.add       2.del        ********\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;********     3.search    4.modify     ********\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;********     5.sort      6.show       ********\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;********     0.exit                   ********\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;**********************************************\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> input = <span class="number">0</span>;</span><br><span class="line">	Contact con = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	InitContact(&amp;con);</span><br><span class="line">	<span class="keyword">do</span> &#123;	</span><br><span class="line">		menu();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请选择：&gt;&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">		<span class="keyword">switch</span> (input) &#123;</span><br><span class="line">			<span class="keyword">case</span> ADD:</span><br><span class="line">				AddContact(&amp;con);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> DEL:</span><br><span class="line">				DeleteContact(&amp;con);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> SEARCH:</span><br><span class="line">				SearchContact(&amp;con);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> MODIFY:</span><br><span class="line">				ModifyContact(&amp;con);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> SORT:</span><br><span class="line">				SortContact(&amp;con);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> SHOW:</span><br><span class="line">				ShowContact(&amp;con);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> EXIT:</span><br><span class="line">				DestroyContact(&amp;con);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;退出通讯录\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;选择错误！\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="第七章、文件操作"><a href="#第七章、文件操作" class="headerlink" title="第七章、文件操作"></a>第七章、文件操作</h1><h2 id="1-文件的概念"><a href="#1-文件的概念" class="headerlink" title="1.文件的概念"></a>1.文件的概念</h2><p>磁盘上的文件是文件。</p>
<p>但是在程序设计中，我们一般谈的文件有两种：<strong>程序文件</strong>、<strong>数据文件</strong>（从文件功能的角度来分类的）。  </p>
<ul>
<li>程序文件</li>
</ul>
<blockquote>
<p>包括源程序文件（后缀为.c）,目标文件（windows环境后缀为.obj）,可执行程序（windows环境后缀为.exe）。  </p>
</blockquote>
<ul>
<li>数据文件</li>
</ul>
<blockquote>
<p>文件的内容不一定是程序，而是程序运行时读写的数据，比如程序运行需要从中读取数据的文件，或者输出内容的文件 。</p>
</blockquote>
<p>本节主要讨论的是数据文件。</p>
<p>一个文件要有一个唯一的文件标识，以便用户识别和引用。</p>
<p>文件名包含3部分：文件路径+文件名主干+文件后缀（ 例如： c:\code\test.txt ）</p>
<p>为了方便起见，文件标识常被称为文件名。  </p>
<h2 id="2-文件的打开和关闭"><a href="#2-文件的打开和关闭" class="headerlink" title="2.文件的打开和关闭"></a>2.文件的打开和关闭</h2><h3 id="2-1-文件指针"><a href="#2-1-文件指针" class="headerlink" title="2.1 文件指针"></a>2.1 文件指针</h3><p>缓冲文件系统中，关键的概念是“<strong>文件类型指针</strong>”，简称“<strong>文件指针</strong>”。</p>
<p>每个被使用的文件都在内存中开辟了一个相应的文件信息区，用来存放文件的相关信息（如文件的名字，文件状态及文件当前的位置等）。这些信息是保存在一个结构体变量中的。该结构体类型是有系统声明的，取名<strong>FILE</strong>.  </p>
<p>例如，VS2013编译环境提供的 stdio.h 头文件中有以下的文件类型申明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">iobuf</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> *_ptr;</span><br><span class="line">	<span class="type">int</span> _cnt;</span><br><span class="line">	<span class="type">char</span> *_base;</span><br><span class="line">	<span class="type">int</span> _flag;</span><br><span class="line">	<span class="type">int</span> _file;</span><br><span class="line">	<span class="type">int</span> _charbuf;</span><br><span class="line">	<span class="type">int</span> _bufsiz;</span><br><span class="line">	<span class="type">char</span> *_tmpfname;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">iobuf</span> <span class="title">FILE</span>;</span></span><br></pre></td></tr></table></figure>

<p>不同的c编译器的FILE类型包含的内容不完全相同，但是大同小异。</p>
<p>每当打开一个文件的时候，系统会根据文件的情况自动创建一个FILE结构的变量，并填充其中的信息，使用者不必关心细节。</p>
<p>一般都是通过一个FILE的指针来维护这个FILE结构的变量，这样使用起来更加方便。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE* pf; <span class="comment">//文件指针变量</span></span><br></pre></td></tr></table></figure>

<p>定义pf是一个指向FILE类型数据的指针变量。可以使pf指向某个文件的文件信息区（是一个结构体变量）。通过该文件信息区中的信息就能够访问该文件。也就是说，<strong>通过文件指针变量能够找到与它关联的文件</strong>。 </p>
<h3 id="2-2-文件的打开和关闭"><a href="#2-2-文件的打开和关闭" class="headerlink" title="2.2 文件的打开和关闭"></a>2.2 文件的打开和关闭</h3><p>文件在读写之前应该先打开文件，在使用结束之后应该关闭文件。</p>
<p>在编写程序的时候，在打开文件的同时，都会返回一个FILE*的指针变量指向该文件，也相当于建立了指针和文件的关系。</p>
<p><strong>ANSIC</strong> 规定使用<strong>fopen函数</strong>来打开文件，<strong>fclose函数</strong>来关闭文件  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开文件</span></span><br><span class="line">FILE * <span class="title function_">fopen</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * filename, <span class="type">const</span> <span class="type">char</span> * mode )</span>;</span><br><span class="line"><span class="comment">//关闭文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fclose</span> <span class="params">( FILE * stream )</span>;</span><br></pre></td></tr></table></figure>

<p><strong>mode</strong>（文件使用方式）:</p>
<table>
<thead>
<tr>
<th align="left">文件使用方式</th>
<th align="left">含义</th>
<th align="left">如果指定文件不存在</th>
</tr>
</thead>
<tbody><tr>
<td align="left">“r”（只读）</td>
<td align="left">为了输入数据，打开一个已经存在的文本文件</td>
<td align="left">出错</td>
</tr>
<tr>
<td align="left">“w”（只写）</td>
<td align="left">为了输出数据，打开一个文本文件</td>
<td align="left">建立一个新的文件</td>
</tr>
<tr>
<td align="left">“a”（追加）</td>
<td align="left">向文本文件尾添加数据</td>
<td align="left">建立一个新的文件</td>
</tr>
<tr>
<td align="left">“rb”（只读）</td>
<td align="left">为了输入数据，打开一个二进制文件</td>
<td align="left">出错</td>
</tr>
<tr>
<td align="left">“wb”（只写）</td>
<td align="left">为了输出数据，打开一个二进制文件</td>
<td align="left">建立一个新的文件</td>
</tr>
<tr>
<td align="left">“ab”（追加）</td>
<td align="left">向一个二进制文件尾添加数据</td>
<td align="left">出错</td>
</tr>
<tr>
<td align="left">“r+”（读写）</td>
<td align="left">为了读和写，打开一个文本文件</td>
<td align="left">出错</td>
</tr>
<tr>
<td align="left">“w+”（读写）</td>
<td align="left">为了读和写，建议一个新的文件</td>
<td align="left">建立一个新的文件</td>
</tr>
<tr>
<td align="left">“a+”（读写）</td>
<td align="left">打开一个文件，在文件尾进行读写</td>
<td align="left">建立一个新的文件</td>
</tr>
<tr>
<td align="left">“rb+”（读写）</td>
<td align="left">为了读和写打开一个二进制文件</td>
<td align="left">出错</td>
</tr>
<tr>
<td align="left">“wb+”（读写）</td>
<td align="left">为了读和写，新建一个新的二进制文件</td>
<td align="left">建立一个新的文件</td>
</tr>
<tr>
<td align="left">“ab+”（读写）</td>
<td align="left">打开一个二进制文件，在文件尾进行读和写</td>
<td align="left">建立一个新的文件</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fopen fclose example */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span>&#123;</span><br><span class="line">	FILE * pFile;</span><br><span class="line">	<span class="comment">//打开文件</span></span><br><span class="line">	pFile = fopen (<span class="string">&quot;myfile.txt&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">	<span class="comment">//文件操作</span></span><br><span class="line">	<span class="keyword">if</span> (pFile!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">fputs</span> (<span class="string">&quot;fopen example&quot;</span>,pFile);</span><br><span class="line">	<span class="comment">//关闭文件</span></span><br><span class="line">		fclose (pFile);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-文件的顺序读写"><a href="#3-文件的顺序读写" class="headerlink" title="3.文件的顺序读写"></a>3.文件的顺序读写</h2><table>
<thead>
<tr>
<th align="center">功能</th>
<th align="center">函数名</th>
<th align="center">适用于</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字符输入函数</td>
<td align="center">fgetc</td>
<td align="center">所有输入流</td>
</tr>
<tr>
<td align="center">字符输出函数</td>
<td align="center">fputc</td>
<td align="center">所有输出流</td>
</tr>
<tr>
<td align="center">文本行输入函数</td>
<td align="center">fgets</td>
<td align="center">所有输入流</td>
</tr>
<tr>
<td align="center">文本行输出函数</td>
<td align="center">fputs</td>
<td align="center">所有输出流</td>
</tr>
<tr>
<td align="center">格式化输入函数</td>
<td align="center">fscanf</td>
<td align="center">所有输入流</td>
</tr>
<tr>
<td align="center">格式化输出函数</td>
<td align="center">fprintf</td>
<td align="center">所有输出流</td>
</tr>
<tr>
<td align="center">二进制输入</td>
<td align="center">fread</td>
<td align="center">文件</td>
</tr>
<tr>
<td align="center">二进制输出</td>
<td align="center">fwrite</td>
<td align="center">文件</td>
</tr>
</tbody></table>
<h2 id="4-文件的随机读写"><a href="#4-文件的随机读写" class="headerlink" title="4.文件的随机读写"></a>4.文件的随机读写</h2><h3 id="4-1-fseek"><a href="#4-1-fseek" class="headerlink" title="4.1 fseek"></a>4.1 fseek</h3><p>根据文件指针的位置和偏移量来定位文件指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fseek</span> <span class="params">( FILE * stream, <span class="type">long</span> <span class="type">int</span> offset, <span class="type">int</span> origin )</span>;</span><br></pre></td></tr></table></figure>

<p>第一个参数<strong>stream</strong>为文件指针</p>
<p>第二个参数<strong>offset</strong>为偏移量，正数表示正向偏移，负数表示负向偏移</p>
<p>第三个参数<strong>origin</strong>设定从文件的哪里开始偏移,可能取值为：<strong>SEEK_CUR</strong>、<strong>SEEK_END</strong> 或 <strong>SEEK_SET</strong></p>
<blockquote>
<p>SEEK_SET： 文件开头</p>
<p>SEEK_CUR： 当前位置</p>
<p>SEEK_END： 文件结尾</p>
<p>其中SEEK_SET,SEEK_CUR和SEEK_END依次为0，1和2。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fseek example */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span>&#123;</span><br><span class="line">	FILE * pFile;</span><br><span class="line">	pFile = fopen ( <span class="string">&quot;example.txt&quot;</span> , <span class="string">&quot;wb&quot;</span> );</span><br><span class="line">	<span class="built_in">fputs</span> ( <span class="string">&quot;This is an apple.&quot;</span> , pFile );</span><br><span class="line">	fseek ( pFile , <span class="number">9</span> , SEEK_SET );</span><br><span class="line">	<span class="built_in">fputs</span> ( <span class="string">&quot; sam&quot;</span> , pFile );</span><br><span class="line">	fclose ( pFile );</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//This is a sample.</span></span><br></pre></td></tr></table></figure>



<h3 id="4-2-ftell"><a href="#4-2-ftell" class="headerlink" title="4.2 ftell"></a>4.2 ftell</h3><p>返回文件指针相对于起始位置的偏移量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">int</span> <span class="title function_">ftell</span> <span class="params">( FILE * stream )</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ftell example */</span></span><br><span class="line"><span class="comment">/* getting size of a file */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span>&#123;</span><br><span class="line">	FILE * pFile;</span><br><span class="line">	<span class="type">long</span> size;</span><br><span class="line">	pFile = fopen (<span class="string">&quot;myfile.txt&quot;</span>,<span class="string">&quot;rb&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (pFile==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        perror (<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		fseek (pFile, <span class="number">0</span>, SEEK_END);</span><br><span class="line">		size=ftell (pFile);</span><br><span class="line">		fclose (pFile);</span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;Size of myfile.txt: %ld bytes.\n&quot;</span>,size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-3-rewind"><a href="#4-3-rewind" class="headerlink" title="4.3 rewind"></a>4.3 rewind</h3><p>让文件指针的位置回到文件的起始位置  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rewind</span> <span class="params">( FILE * stream )</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* rewind example */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	FILE * pFile;</span><br><span class="line">	<span class="type">char</span> buffer [<span class="number">27</span>];</span><br><span class="line">	pFile = fopen (<span class="string">&quot;myfile.txt&quot;</span>,<span class="string">&quot;w+&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> ( n=<span class="string">&#x27;A&#x27;</span> ; n&lt;=<span class="string">&#x27;Z&#x27;</span> ; n++)</span><br><span class="line">		fputc ( n, pFile);</span><br><span class="line">	rewind (pFile);</span><br><span class="line">	fread (buffer,<span class="number">1</span>,<span class="number">26</span>,pFile);</span><br><span class="line">	fclose (pFile);</span><br><span class="line">	buffer[<span class="number">26</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="built_in">puts</span> (buffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-文本文件和二进制文件"><a href="#5-文本文件和二进制文件" class="headerlink" title="5.文本文件和二进制文件"></a>5.文本文件和二进制文件</h2><p>根据数据的组织形式，数据文件被称为<strong>文本文件</strong>或者<strong>二进制文件</strong>。</p>
<p>数据在内存中以二进制的形式存储，如果不加转换的输出到外存，就是二进制文件。</p>
<p>如果要求在外存上以ASCII码的形式存储，则需要在存储前转换。<strong>以ASCII字符的形式存储的文件</strong>就是<strong>文本文件</strong>。</p>
<p><strong>一个数据在内存中是怎么存储的呢？</strong></p>
<blockquote>
<p>字符一律以ASCII形式存储，数值型数据既可以用ASCII形式存储，也可以使用二进制形式存储。</p>
<p>如有整数10000，如果以ASCII码的形式输出到磁盘，则磁盘中占用5个字节（每个字符一个字节），而二进制形式输出，则在磁盘上只占4个字节（VS2013测试）。  </p>
</blockquote>
<h2 id="6-文件读取结束的判定"><a href="#6-文件读取结束的判定" class="headerlink" title="6.文件读取结束的判定"></a>6.文件读取结束的判定</h2><p><strong>被错误使用的feof</strong></p>
<p>牢记：在文件读取过程中，不能用feof函数的返回值直接用来判断文件的是否结束。而是<strong>应用于当文件读取结束的时候，判断是读取失败结束，还是遇到文件尾结束</strong>。</p>
<p>文本文件读取是否结束，判断返回值是否为 EOF （ fgetc ），或者 NULL （ fgets ）</p>
<h2 id="7-文件缓冲区"><a href="#7-文件缓冲区" class="headerlink" title="7.文件缓冲区"></a>7.文件缓冲区</h2><p>ANSIC 标准采用“<strong>缓冲文件系统</strong>”处理的数据文件的，所谓缓冲文件系统是指系统自动地在内存中为程序中每一个正在使用的文件开辟一块“<strong>文件缓冲区</strong>”。从内存向磁盘输出数据会先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘上。如果从磁盘向计算机读入数据，则从磁盘文件中读取数据输入到内存缓冲区（充满缓冲区），然后再从缓冲区逐个地将数据送到程序数据区（程序变量等）。缓冲区的大小根据C编译系统决定的。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* example */</span></span><br><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	FILE*pf = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">	<span class="built_in">fputs</span>(<span class="string">&quot;abcdef&quot;</span>, pf);<span class="comment">//先将代码放在输出缓冲区</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;睡眠10秒-已经写数据了，打开test.txt文件，发现文件没有内容\n&quot;</span>);</span><br><span class="line">	Sleep(<span class="number">10000</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;刷新缓冲区\n&quot;</span>);</span><br><span class="line">	fflush(pf);<span class="comment">//刷新缓冲区时，才将输出缓冲区的数据写到文件（磁盘）</span></span><br><span class="line">	<span class="comment">//注：fflush 在高版本的VS上不能使用了</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;再睡眠10秒-此时，再次打开test.txt文件，文件有内容了\n&quot;</span>);</span><br><span class="line">	Sleep(<span class="number">10000</span>);</span><br><span class="line">	fclose(pf);</span><br><span class="line">	<span class="comment">//注：fclose在关闭文件的时候，也会刷新缓冲区</span></span><br><span class="line">	pf = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为有缓冲区的存在，C语言在操作文件的时候，需要做刷新缓冲区或者在文件操作结束的时候关闭文件。如果不做，可能导致读写文件的问题。</p>
<h1 id="第八章、程序的编译"><a href="#第八章、程序的编译" class="headerlink" title="第八章、程序的编译"></a>第八章、程序的编译</h1><h2 id="1-程序的翻译环境和执行环境"><a href="#1-程序的翻译环境和执行环境" class="headerlink" title="1.程序的翻译环境和执行环境"></a>1.程序的翻译环境和执行环境</h2><p>在ANSI C的任何一种实现中，存在两个不同的环境。</p>
<p>第1种是翻译环境，在这个环境中源代码被转换为可执行的机器指令。</p>
<p>第2种是执行环境，它用于实际执行代码  </p>
<h2 id="2-详解编译-链接"><a href="#2-详解编译-链接" class="headerlink" title="2.详解编译+链接"></a>2.详解编译+链接</h2><h3 id="2-1-翻译环境"><a href="#2-1-翻译环境" class="headerlink" title="2.1 翻译环境"></a>2.1 翻译环境</h3><p>组成一个程序的每个源文件通过编译过程分别转换成目标代码（object code）。</p>
<p>每个目标文件由链接器（linker）捆绑在一起，形成一个单一而完整的可执行程序。（linux后缀**.o**     windows后缀**.obj**）</p>
<p>链接器同时也会引入标准C函数库中任何被该程序所用到的函数，而且它可以搜索程序员个人的程序库，将其需要的函数也链接到程序中。</p>
<p><strong>翻译环境</strong>本身又分为几个阶段：</p>
<ul>
<li><strong>预编译</strong>阶段</li>
</ul>
<blockquote>
<p>gcc  -E test.c -o test.i</p>
<p>文本操作</p>
<p>①头文件的包含#include；</p>
<p>②删除注释</p>
<p>③#define定义符号的替换</p>
</blockquote>
<ul>
<li><strong>编译</strong></li>
</ul>
<blockquote>
<p>gcc -S test.i</p>
<p>-&gt;test.s</p>
<p>把C语言转换成汇编代码</p>
<p>①语法分析</p>
<p>②词法分析</p>
<p>③语义分析</p>
<p>④符号汇总</p>
<p>推荐两本书《编译原理》，《程序员的自我修养》</p>
</blockquote>
<ul>
<li><strong>汇编</strong></li>
</ul>
<blockquote>
<p>gcc -c test.s</p>
<p>-&gt;test.o</p>
<p>把汇编代码转换成二进制的指令</p>
<p>①形成符号表</p>
</blockquote>
<ul>
<li><strong>链接</strong></li>
</ul>
<blockquote>
<p>gcc test.o xxx.o -o test</p>
<p>-&gt;test(可执行文件，如果不自定义的化，默认a.out)</p>
<p>生成可执行程序</p>
<p>①合并段表</p>
<p>②符号表的合并和符号表的重定位</p>
<p><strong>多个目标文件进行链接的时候会通过符号表来查看来自外部的符号是否存在</strong></p>
</blockquote>
<h3 id="2-2-运行环境"><a href="#2-2-运行环境" class="headerlink" title="2.2 运行环境"></a>2.2 运行环境</h3><p>程序执行的过程：</p>
<p>①程序必须载入内存中。在有操作系统的环境中：一般这个由操作系统完成。在独立的环境中，程序的载入必须由手工安排，也可能是通过可执行代码置入只读内存来完成。</p>
<p>②程序的执行便开始。接着便调用main函数。</p>
<p>③开始执行程序代码。这个时候程序将使用一个运行时堆栈（stack），存储函数的局部变量和返回地址。程序同时也可以使用静态（static）内存，存储于静态内存中的变量在程序的整个执行过程一直保留他们的值。</p>
<p>④终止程序。正常终止main函数；也有可能是意外终止。  </p>
<h2 id="3-预处理详解"><a href="#3-预处理详解" class="headerlink" title="3.预处理详解"></a>3.预处理详解</h2><h3 id="3-1-预定义符号"><a href="#3-1-预定义符号" class="headerlink" title="3.1 预定义符号"></a>3.1 预定义符号</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__FILE__ <span class="comment">//进行编译的源文件</span></span><br><span class="line">__LINE__ <span class="comment">//文件当前的行号</span></span><br><span class="line">__DATE__ <span class="comment">//文件被编译的日期</span></span><br><span class="line">__TIME__ <span class="comment">//文件被编译的时间</span></span><br><span class="line">__STDC__ <span class="comment">//如果编译器遵循ANSI C，其值为1，否则未定义</span></span><br></pre></td></tr></table></figure>

<p>这些预定义符号都是语言内置的，可以直接用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* example */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;file:%s line:%d\n&quot;</span>, __FILE__, __LINE__);</span><br></pre></td></tr></table></figure>



<h3 id="3-2-define"><a href="#3-2-define" class="headerlink" title="3.2 #define"></a>3.2 #define</h3><p><strong>#define 定义标识符</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* example */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reg register       <span class="comment">//为 register这个关键字，创建一个简短的名字</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> do_forever for(;;) <span class="comment">//用更形象的符号来替换一种实现</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASE break;case    <span class="comment">//在写case语句的时候自动把 break写上。</span></span></span><br><span class="line"><span class="comment">// 如果定义的 stuff过长，可以分成几行写，除了最后一行外，每行的后面都加一个反斜杠(续行符)。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_PRINT printf(<span class="string">&quot;file:%s\tline:%d\t \</span></span></span><br><span class="line"><span class="string"><span class="meta">						date:%s\ttime:%s\n&quot;</span> ,\</span></span><br><span class="line"><span class="meta">						__FILE__,__LINE__ , \</span></span><br><span class="line"><span class="meta">						__DATE__,__TIME__ )</span></span><br></pre></td></tr></table></figure>

<p>注意：在define定义标识符时，不要在后面加上 <strong>;</strong> </p>
<p><strong>#define 定义宏</strong></p>
<p>#define 机制包括了一个规定，允许把参数替换到文本中，这种实现通常称为宏（macro）或定义宏（define macro）。</p>
<p>宏的申明方式：</p>
<blockquote>
<p>#define name( parament-list ) stuff</p>
<p>其中的 parament-list 是一个由逗号隔开的符号表，它们可能出现在stuff中  </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* example */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) ((x) * (x))</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<blockquote>
<p>参数列表的左括号必须与name紧邻。</p>
<p>如果两者之间有任何空白存在，参数列表就会被解释为stuff的一部分  </p>
<p>用于对数值表达式进行求值的宏定义都应该用加上括号，避免在使用宏时由于参数中的操作符或邻近操作符之间不可预料的相互作用。</p>
<p>约定俗成：把宏名全部大写；函数名不要全部大写  </p>
</blockquote>
<p><strong>#define 替换规则</strong></p>
<p>在程序中扩展#define定义符号和宏时，需要涉及几个步骤。</p>
<blockquote>
<p>①在调用宏时，首先对参数进行检查，看看是否包含任何由#define定义的符号。如果是，它们首先被替换。</p>
<p>②替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被他们的值所替换。</p>
<p>③最后，再次对结果文件进行扫描，看看它是否包含任何由#define定义的符号。如果是，就重复上述处理过程。</p>
</blockquote>
<p>注意：</p>
<blockquote>
<p>①宏参数和#define 定义中可以出现其他#define定义的符号。但是对于宏，不能出现递归。<br>②当预处理器搜索#define定义的符号的时候，字符串常量的内容并不被搜索 。</p>
</blockquote>
<p><strong>#和##</strong>  </p>
<ul>
<li>#的作用</li>
</ul>
<p>①当字符串作为宏参数的时候可以把字符串放在字符串中  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT(FORMAT, VALUE)\</span></span><br><span class="line"><span class="meta">printf(<span class="string">&quot;the value is &quot;</span>FORMAT<span class="string">&quot;\n&quot;</span>, VALUE)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	PRINT(<span class="string">&quot;%d&quot;</span>, <span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②使用 # ，可以把一个宏参数变成对应的字符串  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT(n) printf(<span class="string">&quot;the value of &quot;</span>#n<span class="string">&quot; is %d\n&quot;</span>,n)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    PRINT(a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>##的作用</li>
</ul>
<p>##可以把位于它两边的符号合成一个符号。</p>
<p>它允许宏定义从分离的文本片段创建标识符。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_TO_SUM(num, value) sum##num += value;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> sum5 = <span class="number">10</span>;</span><br><span class="line">	ADD_TO_SUM(<span class="number">5</span>, <span class="number">10</span>);<span class="comment">//作用是：给sum5增加10.</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum5);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>带有副作用的宏参数</strong></p>
<p>当宏参数在宏的定义中出现超过一次的时候，如果参数带有副作用，那么你在使用这个宏的时候就可能出现危险，导致不可预测的后果。副作用就是表达式求值的时候出现的永久性效果。  </p>
<p>x+1;&#x2F;&#x2F;不带副作用<br>x++;&#x2F;&#x2F;带有副作用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//证明 具有副作用的参数所引起的问题 的例子</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) ( (a) &gt; (b) ? (a) : (b) )</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">	<span class="type">int</span> y = <span class="number">8</span>;</span><br><span class="line">	<span class="type">int</span> z = MAX(x++, y++);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;x=%d y=%d z=%d\n&quot;</span>, x, y, z);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//x=6 y=10 z=9</span></span><br></pre></td></tr></table></figure>



<p>3.3 宏和函数的对比</p>
<p>宏通常被应用于执行简单的运算  ，为什么不用函数来执行呢？</p>
<p>原因：</p>
<blockquote>
<p>①用于调用函数和从函数返回的代码可能比实际执行这个小型计算工作所需要的时间更多。</p>
<p><strong>所以宏比函数在程序的规模和速度方面更胜一筹。</strong></p>
<p>②更为重要的是函数的参数必须声明为特定的类型。</p>
<p>所以函数只能在类型合适的表达式上使用。反之这个宏怎可以适用于整形、长整型、浮点型等可以用于&gt;来比较的类型。</p>
<p><strong>宏是类型无关的。</strong>  </p>
</blockquote>
<p>宏有时候可以做函数做不到的事情。比如：宏的参数可以出现类型，但是函数做不到。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC(num, type)\</span></span><br><span class="line"><span class="meta">(type *)malloc(num * sizeof(type))</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">MALLOC(<span class="number">10</span>, <span class="type">int</span>);<span class="comment">//类型作为参数</span></span><br><span class="line"><span class="comment">//预处理器替换之后：</span></span><br><span class="line">(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>

<p><strong>宏的缺点</strong>：当然和函数相比宏也有劣势的地方：</p>
<blockquote>
<p>①每次使用宏的时候，一份宏定义的代码将插入到程序中。除非宏比较短，否则可能大幅度增加程序的长度。</p>
<p>② 宏是没法调试的。  </p>
<p>③宏由于类型无关，也就不够严谨。</p>
<p>④宏可能会带来运算符优先级的问题，导致程容易出现错。  </p>
</blockquote>
<p><strong>宏和函数的对比</strong>：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>#define定义宏</th>
<th>函数</th>
</tr>
</thead>
<tbody><tr>
<td>代码长度</td>
<td>每次使用时，宏代码都会被插入到程序中。除了非常小的宏之外，程序的长度会大幅度增长</td>
<td>函数代码只出现于一个地方；每次使用这个函数时，都调用那个地方的同一份代码</td>
</tr>
<tr>
<td>执行速度</td>
<td>更快</td>
<td>存在函数的调用和返回的额外开销，所以相对慢一些</td>
</tr>
<tr>
<td>操作符优先</td>
<td>宏参数的求值是在所有周围表达式的上下文环境里， 除非加上括号，否则邻近操作符的优先级可能会产生不可预料的后果，所以建议宏在书写的时候多些括 号</td>
<td>函数参数只在函数调用的时候求值一次，它的结果值传递给函数。表达式的求值结果更容易预测</td>
</tr>
<tr>
<td>带有副作用的参数</td>
<td>参数可能被替换到宏体中的多个位置，所以带有副作用的参数求值可能会产生不可预料的结果。</td>
<td>函数参数只在传参的时候求值一 次，结果更容易控制。</td>
</tr>
<tr>
<td>参数类型</td>
<td>宏的参数与类型无关，只要对参数的操作是合法的， 它就可以使用于任何参数类型。</td>
<td>函数的参数是与类型有关的，如果参数的类型不同，就需要不同的函数，即使他们执行的任务是不同的。</td>
</tr>
<tr>
<td>调试</td>
<td>宏是不方便调试的</td>
<td>函数是可以逐语句调试的</td>
</tr>
<tr>
<td>递归</td>
<td>宏是不能递归的</td>
<td>函数是可以递归的</td>
</tr>
</tbody></table>
<h3 id="3-3-undef"><a href="#3-3-undef" class="headerlink" title="3.3 #undef"></a>3.3 #undef</h3><p>这条指令用于移除一个宏定义  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">undef</span> NAME</span></span><br><span class="line"><span class="comment">//如果现存的一个名字需要被重新定义，那么它的旧名字首先要被移除。</span></span><br></pre></td></tr></table></figure>



<h3 id="3-4-命令行定义"><a href="#3-4-命令行定义" class="headerlink" title="3.4 命令行定义"></a>3.4 命令行定义</h3><p>许多C 的编译器提供了一种能力，允许在命令行中定义符号。用于启动编译过程。</p>
<p>例如：当我们根据同一个源文件要编译出不同的一个程序的不同版本的时候，这个特性有点用处。（假定某个程序中声明了一个某个长度的数组，如果机器内存有限，我们需要一个很小的数组，但是另外一个机器内存大写，我们需要一个数组能够大写。）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="built_in">array</span> [ARRAY_SIZE];</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; ARRAY_SIZE; i ++)&#123;</span><br><span class="line">		<span class="built_in">array</span>[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; ARRAY_SIZE; i ++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span> ,<span class="built_in">array</span>[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span> );</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译指令：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux 环境演示</span></span><br><span class="line">gcc -D ARRAY_SIZE=<span class="number">10</span> programe.c</span><br></pre></td></tr></table></figure>



<h3 id="3-5-条件编译"><a href="#3-5-条件编译" class="headerlink" title="3.5 条件编译"></a>3.5 条件编译</h3><p>在编译一个程序的时候我们如果要将一条语句（一组语句）编译或者放弃是很方便的。因为我们有条件编译指令。  </p>
<p>比如：</p>
<p>调试性的代码，删除可惜，保留又碍事，所以我们可以选择性的编译。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DEBUG__</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">		arr[i] = i;</span><br><span class="line">    	<span class="meta">#<span class="keyword">ifdef</span> __DEBUG__</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, arr[i]);<span class="comment">//为了观察数组是否赋值成功。</span></span><br><span class="line">		<span class="meta">#<span class="keyword">endif</span> <span class="comment">//__DEBUG__</span></span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>常见的条件编译指令</strong>  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 常量表达式</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//常量表达式由预处理器求值。</span></span><br><span class="line">如：</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DEBUG__ 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __DEBUG__</span></span><br><span class="line">	<span class="comment">//..</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="number">2.</span>多个分支的条件编译</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 常量表达式</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> 常量表达式</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span>判断是否被定义</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(symbol)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> symbol</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(symbol)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> symbol</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>嵌套指令</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(OS_UNIX)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">ifdef</span> OPTION1</span></span><br><span class="line">		unix_version_option1();</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">ifdef</span> OPTION2</span></span><br><span class="line">		unix_version_option2();</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(OS_MSDOS)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">ifdef</span> OPTION2</span></span><br><span class="line">		msdos_version_option2();</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h3 id="3-6-文件包含"><a href="#3-6-文件包含" class="headerlink" title="3.6 文件包含"></a>3.6 文件包含</h3><p>#include 指令可以使另外一个文件被编译。预处理器会先删除这条指令，并用包含文件的内容替换。  </p>
<ul>
<li>本地文件包含</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;filename&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>先在源文件所在目录下查找，如果该头文件未找到，编译器就像查找库函数头文件一样在标准位置查找头文件。如果找不到就提示编译错误。  </p>
<ul>
<li>库文件包含</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;filename.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>查找头文件直接去标准路径下去查找，如果找不到就提示编译错误。 所以对于库文件也可以使用 “ ” 的形式包含（但是这样效率低，也不容易区分本地文件和库文件） 。</p>
<ul>
<li>嵌套文件包含</li>
</ul>
<p>如果出现了嵌套文件包含，就容易造成文件内容的重复，为了解决这个问题，可以使用条件编译。</p>
<p>在每个头文件的开头写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __TEST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TEST_H__</span></span><br><span class="line"><span class="comment">//头文件的内容</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//__TEST_H__</span></span></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br></pre></td></tr></table></figure>



<h2 id="4-其他预处理指令"><a href="#4-其他预处理指令" class="headerlink" title="4.其他预处理指令"></a>4.其他预处理指令</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">error</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">line</span></span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//内容较多，不做具体介绍，有兴趣可以自己去了解</span></span><br></pre></td></tr></table></figure>



<h2 id="5-小练习"><a href="#5-小练习" class="headerlink" title="5.小练习"></a>5.小练习</h2><ul>
<li>写一个宏，可以将一个整数的二进制位的奇数位和偶数位交换。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> SWAP_ODD_EVEN(NUM) ((((NUM) &amp; (0X55555555)) <span class="string">&lt;&lt; 1) | (((NUM) &amp; (0XAAAAAAAA)) &gt;</span>&gt; 1))</span></span><br></pre></td></tr></table></figure>



<ul>
<li>写一个宏，计算结构体中某变量相对于首地址的偏移，并给出说明</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  STRUCT_OFFSET(id, element)  ((unsigned long)&amp;((( struct id*)0)-&gt;element))</span></span><br></pre></td></tr></table></figure>

<p>假设结构体的首地址是0开始，把他转换成结构体指针类型，再用 -&gt; 获取他的成员，前面加 &amp; 就是为了获取这个成员的地址。，最后再强制转换成unsigned long, 这样就得到了偏移量。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://pudding1108.github.io">Pudding</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://pudding1108.github.io/2025/06/01/C%E8%AF%AD%E8%A8%80%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89%E7%AC%94%E8%AE%B0/">https://pudding1108.github.io/2025/06/01/C%E8%AF%AD%E8%A8%80%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://pudding1108.github.io" target="_blank">普通博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C</a></div><div class="post-share"><div class="social-share" data-image="/image/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/06/01/C%E8%AF%AD%E8%A8%80%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89%E7%AC%94%E8%AE%B0/" title="C语言（基础）笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">C语言（基础）笔记</div></div><div class="info-2"><div class="info-item-1">第一章、初识C语言先快速了解一下C语言的大概内容，点到为止，以后会具体介绍。 1.什么是C语言C语言是一门面向过程的、抽象化的通用程序设计语言，广泛应用于底层开发。 2.第一个C语言123456#include&lt;stdio.h&gt;int main()&#123;    printf(&quot;Hello,world!\n&quot;);    return 0;&#125;//Ctrl+F5  VS运行代码快捷键    3.数据类型123456789char          //字符数据类型short         //短整型int           //整型long          //长整型long long     //更长的整形float         //单精度浮点数double        //双精度浮点数//C语言中没有字符串类型//在不同的系统上，这些类型占据的字节长度不同，具体可以用sizeof测试    4.常量与变量常量—不变的量 变量—可变的量 4.1 定义变量的方法123int age = 150;float weight =...</div></div></div></a><a class="pagination-related" href="/2025/06/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89%E7%AC%94%E8%AE%B0/" title="数据结构（基础）笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">数据结构（基础）笔记</div></div><div class="info-2"><div class="info-item-1">第一章：绪论1.基本概念数据是信息的载体是对客观事物的符号表示，在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称。 数据元素是数据的基本单位，一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。 数据对象是性质相同的数据元素的集合，是数据的一个子集。 数据结构是相互之间存在一种或多种特定关系的数据元素的集合。（没有官方统一定义） 数据结构三要素：逻辑结构；数据的运算；物理结构（存储结构） 数据类型是一个值的集合和定义在此集合上的一组操作的总称。  原子类型。其值不可再分的数据类型。...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/06/01/C%E8%AF%AD%E8%A8%80%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89%E7%AC%94%E8%AE%B0/" title="C语言（基础）笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-01</div><div class="info-item-2">C语言（基础）笔记</div></div><div class="info-2"><div class="info-item-1">第一章、初识C语言先快速了解一下C语言的大概内容，点到为止，以后会具体介绍。 1.什么是C语言C语言是一门面向过程的、抽象化的通用程序设计语言，广泛应用于底层开发。 2.第一个C语言123456#include&lt;stdio.h&gt;int main()&#123;    printf(&quot;Hello,world!\n&quot;);    return 0;&#125;//Ctrl+F5  VS运行代码快捷键    3.数据类型123456789char          //字符数据类型short         //短整型int           //整型long          //长整型long long     //更长的整形float         //单精度浮点数double        //双精度浮点数//C语言中没有字符串类型//在不同的系统上，这些类型占据的字节长度不同，具体可以用sizeof测试    4.常量与变量常量—不变的量 变量—可变的量 4.1 定义变量的方法123int age = 150;float weight =...</div></div></div></a><a class="pagination-related" href="/2025/06/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89%E7%AC%94%E8%AE%B0/" title="数据结构（基础）笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-01</div><div class="info-item-2">数据结构（基础）笔记</div></div><div class="info-2"><div class="info-item-1">第一章：绪论1.基本概念数据是信息的载体是对客观事物的符号表示，在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称。 数据元素是数据的基本单位，一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。 数据对象是性质相同的数据元素的集合，是数据的一个子集。 数据结构是相互之间存在一种或多种特定关系的数据元素的集合。（没有官方统一定义） 数据结构三要素：逻辑结构；数据的运算；物理结构（存储结构） 数据类型是一个值的集合和定义在此集合上的一组操作的总称。  原子类型。其值不可再分的数据类型。...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/image/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Pudding</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Pudding1108" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:epiphany1108@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%E3%80%81%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">1.</span> <span class="toc-text">第一章、数据的存储</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%95%B4%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">1.1.</span> <span class="toc-text">1.整型在内存中的存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E5%92%8C%E8%A1%A5%E7%A0%81"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 原码、反码和补码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%A4%A7%E7%AB%AF%E5%92%8C%E5%B0%8F%E7%AB%AF"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 大端和小端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%B5%AE%E7%82%B9%E5%9E%8B%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">1.2.</span> <span class="toc-text">2.浮点型在内存中的存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%B5%AE%E7%82%B9%E6%95%B0%E5%AD%98%E5%82%A8%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 浮点数存储的例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%B5%AE%E7%82%B9%E6%95%B0%E5%AD%98%E5%82%A8%E8%A7%84%E5%88%99"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 浮点数存储规则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%81%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%9B%E9%98%B6"><span class="toc-number">2.</span> <span class="toc-text">第二章、指针的进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88"><span class="toc-number">2.1.</span> <span class="toc-text">1.字符指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.</span> <span class="toc-text">2.指针数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88"><span class="toc-number">2.3.</span> <span class="toc-text">3.数组指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%AE%9A%E4%B9%89"><span class="toc-number">2.3.1.</span> <span class="toc-text">3.1 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E2%80%9C%E6%95%B0%E7%BB%84%E5%90%8D%E2%80%9D-vs-%E2%80%9C-%E6%95%B0%E7%BB%84%E5%90%8D%E2%80%9D"><span class="toc-number">2.3.2.</span> <span class="toc-text">3.2 “数组名” vs “&amp;数组名”</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">2.4.</span> <span class="toc-text">4.函数指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84"><span class="toc-number">2.5.</span> <span class="toc-text">5.函数指针数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">2.6.</span> <span class="toc-text">6.指向函数指针数组的指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">2.7.</span> <span class="toc-text">7.回调函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E7%AC%94%E8%AF%95%E9%A2%98"><span class="toc-number">2.8.</span> <span class="toc-text">8.指针和数组的笔试题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%8C%87%E9%92%88%E7%AC%94%E8%AF%95%E9%A2%98"><span class="toc-number">2.9.</span> <span class="toc-text">9.指针笔试题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E9%99%84%E5%BD%95%EF%BC%88qsort%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="toc-number">2.10.</span> <span class="toc-text">10.附录（qsort的使用）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%86%85%E5%AD%98%E5%87%BD%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">第三章、字符串+内存函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.1.</span> <span class="toc-text">1.函数介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-strlen"><span class="toc-number">3.1.1.</span> <span class="toc-text">1.1 strlen</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-strcpy"><span class="toc-number">3.1.2.</span> <span class="toc-text">1.2 strcpy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-strcat"><span class="toc-number">3.1.3.</span> <span class="toc-text">1.3 strcat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-strcmp"><span class="toc-number">3.1.4.</span> <span class="toc-text">1.4 strcmp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-strncpy"><span class="toc-number">3.1.5.</span> <span class="toc-text">1.5 strncpy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-strncat"><span class="toc-number">3.1.6.</span> <span class="toc-text">1.6 strncat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-strncmp"><span class="toc-number">3.1.7.</span> <span class="toc-text">1.7 strncmp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-strstr"><span class="toc-number">3.1.8.</span> <span class="toc-text">1.8 strstr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-strtok"><span class="toc-number">3.1.9.</span> <span class="toc-text">1.9 strtok</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-10-strerror"><span class="toc-number">3.1.10.</span> <span class="toc-text">1.10 strerror</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-11-memcpy"><span class="toc-number">3.1.11.</span> <span class="toc-text">1.11 memcpy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-12-memmove"><span class="toc-number">3.1.12.</span> <span class="toc-text">1.12 memmove</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-13-memcmp"><span class="toc-number">3.1.13.</span> <span class="toc-text">1.13 memcmp</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.</span> <span class="toc-text">2.函数的模拟实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0strlen"><span class="toc-number">3.2.1.</span> <span class="toc-text">2.1 模拟实现strlen</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0strcpy"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.2 模拟实现strcpy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0strcat"><span class="toc-number">3.2.3.</span> <span class="toc-text">2.3 模拟实现strcat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0strstr"><span class="toc-number">3.2.4.</span> <span class="toc-text">2.4 模拟实现strstr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0strcmp"><span class="toc-number">3.2.5.</span> <span class="toc-text">2.5 模拟实现strcmp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0memcpy"><span class="toc-number">3.2.6.</span> <span class="toc-text">2.6 模拟实现memcpy</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3"><span class="toc-number">4.</span> <span class="toc-text">第四章、自定义类型详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">4.1.</span> <span class="toc-text">1.结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%BB%93%E6%9E%84%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">4.1.1.</span> <span class="toc-text">1.1 结构的声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E7%BB%93%E6%9E%84%E7%9A%84%E8%87%AA%E5%BC%95%E7%94%A8"><span class="toc-number">4.1.2.</span> <span class="toc-text">1.2  结构的自引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.1.3.</span> <span class="toc-text">1.3 结构体变量的定义与初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span class="toc-number">4.1.4.</span> <span class="toc-text">1.4 结构体内存对齐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E5%AF%B9%E9%BD%90%E6%95%B0"><span class="toc-number">4.1.5.</span> <span class="toc-text">1.5 修改默认对齐数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E7%BB%93%E6%9E%84%E4%BD%93%E4%BC%A0%E5%8F%82"><span class="toc-number">4.1.6.</span> <span class="toc-text">1.6 结构体传参</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BD%8D%E6%AE%B5"><span class="toc-number">4.2.</span> <span class="toc-text">2.位段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%8D%E6%AE%B5"><span class="toc-number">4.2.1.</span> <span class="toc-text">2.1 什么是位段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E4%BD%8D%E6%AE%B5%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">4.2.2.</span> <span class="toc-text">2.2 位段的内存分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E4%BD%8D%E6%AE%B5%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0%E9%97%AE%E9%A2%98"><span class="toc-number">4.2.3.</span> <span class="toc-text">2.3 位段的跨平台问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%9E%9A%E4%B8%BE"><span class="toc-number">4.3.</span> <span class="toc-text">3.枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">4.3.1.</span> <span class="toc-text">3.1 枚举类型的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%9E%9A%E4%B8%BE%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">4.3.2.</span> <span class="toc-text">3.2 枚举的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%9E%9A%E4%B8%BE%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">4.3.3.</span> <span class="toc-text">3.3 枚举的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%81%94%E5%90%88%EF%BC%88%E5%85%B1%E7%94%A8%E4%BD%93%EF%BC%89"><span class="toc-number">4.4.</span> <span class="toc-text">4.联合（共用体）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">4.4.1.</span> <span class="toc-text">4.1 联合类型的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E8%81%94%E5%90%88%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">4.4.2.</span> <span class="toc-text">4.2 联合的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E8%81%94%E5%90%88%E5%A4%A7%E5%B0%8F%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">4.4.3.</span> <span class="toc-text">4.3 联合大小的计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">4.4.4.</span> <span class="toc-text">4.4 面试题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">第五章、动态内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="toc-number">5.1.</span> <span class="toc-text">1.动态内存分配的必要性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.2.</span> <span class="toc-text">2.动态内存函数的介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-malloc-%E5%92%8C-free"><span class="toc-number">5.2.1.</span> <span class="toc-text">2.1 malloc 和 free</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-calloc"><span class="toc-number">5.2.2.</span> <span class="toc-text">2.2 calloc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-realloc"><span class="toc-number">5.2.3.</span> <span class="toc-text">2.3 realloc</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E9%94%99%E8%AF%AF"><span class="toc-number">5.3.</span> <span class="toc-text">3.常见的动态内存错误</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%AF%B9NULL%E6%8C%87%E9%92%88%E7%9A%84%E8%A7%A3%E5%BC%95%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">5.3.1.</span> <span class="toc-text">3.1 对NULL指针的解引用操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%AF%B9%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E7%A9%BA%E9%97%B4%E7%9A%84%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE"><span class="toc-number">5.3.2.</span> <span class="toc-text">3.2 对动态开辟空间的越界访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%AF%B9%E9%9D%9E%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8free%E9%87%8A%E6%94%BE"><span class="toc-number">5.3.3.</span> <span class="toc-text">3.3 对非动态开辟内存使用free释放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E4%BD%BF%E7%94%A8free%E9%87%8A%E6%94%BE%E4%B8%80%E5%9D%97%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86"><span class="toc-number">5.3.4.</span> <span class="toc-text">3.4 使用free释放一块动态开辟内存的一部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%AF%B9%E5%90%8C%E4%B8%80%E5%9D%97%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%A4%9A%E6%AC%A1%E9%87%8A%E6%94%BE"><span class="toc-number">5.3.5.</span> <span class="toc-text">3.5 对同一块动态内存多次释放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E5%8A%A8%E6%80%81%E5%BC%80%E8%BE%9F-%E5%86%85%E5%AD%98%E5%BF%98%E8%AE%B0%E9%87%8A%E6%94%BE%EF%BC%88%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%89"><span class="toc-number">5.3.6.</span> <span class="toc-text">3.6 动态开辟 内存忘记释放（内存泄漏）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%BB%8F%E5%85%B8%E7%9A%84%E7%AC%94%E8%AF%95%E9%A2%98"><span class="toc-number">5.4.</span> <span class="toc-text">4.经典的笔试题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-C-C-%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%BC%80%E8%BE%9F"><span class="toc-number">5.5.</span> <span class="toc-text">5.C&#x2F;C++程序的内存开辟</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84"><span class="toc-number">5.6.</span> <span class="toc-text">6.柔性数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">5.6.1.</span> <span class="toc-text">6.1 柔性数组的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">5.6.2.</span> <span class="toc-text">6.2 柔性数组的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">5.6.3.</span> <span class="toc-text">6.3 柔性数组的优势</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E5%B0%8F%E7%BB%83%E4%B9%A0%EF%BC%9A%E9%80%9A%E8%AE%AF%E5%BD%95"><span class="toc-number">6.</span> <span class="toc-text">第六章、小练习：通讯录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%8B%E7%BB%8D"><span class="toc-number">6.1.</span> <span class="toc-text">一、介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-number">6.2.</span> <span class="toc-text">二、完整代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">7.</span> <span class="toc-text">第七章、文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%96%87%E4%BB%B6%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">7.1.</span> <span class="toc-text">1.文件的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%93%E5%BC%80%E5%92%8C%E5%85%B3%E9%97%AD"><span class="toc-number">7.2.</span> <span class="toc-text">2.文件的打开和关闭</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88"><span class="toc-number">7.2.1.</span> <span class="toc-text">2.1 文件指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%93%E5%BC%80%E5%92%8C%E5%85%B3%E9%97%AD"><span class="toc-number">7.2.2.</span> <span class="toc-text">2.2 文件的打开和关闭</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%96%87%E4%BB%B6%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%AF%BB%E5%86%99"><span class="toc-number">7.3.</span> <span class="toc-text">3.文件的顺序读写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%96%87%E4%BB%B6%E7%9A%84%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%86%99"><span class="toc-number">7.4.</span> <span class="toc-text">4.文件的随机读写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-fseek"><span class="toc-number">7.4.1.</span> <span class="toc-text">4.1 fseek</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-ftell"><span class="toc-number">7.4.2.</span> <span class="toc-text">4.2 ftell</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-rewind"><span class="toc-number">7.4.3.</span> <span class="toc-text">4.3 rewind</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-number">7.5.</span> <span class="toc-text">5.文本文件和二进制文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E7%BB%93%E6%9D%9F%E7%9A%84%E5%88%A4%E5%AE%9A"><span class="toc-number">7.6.</span> <span class="toc-text">6.文件读取结束的判定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%96%87%E4%BB%B6%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">7.7.</span> <span class="toc-text">7.文件缓冲区</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0%E3%80%81%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91"><span class="toc-number">8.</span> <span class="toc-text">第八章、程序的编译</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BF%BB%E8%AF%91%E7%8E%AF%E5%A2%83%E5%92%8C%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="toc-number">8.1.</span> <span class="toc-text">1.程序的翻译环境和执行环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%AF%A6%E8%A7%A3%E7%BC%96%E8%AF%91-%E9%93%BE%E6%8E%A5"><span class="toc-number">8.2.</span> <span class="toc-text">2.详解编译+链接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%BF%BB%E8%AF%91%E7%8E%AF%E5%A2%83"><span class="toc-number">8.2.1.</span> <span class="toc-text">2.1 翻译环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="toc-number">8.2.2.</span> <span class="toc-text">2.2 运行环境</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%A2%84%E5%A4%84%E7%90%86%E8%AF%A6%E8%A7%A3"><span class="toc-number">8.3.</span> <span class="toc-text">3.预处理详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E9%A2%84%E5%AE%9A%E4%B9%89%E7%AC%A6%E5%8F%B7"><span class="toc-number">8.3.1.</span> <span class="toc-text">3.1 预定义符号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-define"><span class="toc-number">8.3.2.</span> <span class="toc-text">3.2 #define</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-undef"><span class="toc-number">8.3.3.</span> <span class="toc-text">3.3 #undef</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9A%E4%B9%89"><span class="toc-number">8.3.4.</span> <span class="toc-text">3.4 命令行定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91"><span class="toc-number">8.3.5.</span> <span class="toc-text">3.5 条件编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB"><span class="toc-number">8.3.6.</span> <span class="toc-text">3.6 文件包含</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%85%B6%E4%BB%96%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4"><span class="toc-number">8.4.</span> <span class="toc-text">4.其他预处理指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%B0%8F%E7%BB%83%E4%B9%A0"><span class="toc-number">8.5.</span> <span class="toc-text">5.小练习</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89%E7%AC%94%E8%AE%B0/" title="数据结构（基础）笔记">数据结构（基础）笔记</a><time datetime="2025-06-01T04:10:00.000Z" title="发表于 2025-06-01 12:10:00">2025-06-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/01/C%E8%AF%AD%E8%A8%80%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89%E7%AC%94%E8%AE%B0/" title="C语言（进阶）笔记">C语言（进阶）笔记</a><time datetime="2025-06-01T04:05:00.000Z" title="发表于 2025-06-01 12:05:00">2025-06-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/01/C%E8%AF%AD%E8%A8%80%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89%E7%AC%94%E8%AE%B0/" title="C语言（基础）笔记">C语言（基础）笔记</a><time datetime="2025-06-01T04:00:00.000Z" title="发表于 2025-06-01 12:00:00">2025-06-01</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/image/background.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2025 By Pudding</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>