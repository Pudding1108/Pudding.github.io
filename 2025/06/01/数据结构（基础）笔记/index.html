<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构（基础）笔记 | 普通博客</title><meta name="author" content="Pudding"><meta name="copyright" content="Pudding"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第一章：绪论1.基本概念数据是信息的载体是对客观事物的符号表示，在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称。 数据元素是数据的基本单位，一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。 数据对象是性质相同的数据元素的集合，是数据的一个子集。 数据结构是相互之间存在一种或多种特定关系的数据元素的集合。（没有官方统一定义） 数据结构三要素：逻辑结构；">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构（基础）笔记">
<meta property="og:url" content="https://pudding1108.github.io/2025/06/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="普通博客">
<meta property="og:description" content="第一章：绪论1.基本概念数据是信息的载体是对客观事物的符号表示，在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称。 数据元素是数据的基本单位，一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。 数据对象是性质相同的数据元素的集合，是数据的一个子集。 数据结构是相互之间存在一种或多种特定关系的数据元素的集合。（没有官方统一定义） 数据结构三要素：逻辑结构；">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pudding1108.github.io/image/avatar.jpg">
<meta property="article:published_time" content="2025-06-01T04:10:00.000Z">
<meta property="article:modified_time" content="2025-05-26T11:43:10.192Z">
<meta property="article:author" content="Pudding">
<meta property="article:tag" content="C">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pudding1108.github.io/image/avatar.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "数据结构（基础）笔记",
  "url": "https://pudding1108.github.io/2025/06/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89%E7%AC%94%E8%AE%B0/",
  "image": "https://pudding1108.github.io/image/avatar.jpg",
  "datePublished": "2025-06-01T04:10:00.000Z",
  "dateModified": "2025-05-26T11:43:10.192Z",
  "author": [
    {
      "@type": "Person",
      "name": "Pudding",
      "url": "https://pudding1108.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/image/favicon.png"><link rel="canonical" href="https://pudding1108.github.io/2025/06/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构（基础）笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/image/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/image/background.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">普通博客</span></a><a class="nav-page-title" href="/"><span class="site-name">数据结构（基础）笔记</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">数据结构（基础）笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-01T04:10:00.000Z" title="发表于 2025-06-01 12:10:00">2025-06-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-26T11:43:10.192Z" title="更新于 2025-05-26 19:43:10">2025-05-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">30.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>111分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="第一章：绪论"><a href="#第一章：绪论" class="headerlink" title="第一章：绪论"></a>第一章：绪论</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><p><strong>数据</strong>是信息的载体是对客观事物的符号表示，在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称。</p>
<p><strong>数据元素</strong>是数据的基本单位，一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。</p>
<p><strong>数据对象</strong>是性质相同的数据元素的集合，是数据的一个子集。</p>
<p><strong>数据结构</strong>是相互之间存在一种或多种特定关系的数据元素的集合。（没有官方统一定义）</p>
<p>数据结构三要素：逻辑结构；数据的运算；物理结构（存储结构）</p>
<p><strong>数据类型</strong>是一个值的集合和定义在此集合上的一组操作的总称。</p>
<ol>
<li>原子类型。其值不可再分的数据类型。 </li>
<li>结构类型。其值可以再分解为若干成分（分量）的数据类型。</li>
</ol>
<p><strong>抽象数据类型</strong>描述了数据的逻辑结构和抽象运算，通常用【数据对象、数据关系、基本操作集】这样的三元组来表示，从而构成一个完整的数据结构定义</p>
<p><strong>算法</strong>是对特定问题求解步骤的一种描述。</p>
<p><strong>算法的特性</strong>：</p>
<p>①<strong>有穷性</strong>。一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。</p>
<p>②<strong>确定性</strong>。算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。</p>
<p>③<strong>可行性</strong>。算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。 </p>
<p>④<strong>输入</strong>。一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。 </p>
<p>⑤<strong>输出</strong>。一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。</p>
<p><strong>“好“算法的特质</strong>：</p>
<p>①<strong>正确性</strong>。算法应能够正确地解决求解问题。</p>
<p>②<strong>可读性</strong>。算法应具有良好的可读性，以帮助人们理解。</p>
<p>③<strong>健壮性</strong>。输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。</p>
<p>④<strong>高效率与低存储量需求</strong>。</p>
<h2 id="2-算法的时间复杂度"><a href="#2-算法的时间复杂度" class="headerlink" title="2.算法的时间复杂度"></a>2.算法的<strong>时间复杂度</strong></h2><p>定义：在计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。一个算法执行所耗费的时间，从理论上说，是不能算出来的，只有你把你的程序放在机器上跑起来，才能知道。但是我们需要每个算法都上机测试吗？是可以都上机测试，但是这很麻烦，所以才有了时间复杂度这个分析方式。一个算法所花费的时间与其中语句的执行次数成正比例，<strong>算法中的基本操作的执行次数，为算法的时间复杂度</strong>。</p>
<h2 id="3-算法的空间复杂度"><a href="#3-算法的空间复杂度" class="headerlink" title="3.算法的空间复杂度"></a>3.算法的<strong>空间复杂度</strong></h2><p>定义：空间复杂度是对一个算法在运行过程中<strong>临时占用存储空间大小的量度</strong> 。空间复杂度不是程序占用了多少bytes的空间，因为这个也没太大意义，所以空间复杂度算的是变量的个数。空间复杂度计算规则基本跟实践复杂度类似，也使用<strong>大O渐进表示法</strong>。</p>
<h1 id="第二章：线性表"><a href="#第二章：线性表" class="headerlink" title="第二章：线性表"></a>第二章：线性表</h1><h2 id="1-线性表"><a href="#1-线性表" class="headerlink" title="1.线性表"></a>1.线性表</h2><h3 id="1-1-线性表的定义"><a href="#1-1-线性表的定义" class="headerlink" title="1.1 线性表的定义"></a>1.1 线性表的定义</h3><p>线性表—具有<strong>相同数据类型</strong>的n（n≥0）个<strong>数据元素</strong>的<strong>有限序列</strong>，其中n为表长，n为0时线性表是一个空表。</p>
<h3 id="1-2-基本操作"><a href="#1-2-基本操作" class="headerlink" title="1.2 基本操作"></a>1.2 基本操作</h3><h4 id="1-2-1-InitList-L"><a href="#1-2-1-InitList-L" class="headerlink" title="1.2.1 InitList(&amp;L)"></a>1.2.1 InitList(&amp;L)</h4><p>初始化表。构造一个空的线性表L，分配内存空间。 </p>
<h4 id="1-2-2-DestroyList-L"><a href="#1-2-2-DestroyList-L" class="headerlink" title="1.2.2 DestroyList(&amp;L)"></a>1.2.2 DestroyList(&amp;L)</h4><p>销毁操作。销毁线性表，并释放线性表L所占用的内存空间。</p>
<h4 id="1-2-3-ListInsert-L-i-e"><a href="#1-2-3-ListInsert-L-i-e" class="headerlink" title="1.2.3 ListInsert(&amp;L,i,e)"></a>1.2.3 ListInsert(&amp;L,i,e)</h4><p>插入操作。在表L中的第i个位置上插入指定元素e。 </p>
<h4 id="1-2-4-ListDelete-L-i-e"><a href="#1-2-4-ListDelete-L-i-e" class="headerlink" title="1.2.4 ListDelete(&amp;L,i,&amp;e)"></a>1.2.4 ListDelete(&amp;L,i,&amp;e)</h4><p>删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。</p>
<h4 id="1-2-5-LocateElem-L-e"><a href="#1-2-5-LocateElem-L-e" class="headerlink" title="1.2.5 LocateElem(L,e)"></a>1.2.5 LocateElem(L,e)</h4><p>按值查找操作。在表L中查找具有给定关键字值的元素。 </p>
<h4 id="1-2-6-GetElem-L-i"><a href="#1-2-6-GetElem-L-i" class="headerlink" title="1.2.6 GetElem(L,i)"></a>1.2.6 GetElem(L,i)</h4><p>按位查找操作。获取表L中第i个位置的元素的值。</p>
<h4 id="1-2-7-其他常用操作"><a href="#1-2-7-其他常用操作" class="headerlink" title="1.2.7 其他常用操作"></a>1.2.7 其他常用操作</h4><p>Length(L)：求表长。返回线性表L的长度，即L中数据元素的个数。 </p>
<p>PrintList(L)：输出操作。按前后顺序输出线性表L的所有元素值。 </p>
<p>Empty(L)：判空操作。若L为空表，则返回true，否则返回false。<br>从无到有 从有到无</p>
<p>Tips： </p>
<p>①对数据的操作（记忆思路）——创销、增删改查 </p>
<p>②C语言函数的定义—— &lt;返回值类型&gt; 函数名(&lt;参数1类型&gt;参数1，&lt;参数2类型&gt;参数2，……) </p>
<p>③实际开发中，可根据实际需求定义其他的基本操作</p>
<p>④函数名和参数的形式、命名都可改变（Reference：严蔚敏版《数据结构》）</p>
<p>⑤什么时候要传入引用“&amp;”——对参数的修改结果需要“带回来”</p>
<h2 id="2-顺序表"><a href="#2-顺序表" class="headerlink" title="2.顺序表"></a>2.顺序表</h2><h3 id="2-1-顺序表的定义"><a href="#2-1-顺序表的定义" class="headerlink" title="2.1 顺序表的定义"></a>2.1 顺序表的定义</h3><p>用<strong>顺序存储</strong>的方式实现<strong>线性表</strong>。</p>
<p>顺序存储—把逻辑上相邻的元素存储在物理 位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。</p>
<h3 id="2-2-顺序表的实现"><a href="#2-2-顺序表的实现" class="headerlink" title="2.2 顺序表的实现"></a>2.2 顺序表的实现</h3><p>静态分配   &amp;&amp;  动态分配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态分配</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data[<span class="number">10</span>];  <span class="comment">//用静态的数组存放数据元素</span></span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SqList &amp;L)</span>&#123;  <span class="comment">//初始化一个顺序表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        L.data[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L.length=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态分配</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line">    <span class="type">int</span> MaxSize;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SeqList;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IncreaseSize</span><span class="params">(SeqList &amp;L,<span class="type">int</span> len)</span>&#123;  <span class="comment">//增加动态数组的长度</span></span><br><span class="line">    <span class="type">int</span> *p = L.data;</span><br><span class="line">    <span class="comment">//动态申请内存空间</span></span><br><span class="line">    <span class="comment">//malloc函数返回一个指针，需要强制转型为你定义的数据元素类型指针</span></span><br><span class="line">    <span class="comment">//malloc函数头文件&lt;stdlib.h&gt;</span></span><br><span class="line">    L.data = (<span class="type">int</span> *)<span class="built_in">malloc</span>((L.Maxsize+len)*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">        L.data[i] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    L.MaxSize = L.MaxSize+len;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-顺序表的特点"><a href="#2-3-顺序表的特点" class="headerlink" title="2.3 顺序表的特点"></a>2.3 顺序表的特点</h3><p>① <strong>随机访问</strong> ，即可以在O(1)时间内找到第i个元素。</p>
<p>②存储密度高，每个节点只存储数据元素 </p>
<p>③拓展容量不方便（即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高）</p>
<p>④插入、删除操作不方便，需要移动大量元素 </p>
<h3 id="2-4-顺序表的基本操作"><a href="#2-4-顺序表的基本操作" class="headerlink" title="2.4 顺序表的基本操作"></a>2.4 顺序表的基本操作</h3><h4 id="2-4-1-插入"><a href="#2-4-1-插入" class="headerlink" title="2.4.1 插入"></a>2.4.1 插入</h4><p>ListInsert(&amp;L,i,e)—在表L中的第i个位置上插入指定元素e。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ListInsert</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,<span class="type">int</span> e)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=L.length;j&gt;=i;j--)&#123;</span><br><span class="line">        L.data[j] = L.data[j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    L.data[i<span class="number">-1</span>] = e;</span><br><span class="line">    L.length++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间复杂度:O(n)</span></span><br></pre></td></tr></table></figure>



<h4 id="2-4-2-删除"><a href="#2-4-2-删除" class="headerlink" title="2.4.2 删除"></a>2.4.2 删除</h4><p>ListDelete(&amp;L,i,&amp;e)—删除表L中第i个位置的元素，并用e返回删除元素的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ListDelete</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,<span class="type">int</span> &amp;e)</span>&#123;</span><br><span class="line">	e = L.data[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;L.length;j++)&#123;</span><br><span class="line">		L.dara[j<span class="number">-1</span>] = L.data[j];</span><br><span class="line">	&#125;</span><br><span class="line">	L.length--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间复杂度:O(n)</span></span><br></pre></td></tr></table></figure>



<h4 id="2-4-3-按值查找"><a href="#2-4-3-按值查找" class="headerlink" title="2.4.3 按值查找"></a>2.4.3 按值查找</h4><p>LocateElem(L,e)—在表L中查找具有给定关键字值的元素。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在顺序表L中查找第一个元素值等于e的元素，并返回其位序</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(SqList L,<span class="type">int</span> e)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L.data[i]==e)&#123;</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;  <span class="comment">//返回位序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间复杂度:O(n)</span></span><br></pre></td></tr></table></figure>



<h4 id="2-4-4-按位查找"><a href="#2-4-4-按位查找" class="headerlink" title="2.4.4 按位查找"></a>2.4.4 按位查找</h4><p>GetElem(L,i)—获取表L中第i个位置的元素的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GetElem</span><span class="params">(SqList L,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L.data[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间复杂度:O(1)</span></span><br></pre></td></tr></table></figure>



<h2 id="3-单链表"><a href="#3-单链表" class="headerlink" title="3.单链表"></a>3.单链表</h2><h3 id="3-1单链表的定义"><a href="#3-1单链表的定义" class="headerlink" title="3.1单链表的定义"></a>3.1单链表的定义</h3><p>单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的数据元素。链表中的数据是以结点来表示的，每个结点的构成：<strong>元素</strong>(数据元素的映象) + <strong>指针</strong>(指示后继元素存储位置)，元素就是存储数据的存储单元，指针就是连接每个结点的地址数据。</p>
<p>优点：不要求大片连续空间，改变容量方便 </p>
<p>缺点：不可随机存取，要耗费一定空间存放指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>            <span class="comment">//定义单链表结点类型</span></span><br><span class="line">    <span class="type">int</span> data;            <span class="comment">//每个节点存放一个数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>  <span class="comment">//指针指向下一个结点</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">p</span> =</span> (<span class="keyword">struct</span> LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Lnode));</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了方便增加结点，可以用typedef来重命名</span></span><br><span class="line"><span class="comment">//把struct LNode重命名为LNode，用LinkList来表示指向struct LNode的指针</span></span><br><span class="line"><span class="comment">//LNode *L; 和 LinkList L；效果一样，但前者强调这是个结点，后者强调这是个单链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化一个空的单链表（不带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(Linklist &amp;L)</span>&#123;</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个空的单链表（带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(Linklist &amp;L)</span>&#123;</span><br><span class="line">    L = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2单链表的基本操作"><a href="#3-2单链表的基本操作" class="headerlink" title="3.2单链表的基本操作"></a>3.2单链表的基本操作</h3><h4 id="3-2-1-插入"><a href="#3-2-1-插入" class="headerlink" title="3.2.1 插入"></a>3.2.1 插入</h4><p>ListInsert(&amp;L,i,e)—在表L中的第i个位置上插入指定元素e。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按位序插入（带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,<span class="type">int</span> e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p;    <span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;   <span class="comment">//当前p指向的第几个结点</span></span><br><span class="line">    p = L;       <span class="comment">//L指向头结点，头结点为第0个结点（不存放数据）</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;   <span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123; <span class="comment">//i值不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////按位序插入（不带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,<span class="type">int</span> e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;   <span class="comment">//插入第1个结点的操作与其他结点操作不同</span></span><br><span class="line">        LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = e;</span><br><span class="line">        s-&gt;next = L;</span><br><span class="line">        L = s;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定结点的后插操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertNextNode</span><span class="params">(LNode *p,<span class="type">int</span> e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Lnode));</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>)&#123;    <span class="comment">//某些情况可能会导致内存分配失败，例如内存不足</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定结点的前插操作</span></span><br><span class="line"> <span class="type">bool</span> <span class="title function_">InsertPriorNode</span><span class="params">(LinkList L,LNode *p,<span class="type">int</span> e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Lnode));</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>)&#123;    <span class="comment">//某些情况可能会导致内存分配失败，例如内存不足</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    s-&gt;data = p-&gt;data;</span><br><span class="line">    p-&gt;data = e;    <span class="comment">//后插操作后交换数值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-删除"><a href="#3-2-2-删除" class="headerlink" title="3.2.2 删除"></a>3.2.2 删除</h4><p>ListDelete(&amp;L,i,&amp;e)—删除表L中第i个位置的元素，并用e返回删除元素的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////按位序删除（带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i,<span class="type">int</span> &amp;e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *q = p-&gt;next;  <span class="comment">//q指向被删除结点</span></span><br><span class="line">    e = q-&gt;data;         <span class="comment">//e返回删除元素的值</span></span><br><span class="line">    p-&gt;next = q-&gt;next;   <span class="comment">//将*q结点从链中断开</span></span><br><span class="line">    <span class="built_in">free</span>(q);             <span class="comment">//释放结点存储空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除指定结点</span></span><br><span class="line"><span class="comment">//如果p是最后一个结点，就只能从表头开始依次寻找p的前驱</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeleteNode</span><span class="params">(LNode *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *q = p-&gt;next;       <span class="comment">//让q指向*p的后继结点</span></span><br><span class="line">    p-&gt;data = p-&gt;next-&gt;data;  <span class="comment">//和后继结点交换数据域</span></span><br><span class="line">    p-&gt;next = q-&gt;next;        <span class="comment">//将*q结点从链中断开</span></span><br><span class="line">    <span class="built_in">free</span>(q);                  <span class="comment">//释放后继结点存储空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-3-查找"><a href="#3-2-3-查找" class="headerlink" title="3.2.3 查找"></a>3.2.3 查找</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按位查找，返回第i个元素（带头结点）</span></span><br><span class="line">LNode *<span class="title function_">GetElem</span><span class="params">(LinkList L,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按值查找，找到数据域==e的结点</span></span><br><span class="line">LNode *<span class="title function_">LocateElem</span><span class="params">(LinkList L,<span class="type">int</span> e)</span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next;  <span class="comment">//从第1个结点开始查找数据域为e的结点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;p-&gt;data!=e)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-单链表的建立"><a href="#3-3-单链表的建立" class="headerlink" title="3.3 单链表的建立"></a>3.3 单链表的建立</h3><p>核心就是<strong>初始化</strong>操作、<strong>指定结点</strong>的后插操作</p>
<h4 id="3-3-1-尾插法"><a href="#3-3-1-尾插法" class="headerlink" title="3.3.1 尾插法"></a>3.3.1 尾插法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(Linklist &amp;L)</span>&#123;</span><br><span class="line">    L = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(L=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">LinkList <span class="title function_">List_TailInsert</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));   <span class="comment">//建立头结点</span></span><br><span class="line">    LNode *s,*r = L;                       <span class="comment">//r为表尾指针</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);                        <span class="comment">//输入结点的值</span></span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;                        <span class="comment">//输入9999表示结束</span></span><br><span class="line">        s = (LNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = x; </span><br><span class="line">        r-&gt;next = s; </span><br><span class="line">        r = s;                             <span class="comment">//r指向新的表尾结点</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;                        <span class="comment">//尾结点指针置空</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-头插法"><a href="#3-3-2-头插法" class="headerlink" title="3.3.2 头插法"></a>3.3.2 头插法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(Linklist &amp;L)</span>&#123;</span><br><span class="line">    L = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(L=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">LinkList <span class="title function_">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    LNode *s;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));   <span class="comment">//建立头结点</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;                        <span class="comment">//初始为空链表</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);                        <span class="comment">//输入结点的值</span></span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;                        <span class="comment">//输入9999表示结束</span></span><br><span class="line">        s = (LNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = x; </span><br><span class="line">        s-&gt;next = L-&gt;next; </span><br><span class="line">        L-&gt;next = s;                       <span class="comment">//将新结点插入表中，L为头指针</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-双链表"><a href="#4-双链表" class="headerlink" title="4.双链表"></a>4.双链表</h2><p>双链表就是在单链表的基础上再增加一个指针域。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span>   <span class="comment">//前驱和后继指针</span></span><br><span class="line">&#125;LNode,*DinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双链表的初始化</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(Dinklist &amp;L)</span>&#123;</span><br><span class="line">    L = (DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode)); <span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;prior = <span class="literal">NULL</span>;                    <span class="comment">//头结点的prioe永远指向NULL</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;                     <span class="comment">//头结点之后暂时没有结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双链表的插入</span></span><br><span class="line"><span class="comment">//在p结点后插入s节点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertNextNode</span><span class="params">(DNode *p,DNode *s)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>||s==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        p-&gt;next-&gt;prior = s;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双链表的删除</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeleteNextNode</span><span class="params">(DNode *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(P==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DNode *q = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(q==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        q-&gt;next-&gt;prior=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-循环链表"><a href="#5-循环链表" class="headerlink" title="5.循环链表"></a>5.循环链表</h2><h3 id="5-1-循环单链表"><a href="#5-1-循环单链表" class="headerlink" title="5.1 循环单链表"></a>5.1 循环单链表</h3><p><strong>循环单链表</strong>：表尾结点的next指针指向头结点。</p>
<p>普通单链表无法找到前驱结点，循环单链表可以找到其他任何一个结点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个空的循环单链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(Linklist &amp;L)</span>&#123;</span><br><span class="line">    L = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(L=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = L;   <span class="comment">//头结点next指向头结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-循环双链表"><a href="#5-2-循环双链表" class="headerlink" title="5.2 循环双链表"></a>5.2 循环双链表</h3><p><strong>循环双链表</strong>：表头结点的prior指向表尾结点，表尾结点的next指向头结点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*DinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环双链表的初始化</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(Dinklist &amp;L)</span>&#123;</span><br><span class="line">    L = (DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">    <span class="keyword">if</span>(L=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;prior = L;</span><br><span class="line">    L-&gt;next = L;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-静态链表"><a href="#6-静态链表" class="headerlink" title="6.静态链表"></a>6.静态链表</h2><p>单链表：各个结点在内存中星罗棋布、散落天涯。</p>
<p>静态链表：分配一整片连续的内存空间，各个结点集中安置。相当于用数组的方式实现的链表。</p>
<p>优点：增、删操作不需要大量移动元素</p>
<p>缺点：不能随机存取，只能从头结点开始依次往后查找；容量固定不可变</p>
<p>适用场景：</p>
<p>①不支持指针的低级语言；</p>
<p>②数据元素数量固定不变的场景（如操作系统的文件分配表FAT）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10  <span class="comment">//静态链表最大长度</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span>             <span class="comment">//静态链表结构类型的定义</span></span><br><span class="line">    <span class="type">int</span> data;       <span class="comment">//存储数据元素</span></span><br><span class="line">    <span class="type">int</span> next;       <span class="comment">//下一个元素的数组下标</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">testLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">a</span>[<span class="title">MaxSize</span>];</span></span><br><span class="line">    <span class="comment">//......后续代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7-顺序表和链表的比较"><a href="#7-顺序表和链表的比较" class="headerlink" title="7.顺序表和链表的比较"></a>7.顺序表和链表的比较</h2><blockquote>
<p><strong>逻辑结构</strong></p>
</blockquote>
<p>都属于线性表，都是线性结构。</p>
<blockquote>
<p><strong>存储结构</strong></p>
</blockquote>
<p>顺序表（顺序存储）：</p>
<p>优点：支持随机存取、存储密度高</p>
<p>缺点：大片连续空间分配不方便，改变容量不方便</p>
<p>链表（链式存储）：</p>
<p>优点：离散的小空间分配方便，改变容量方便</p>
<p>缺点：不可随机存取，存储密度低 </p>
<blockquote>
<p><strong>使用场景</strong></p>
</blockquote>
<p>链表——表长难以预估、经常要增加&#x2F;删除元素 </p>
<p>顺序表 ——表长可预估、查询（搜索）操作较多</p>
<h1 id="第三章：栈和队列"><a href="#第三章：栈和队列" class="headerlink" title="第三章：栈和队列"></a>第三章：栈和队列</h1><h2 id="1-栈"><a href="#1-栈" class="headerlink" title="1.栈"></a>1.栈</h2><h3 id="1-1-栈的定义"><a href="#1-1-栈的定义" class="headerlink" title="1.1 栈的定义"></a>1.1 栈的定义</h3><p>栈（Stack）—是<strong>只允许在一端进行插入或删除操作</strong>的线性表。 </p>
<p>（特性：<strong>后进先出</strong>）</p>
<p>空栈—栈中没有任何数据元素。</p>
<p>栈顶—<strong>允许</strong>插入和删除的一端。</p>
<p>栈底—<strong>不允许</strong>插入和删除的一端。</p>
<h3 id="1-2-栈的基本操作"><a href="#1-2-栈的基本操作" class="headerlink" title="1.2 栈的基本操作"></a>1.2 栈的基本操作</h3><p>栈的基本操作和线性表基本操作类似。（创、销、增、删、查）</p>
<p><strong>InitStack(&amp;S)</strong>：初始化栈。构造一个空栈S，分配内存空间。 </p>
<p><strong>DestroyStack(&amp;S)</strong>：销毁栈。销毁并释放栈S所占用的内存空间。</p>
<p><strong>Push(&amp;S,x)</strong>：进栈，若栈S未满，则将x加入使之成为新栈顶。 </p>
<p><strong>Pop(&amp;S,&amp;x)</strong>：出栈，若栈S非空，则弹出栈顶元素，并用x返回。</p>
<p><strong>GetTop(S,&amp;x)</strong>：读栈顶元素。若栈S非空，则用x返回栈顶元素</p>
<p>其他常用操作： </p>
<p><strong>StackEmpty(S)</strong>：判断一个栈S是否为空。若S为空，则返回true，否则返回false。</p>
<p>注： <strong>卡特兰数</strong><br>$$<br>n个不同元素进栈，出栈元素不同排列的个数为 \frac{1}{n+1}C_{2n}^{n}<br>$$</p>
<h3 id="1-3-栈的顺序存储实现"><a href="#1-3-栈的顺序存储实现" class="headerlink" title="1.3 栈的顺序存储实现"></a>1.3 栈的顺序存储实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10       <span class="comment">//定义栈中元素的最t大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>          </span><br><span class="line">    <span class="type">int</span> data[MaxSize];   <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top;             <span class="comment">//栈顶指针</span></span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SqStack &amp;S)</span>&#123;</span><br><span class="line">    S.top = <span class="number">-1</span>;          <span class="comment">//初始化栈顶指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(SqStack S)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新元素入栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(SqStack &amp;S,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==Maxsize<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">//栈满，报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    S.top = S.top+<span class="number">1</span>;     <span class="comment">//指针先加1</span></span><br><span class="line">    S.data[S.top] = x;   <span class="comment">//新元素入栈</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(SqStack &amp;S,<span class="type">int</span> &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">//栈空，报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    x =  S.data[S.top]   <span class="comment">//栈顶元素出栈</span></span><br><span class="line">    S.top = S.top<span class="number">-1</span>;     <span class="comment">//指针再减1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序栈大大小不可变，可以用共享栈的方式来提高空间的利用率</span></span><br><span class="line"><span class="comment">//共享栈会定义两个栈顶指针，一个初始为-1，另一个初始为MaxSize</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4-栈的链式存储实现"><a href="#1-4-栈的链式存储实现" class="headerlink" title="1.4 栈的链式存储实现"></a>1.4 栈的链式存储实现</h3><p>链式存储实现的栈本质上就是一个单链表，只不过我们规定只允许在“单链表”的一端进行操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Struct Linknode *next;</span><br><span class="line">&#125;*Listack;</span><br></pre></td></tr></table></figure>



<h2 id="2-队列"><a href="#2-队列" class="headerlink" title="2.队列"></a>2.队列</h2><h3 id="2-1-队列的定义"><a href="#2-1-队列的定义" class="headerlink" title="2.1 队列的定义"></a>2.1 队列的定义</h3><p>队列（Queue）—是只允许在<strong>一端进行插入</strong>，<strong>另一端删除</strong>的线性表</p>
<p>（特性：<strong>先进先出</strong>）</p>
<p>空队列—队列中没有任何数据元素。</p>
<p>队头—<strong>允许删除</strong>的一端。</p>
<p>队尾—<strong>允许插入</strong>的一端。</p>
<h3 id="2-2-队列的基本操作"><a href="#2-2-队列的基本操作" class="headerlink" title="2.2 队列的基本操作"></a>2.2 队列的基本操作</h3><p><strong>InitQueue(&amp;Q)</strong>：初始化队列，构造一个空队列Q。</p>
<p><strong>DestroyQueue(&amp;Q)</strong>：销毁队列。销毁并释放队列Q所占用的内存空间。</p>
<p><strong>EnQueue(&amp;Q,x)</strong>：入队，若队列Q未满，将x加入，使之成为新的队尾。 </p>
<p><strong>DeQueue(&amp;Q,&amp;x)</strong>：出队，若队列Q非空，删除队头元素，并用x返回。</p>
<p><strong>GetHead(Q,&amp;x)</strong>：读队头元素，若队列Q非空，则将队头元素赋值给x。</p>
<p>其他常用操作： </p>
<p><strong>QueueEmpty(Q)</strong>：判队列空，若队列Q为空返回true，否则返回false。</p>
<h3 id="2-3-队列的顺序存储实现"><a href="#2-3-队列的顺序存储实现" class="headerlink" title="2.3 队列的顺序存储实现"></a>2.3 队列的顺序存储实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10       <span class="comment">//定义队列中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>          </span><br><span class="line">    <span class="type">int</span> dara[MaxSize];   <span class="comment">//静态数组存放队列元素</span></span><br><span class="line">    <span class="type">int</span> front,rear;      <span class="comment">//队头指针和队尾指针</span></span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue &amp;Q)</span>&#123;</span><br><span class="line">    Q.rear = <span class="number">0</span>;</span><br><span class="line">    Q.front = <span class="number">0</span>;         <span class="comment">//初始时，队头、队尾指针指向0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断对列是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">QueueEmpty</span><span class="params">(SqStack S)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(SqStack &amp;S,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MaxSize == Q.front)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;                 <span class="comment">//队满，报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    Q.data[Q.rear] = x;               <span class="comment">//将x插入队尾</span></span><br><span class="line">    Q.rear = (Q.rear+<span class="number">1</span>)%MaxSize;      <span class="comment">//队尾指针后移</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(SqStack &amp;S,<span class="type">int</span> &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">//队列空，报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    x = x.data[Q.front];</span><br><span class="line">    Q.front = (Q.front+<span class="number">1</span>)%MaxSize;    <span class="comment">//队头指针后移</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用“Q.front = (Q.front+1)%MaxSize”判断队列是否已满会牺牲一个存储空间</span></span><br><span class="line"><span class="comment">//解决办法：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种方法：在队列结构中定义size（初始为0，每次进队size++，出队size--）</span></span><br><span class="line"><span class="comment">//队满条件：size==MaxSize；队空条件：size==0; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方法：在队列结构中定义tag（每次删除操作成功时，都令tag=0； 每次插入操作成功时，都令tag=1）</span></span><br><span class="line"><span class="comment">//队满条件：front==rear&amp;&amp;tag==1；队空条件：front==rear&amp;&amp;tag==0 </span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-队列的链式存储实现"><a href="#2-4-队列的链式存储实现" class="headerlink" title="2.4 队列的链式存储实现"></a>2.4 队列的链式存储实现</h3><p>队列和单链表相比，无非是在插入和删除操作中，它只能分别在队尾和队头进行，单链表的插入和删除却是可以在任何一个位置进行的，队列就相当于一个单链表的“阉割”版。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span>&#123;</span>     <span class="comment">//链式队列结点</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Struct Linknode *next;</span><br><span class="line">&#125;*LinkNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>              <span class="comment">//链式队列</span></span><br><span class="line">    LinkNode *front,*rear;   <span class="comment">//队列的队头和队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列（带头节点）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line">    <span class="comment">//初始时，front、rear都指向头节点 </span></span><br><span class="line">    Q.front=Q.rear=(LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断队列是否为空（带头节点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列（不带头节点）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line">    <span class="comment">//初始时，front、rear都指向NULL</span></span><br><span class="line">    Q.front=<span class="literal">NULL</span>；</span><br><span class="line">    Q.rear=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断队列是否为空（不带头节点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==<span class="literal">NULL</span>)&#123;   <span class="comment">//也可以判断Q.rear==NULL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新元素入队（带头节点）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    LinkNode *s=(LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next=s;   <span class="comment">//新结点插入到rear之后</span></span><br><span class="line">    Q.rear=s;         <span class="comment">//修改表尾指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新元素入队（不带头节点）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    LinkNode *s=(LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//不带头结点的队列，第一个元素入队需要特别处理</span></span><br><span class="line">    <span class="keyword">if</span>(Q.front==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        Q.front=s;</span><br><span class="line">        Q.rear=s;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Q.rear-&gt;next=s;</span><br><span class="line">    	Q.rear=s;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队头元素出队（带头节点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q,<span class="type">int</span> &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;          <span class="comment">//判空</span></span><br><span class="line">    &#125;</span><br><span class="line">    LinkNode *p=Q.front-&gt;next;</span><br><span class="line">    x=p-&gt;data;                 <span class="comment">//用x返回队头元素</span></span><br><span class="line">    Q.front-&gt;next=p-&gt;next;     <span class="comment">//修改头结点的next指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear==p)&#123;             <span class="comment">//此次是最后一个结点出队</span></span><br><span class="line">        Q.rear=Q.front;        <span class="comment">//修改rear指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);                   <span class="comment">//释放结点空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//队头元素出队（不带头节点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q,<span class="type">int</span> &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;          <span class="comment">//判空</span></span><br><span class="line">    &#125;</span><br><span class="line">    LinkNode *p=Q.front;       <span class="comment">//p指向这次出队的结点</span></span><br><span class="line">    x=p-&gt;data;                 <span class="comment">//用x返回队头元素</span></span><br><span class="line">    Q.front=p-&gt;next;           <span class="comment">//修改front指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear==p)&#123;             <span class="comment">//此次是最后一个结点出队</span></span><br><span class="line">        Q.front=<span class="literal">NULL</span>;</span><br><span class="line">        Q.rear=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);                   <span class="comment">//释放结点空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-双端队列"><a href="#2-5-双端队列" class="headerlink" title="2.5 双端队列"></a>2.5 双端队列</h3><p>栈：只允许从<strong>一端插入和删除</strong>的线性表。</p>
<p>队列：只允许从<strong>一端插入</strong>、<strong>另一端删除</strong>的线性表。</p>
<p>双端队列：只允许从<strong>两端插入</strong>、<strong>两端删除</strong>的线性表。</p>
<p>另一方面，双端队列也可以衍生出其他变种</p>
<p><strong>输入受限</strong>的双端队列：只允许从<strong>一端插入</strong>、<strong>两端删除</strong>的线性表</p>
<p><strong>输出受限</strong>的双端队列：只允许从<strong>两端插入</strong>、<strong>一端删除</strong>的线性表</p>
<h2 id="3-栈的应用"><a href="#3-栈的应用" class="headerlink" title="3.栈的应用"></a>3.栈的应用</h2><h3 id="3-1-栈在括号匹配中的应用"><a href="#3-1-栈在括号匹配中的应用" class="headerlink" title="3.1 栈在括号匹配中的应用"></a>3.1 栈在括号匹配中的应用</h3><p>在写代码的过程中，代码中的()、[]、{}都是成双成对出现的，这就是所谓的括号匹配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(((((  )))))</span><br></pre></td></tr></table></figure>

<p>最后出现的左括号最先被匹配（与栈的先进后出异曲同工）</p>
<p> 思路：遇到左括号就入栈，遇到右括号就出栈（“消耗”一个左括号）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line">typrdef <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> data[MaxSize];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SqStack &amp;S)</span></span><br><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(SqStack S)</span></span><br><span class="line"><span class="comment">//新元素入栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(SqStack &amp;S,<span class="type">char</span> x)</span></span><br><span class="line"><span class="comment">//栈顶元素出栈，用x返回</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(SqStack &amp;S,<span class="type">char</span> &amp;x)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//括号匹配</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">bracketCheck</span><span class="params">(<span class="type">char</span> str[],<span class="type">int</span> length)</span>&#123;</span><br><span class="line">    SqStack S;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">&quot;(&quot;</span>||str[i]==<span class="string">&quot;[&quot;</span>||str[i]==<span class="string">&quot;&#123;&quot;</span>)&#123;</span><br><span class="line">            Push(S,str[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(StackEmpty(S))&#123;   <span class="comment">//扫描到右括号，且当前栈空</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">//匹配失败</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">char</span> topElem;</span><br><span class="line">            Pop(S,topElem);</span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">&#x27;)&#x27;</span> &amp;&amp; topElem!=<span class="string">&quot;(&quot;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">&#x27;]&#x27;</span> &amp;&amp; topElem!=<span class="string">&quot;[&quot;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; topElem!=<span class="string">&quot;&#123;&quot;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> StackEmpty(S);       <span class="comment">//检索完全部括号后，栈空说明匹配成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-栈在表达式求值中的应用"><a href="#3-2-栈在表达式求值中的应用" class="headerlink" title="3.2 栈在表达式求值中的应用"></a>3.2 栈在表达式求值中的应用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="number">15</span>/(<span class="number">7</span>-(<span class="number">1</span>+<span class="number">1</span>)))*<span class="number">3</span>)-(<span class="number">2</span>+(<span class="number">1</span>+<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p>算术表达式由三个部分组成：操作数、运算符、界限符（必不可少）。</p>
<p>1924年，一个波兰的数学家突发奇想，可以不用界限符也能无歧义地表达运算顺序。</p>
<p>也就是 Reverse Polish notation（逆波兰表达式&#x3D;后缀表达式）和 Polish notation（波兰表达式&#x3D;前缀表达式）。</p>
<p><strong>中缀</strong>表达式：运算符在两个操作数中间，例如：a+b</p>
<p><strong>后缀</strong>表达式：运算符在两个操作数的后面，例如：ab+</p>
<p><strong>前缀</strong>表达式：运算符在两个操作数的前面，例如：+ab</p>
<h4 id="3-2-1-后缀表达式"><a href="#3-2-1-后缀表达式" class="headerlink" title="3.2.1 后缀表达式"></a>3.2.1 后缀表达式</h4><h5 id="（1）中缀转后缀"><a href="#（1）中缀转后缀" class="headerlink" title="（1）中缀转后缀"></a>（1）中缀转后缀</h5><ul>
<li>中缀转后缀的<strong>手算</strong>方法：</li>
</ul>
<p>① 确定中缀表达式中各个运算符的运算顺序</p>
<p>② 选择下一个运算符，按照「左操作数 右操作数 运算符」的方式组合成一个新的操作数</p>
<p>③ 如果还有运算符没被处理，就继续 ②</p>
<p>【为保证运算顺序唯一，建议采用**“左优先”原则**—只要左边的运算符能先计算，就优先算左边的】 </p>
<ul>
<li>中缀转后缀的<strong>机算</strong>方法：</li>
</ul>
<p>初始化一个栈，用于保存暂时还不能确定运算顺序的运算符。 </p>
<p>从左到右处理各个元素，直到末尾。</p>
<p>可能遇到三种情况：</p>
<p>① 遇到操作数。直接加入后缀表达式。</p>
<p>② 遇到界限符。遇到“(”直接入栈；</p>
<p>遇到“)”则依次弹出栈内运算符并加入后缀表达式，直到 弹出“(”为止。</p>
<p>注意：“(”和”)“不加入后缀表达式。</p>
<p>③ 遇到运算符。依次弹出栈中优先级<strong>高于或等于</strong>当前运算符的所有运算符，并加入后缀表达式， 若碰到“(” 或栈空则停止。之后再把当前运算符入栈。</p>
<p>按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。</p>
<h5 id="（2）后缀表达式的计算"><a href="#（2）后缀表达式的计算" class="headerlink" title="（2）后缀表达式的计算"></a>（2）后缀表达式的计算</h5><ul>
<li>后缀表达式的<strong>手算</strong>方法：</li>
</ul>
<p>从左往右扫描，每遇到一个运算符，就让<strong>运算符前面最近的两个操作数</strong>执行对应运算， 合体为一个操作数</p>
<p>【注意两个操作数的左右顺序】</p>
<ul>
<li>后缀表达式的<strong>机算</strong>方法</li>
</ul>
<p>最后出现的操作数先被运算，与栈的后进先出的特性吻合。</p>
<p>用<strong>栈</strong>实现后缀表达式的计算：</p>
<p>①从左往右扫描下一个元素，直到处理完所有元素</p>
<p>②若扫描到操作数则压入栈，并回到①；否则执行③</p>
<p>③若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到①</p>
<p>【注意先出栈的是“右操作数”】</p>
<h4 id="3-2-2-前缀表达式"><a href="#3-2-2-前缀表达式" class="headerlink" title="3.2.2 前缀表达式"></a>3.2.2 前缀表达式</h4><h5 id="（1）-中缀转前缀"><a href="#（1）-中缀转前缀" class="headerlink" title="（1） 中缀转前缀"></a>（1） 中缀转前缀</h5><ul>
<li>中缀转前缀的<strong>手算</strong>方法：</li>
</ul>
<p>① 确定中缀表达式中各个运算符的运算顺序</p>
<p>② 选择下一个运算符，按照「运算符 左操作数 右操作数」的方式组合成一个新的操作数</p>
<p>③ 如果还有运算符没被处理，就继续 ②</p>
<p>【<strong>“右优先”原则</strong>：只要右边的运算符能先计算，就优先算右边的】</p>
<ul>
<li>中缀转前缀的<strong>机算</strong>方法：</li>
</ul>
<p>初始化两个栈，分别用于保存暂时还不能确定运算顺序的运算符S1和中间结果S2。 </p>
<p>从右往左处理各个元素，直到末尾。</p>
<p>可能遇到三种情况：</p>
<p>① 遇到操作数。直接入S2栈。</p>
<p>② 遇到界限符。遇到“)”直接入S1栈；</p>
<p>遇到“(”则依次弹出S1栈顶运算符并加入S2栈，直到遇到“)”为止。</p>
<p>注意：“(”和”)“不加入前缀表达式。</p>
<p>③ 遇到运算符。依次弹出S1栈中优先级<strong>高于</strong>当前运算符的所有运算符，并加入S2栈， 若碰到“)” 或栈S1空则停止。之后再把当前运算符入栈S1。</p>
<p>按上述方法处理完所有字符后，将S1栈中剩余运算符依次弹出，并加入S2栈，最后在依次弹出S2栈的元素并输出，加入前缀表达式。</p>
<h5 id="（2）-前缀表达式的计算"><a href="#（2）-前缀表达式的计算" class="headerlink" title="（2） 前缀表达式的计算"></a>（2） 前缀表达式的计算</h5><ul>
<li>前缀表达式的<strong>手算</strong>方法</li>
</ul>
<p><strong>从右往左</strong>扫描，每遇到一个运算符，就让<strong>运算符后面最近的两个操作数</strong>执行对应运算， 合体为一个操作数</p>
<p>【注意两个操作数的左右顺序】</p>
<ul>
<li>前缀表达式的<strong>机算</strong>方法</li>
</ul>
<p>用<strong>栈</strong>实现前缀表达式的计算： </p>
<p>①<strong>从右往左</strong>扫描下一个元素，直到处理完所有元素</p>
<p>②若扫描到操作数则压入栈，并回到①；否则执行③</p>
<p>③若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到①</p>
<p>【注意先出栈的 是“左操作数“】</p>
<h4 id="3-2-3-中缀表达式"><a href="#3-2-3-中缀表达式" class="headerlink" title="3.2.3 中缀表达式"></a>3.2.3 中缀表达式</h4><h5 id="（1）-中缀表达式的计算"><a href="#（1）-中缀表达式的计算" class="headerlink" title="（1） 中缀表达式的计算"></a>（1） 中缀表达式的计算</h5><ul>
<li>中缀表达式的<strong>手算</strong></li>
</ul>
<p>中缀表达式是人们常用的算术表示方法，手算方法不再赘述。</p>
<ul>
<li>中缀表达式的<strong>机算</strong></li>
</ul>
<p>初始化两个栈，操作数栈和运算符栈。</p>
<p>从左往右依次处理各个元素，直到末尾。</p>
<p>①若扫描到操作数，压入操作数栈</p>
<p>②若扫描到运算符或界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈</p>
<p>（期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈）</p>
<h3 id="3-3-栈在递归中的应用"><a href="#3-3-栈在递归中的应用" class="headerlink" title="3.3 栈在递归中的应用"></a>3.3 栈在递归中的应用</h3><p>递归算法就是递归函数调用自身的过程。在递归过程中，<strong>最后被调用的函数最先执行结束</strong>，和栈的后进先出类似。</p>
<p>适合用”递归“算法解决：可以把原始问题转换为<strong>属性相同，但规模较小</strong>的问题，例如阶乘、斐波那契数列······</p>
<p>函数调用时，需要用<strong>一个栈</strong>存储： </p>
<p>① 调用返回地址</p>
<p>② 实参</p>
<p>③ 局部变量</p>
<p>递归调用时，<strong>函数调用栈</strong>可称为“递归工作栈”</p>
<p>每进入一层递归，就将递归调用所需信息压入栈顶</p>
<p>每退出一层递归，就从栈顶弹出相应信息</p>
<p>缺点：效率低，太多层递归可能会导致栈溢出；可能包含很多重复计算</p>
<h2 id="4-队列的应用"><a href="#4-队列的应用" class="headerlink" title="4.队列的应用"></a>4.队列的应用</h2><p>队列应用——<strong>树的层次遍历</strong></p>
<p>在后面”树“的笔记里会详细介绍</p>
<p>队列应用——<strong>图的广度优先遍历</strong></p>
<p>在后面”图“的笔记里会详细介绍</p>
<p>队列在<strong>操作系统</strong>中的应用</p>
<p>多个进程争抢着使用有限的系统资源时，FCFS（FirstComeFirstService，先来先服务—可用队列实现）是一种常用策略。</p>
<p>例如：CPU资源的分配，打印数据缓冲区</p>
<h2 id="5-特殊矩阵的压缩存储"><a href="#5-特殊矩阵的压缩存储" class="headerlink" title="5.特殊矩阵的压缩存储"></a>5.特殊矩阵的压缩存储</h2><h3 id="5-1-数据的存储结构"><a href="#5-1-数据的存储结构" class="headerlink" title="5.1 数据的存储结构"></a>5.1 数据的存储结构</h3><p>一维数组——各数组元素大小相同，且物理上连续存放。</p>
<p>二维数组——”行优先“存储和”列优先“存储 </p>
<h3 id="5-2-特殊矩阵"><a href="#5-2-特殊矩阵" class="headerlink" title="5.2 特殊矩阵"></a>5.2 特殊矩阵</h3><p>普通矩阵的存储——可以用二维数组存储。</p>
<p>某些特殊矩可以压缩存储空间。</p>
<h4 id="5-2-1-对称矩阵"><a href="#5-2-1-对称矩阵" class="headerlink" title="5.2.1 对称矩阵"></a>5.2.1 对称矩阵</h4><p>对阵矩阵：n阶<strong>方阵</strong>中任意一个元素a(i,j)&#x3D;a(j,i)</p>
<p>压缩存储策略：只存储主对角线+下三角区 （或主对角线+上三角区），按行优先（或列优先）原则将各元素存入一维数组中。</p>
<p>站在程序员的角度，为了方便使用，可以实现一个**“映射”函数**。</p>
<p>（矩阵下标—&gt;一维数组下标）</p>
<h4 id="5-2-2-三角矩阵"><a href="#5-2-2-三角矩阵" class="headerlink" title="5.2.2 三角矩阵"></a>5.2.2 三角矩阵</h4><p>下三角矩阵：除了主对角线和下三角区，其余的元素都相同</p>
<p>上三角矩阵：除了主对角线和上三角区，其余的元素都相同</p>
<p>压缩存储策略：与对称矩阵类似，行优先（或列优先）原则将主对角线和下（上）三角区存入一维数组中，并在最后一个位置存储常量c</p>
<h4 id="5-2-3-三对角矩阵"><a href="#5-2-3-三对角矩阵" class="headerlink" title="5.2.3 三对角矩阵"></a>5.2.3 三对角矩阵</h4><p>三对角矩阵，又称带状矩阵： 当|i-j|&gt;1时，有a(i,j)&#x3D;0 （1≤i,j≤n）</p>
<p>压缩存储策略： 按行优先（或列优先）原则，只存储带状部分</p>
<h4 id="5-2-4-稀疏矩阵"><a href="#5-2-4-稀疏矩阵" class="headerlink" title="5.2.4 稀疏矩阵"></a>5.2.4 稀疏矩阵</h4><p>稀疏矩阵：非零元素远远少于矩阵元素的个数</p>
<p>压缩存储策略：</p>
<p>①顺序存储——三元组&lt;行，列，值&gt;</p>
<p>②链式存储——十字链表法</p>
<h1 id="第四章：串"><a href="#第四章：串" class="headerlink" title="第四章：串"></a>第四章：串</h1><h2 id="1-串的定义和基本操作"><a href="#1-串的定义和基本操作" class="headerlink" title="1.串的定义和基本操作"></a>1.串的定义和基本操作</h2><h3 id="1-1-串的定义"><a href="#1-1-串的定义" class="headerlink" title="1.1 串的定义"></a>1.1 串的定义</h3><p><strong>串</strong>，即<strong>字符串</strong>（String）是由零个或多个<strong>字符</strong>组成的有限序列。</p>
<p>一些术语：</p>
<p>子串： 串中任意个连续的字符组成的子序列。 </p>
<p>主串： 包含子串的串。</p>
<p>字符在主串中的位置： 字符在串中的序号（从1开始计数）。</p>
<p>子串在主串中的位置： 子串的第一个字符在主串中的位置 。 </p>
<h3 id="1-2-串的基本操作"><a href="#1-2-串的基本操作" class="headerlink" title="1.2 串的基本操作"></a>1.2 串的基本操作</h3><p>串是一种特殊的线性表，数据元素之间呈线性关系。</p>
<p>串的数据对象限定为字符集（如中文字符、英文字符、数字字符、标点字符等）。</p>
<p>串的基本操作，如增删改查等<strong>通常以子串为操作对象</strong>。</p>
<p>StrAssign(&amp;T,chars)：赋值操作。把串T赋值为chars。 </p>
<p>StrCopy(&amp;T,S)：复制操作。由串S复制得到串T。</p>
<p>StrEmpty(S)：判空操作。若S为空串，则返回TRUE，否则返回FALSE。 </p>
<p>StrLength(S)：求串长。返回串S的元素个数。</p>
<p>ClearString(&amp;S)：清空操作。将S清为空串。 </p>
<p>DestroyString(&amp;S)：销毁串。将串S销毁（回收存储空间）。 </p>
<p>Concat(&amp;T,S1,S2)：串联接。用T返回由S1和S2联接而成的新串 </p>
<p>SubString(&amp;Sub,S,pos,len)：求子串。用Sub返回串S的第pos个字符起长度为len的子串。</p>
<p>StrCompare(S,T)：比较操作。若S&gt;T，则返回值&gt;0；若S&#x3D;T，则返回值&#x3D;0；若S&lt;T，则返回值&lt;0。 </p>
<p>Index(S,T)：定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的 位置；否则函数值为0。 </p>
<h2 id="2-串的存储结构"><a href="#2-串的存储结构" class="headerlink" title="2.串的存储结构"></a>2.串的存储结构</h2><h3 id="2-1-串的顺序存储"><a href="#2-1-串的顺序存储" class="headerlink" title="2.1 串的顺序存储"></a>2.1 串的顺序存储</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch[MAXSIZE];   <span class="comment">//静态数组实现（定长顺序存储）</span></span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *ch;           <span class="comment">//动态数组实现（堆分配存储）</span></span><br><span class="line">    <span class="type">int</span> length; </span><br><span class="line">&#125;HString;</span><br><span class="line">Hstring s;</span><br><span class="line">S.ch = (<span class="type">char</span> *)<span class="built_in">malloc</span>(MAXSIZE * <span class="keyword">sizeof</span>(<span class="type">char</span>));  <span class="comment">//用完需要手动free</span></span><br><span class="line">S.length = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-串的链式存储"><a href="#2-2-串的链式存储" class="headerlink" title="2.2 串的链式存储"></a>2.2 串的链式存储</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">typedef struct StringNode&#123;</span></span><br><span class="line"><span class="comment">    char ch;</span></span><br><span class="line"><span class="comment">    int StringNode *next;</span></span><br><span class="line"><span class="comment">&#125;StringNode,*String;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">char一个字符只占1个字节，在32位电脑中，指针占4个字节。</span></span><br><span class="line"><span class="comment">这意味着你用1个字节存储你想要的信息，用4个字节来存储辅助信息，这种情况称之为存储密度低，所以不太建议采用这种方式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//每个结点存储多个字节，为了避免存储密度低</span></span><br><span class="line">    <span class="comment">//如果某些结点填不满，可以用特殊字符填充，例如&#x27;#&#x27;，&#x27;\0&#x27;</span></span><br><span class="line">    <span class="type">char</span> ch[<span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> StringNode *next;</span><br><span class="line">&#125;StringNode,*String;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-3-基本操作的实现"><a href="#2-3-基本操作的实现" class="headerlink" title="2.3 基本操作的实现"></a>2.3 基本操作的实现</h3><p>以<strong>顺序存储</strong>的<strong>动态数组</strong>实现的串为例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *ch;   <span class="comment">//动态数组实现（堆分配存储）</span></span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;HString;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值操作。把串T赋值为chars。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">StrAssign</span><span class="params">(HString &amp;T, <span class="type">char</span> chars[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;*(chars+i);i++);</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">        T.ch = <span class="literal">NULL</span>;</span><br><span class="line">        T.length = <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        T.ch = (<span class="type">char</span> *)<span class="built_in">malloc</span>(i*<span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        <span class="keyword">if</span>(!T.ch)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; i;j++)&#123;</span><br><span class="line">                *(T.ch+j) = *(chars+j);</span><br><span class="line">            &#125;</span><br><span class="line">            T.length = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制操作。由串S复制得到串T。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StringCopy</span><span class="params">(HString &amp;T, HString &amp;S)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T.ch)&#123;</span><br><span class="line">        <span class="built_in">free</span>(T.ch);</span><br><span class="line">        T.ch = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T.length = <span class="number">0</span>;</span><br><span class="line">    T.ch = (<span class="type">char</span> *)<span class="built_in">malloc</span>(S.length*<span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S.length; i++)&#123;</span><br><span class="line">		T.ch[i] = S.ch[i];</span><br><span class="line">	&#125;</span><br><span class="line">	T.length = S.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空操作。若S为空串，则返回TRUE，否则返回FALSE。</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StrEmpty</span><span class="params">(HString &amp;S)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!S.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求串长。返回串S的元素个数。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">StrLength</span><span class="params">(HString &amp;S)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空操作。将S清为空串。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ClearString</span><span class="params">(HString &amp;S)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.ch)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(s.ch);</span><br><span class="line">        s.ch = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s.length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁串。将串S销毁（回收存储空间）。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyString</span><span class="params">(HString &amp;S)</span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(s.ch);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//串联接。用T返回由S1和S2联接而成的新串</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Concat</span><span class="params">(HString &amp;T,HString s1,HString s2)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">if</span>(T.ch)&#123;</span><br><span class="line">		<span class="built_in">free</span>(T.ch); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!(T.ch = (<span class="type">char</span>*)<span class="built_in">malloc</span>((s1.length + s2.length)*<span class="keyword">sizeof</span>(<span class="type">char</span>))))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T.length = s1.length + s2.length;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; s1.length;i++)&#123;</span><br><span class="line">        *(T.ch+i) = *(s1.ch+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; s2.length;j++)&#123;</span><br><span class="line">           *(T.ch+s1.length+j) = *(s2.ch + j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//求子串。用Sub返回串S的第pos个字符起长度为len的子串。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">SubString</span><span class="params">(HString &amp;Sub,HString S,<span class="type">int</span> pos,<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">0</span> || len &gt; S.length ||pos &lt; <span class="number">1</span>  || pos &gt; S.length-pos+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">        Sub.ch = <span class="literal">NULL</span>;</span><br><span class="line">        Sub.length = <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Sub.ch = (<span class="type">char</span> *)<span class="built_in">malloc</span>(len *<span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            *(Sub.ch+i) = *(S.ch+pos+i<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Sub.length = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较操作。若S&gt;T，则返回值&gt;0；若S=T，则返回值=0；若S&lt;T，则返回值&lt;0。 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">StrCompare</span><span class="params">(HString S,HString T)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; S.length &amp;&amp; i &lt; T.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i]!=T.ch[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> S.ch[i]-T.ch[i];</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;       </span><br><span class="line">    <span class="keyword">return</span> S.length-T.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为-1。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(HString S,HString T)</span>&#123;</span><br><span class="line">    HString a;</span><br><span class="line">    <span class="type">int</span> m = S.length;</span><br><span class="line">    <span class="type">int</span> n = T.length;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=m-n+<span class="number">1</span>)&#123;</span><br><span class="line">        SubString(sub,S,i,n);</span><br><span class="line">        <span class="keyword">if</span>(StrCompare(sub,T)!=<span class="number">0</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-字符串模式匹配"><a href="#3-字符串模式匹配" class="headerlink" title="3.字符串模式匹配"></a>3.字符串模式匹配</h2><p>⼦串——主串的⼀部分，⼀定存在</p>
<p>模式串——不⼀定能在主串中找到</p>
<p><strong>字符串模式匹配</strong>：在主串中找到与模式串相同的⼦串，并返回其所在位置。</p>
<h3 id="3-1-朴素模式匹配算法"><a href="#3-1-朴素模式匹配算法" class="headerlink" title="3.1 朴素模式匹配算法"></a>3.1 朴素模式匹配算法</h3><p>主串⻓度为n，模式串⻓度为 m </p>
<p>朴素模式匹配算法：将主串中<strong>所有⻓度为m的⼦串</strong>依次与模式串对⽐，直到找到⼀个完全匹配的⼦串， 或所有的⼦串都不匹配为⽌。 </p>
<p>【最多对⽐ n-m+1 个⼦串】</p>
<p>之前介绍过的<strong>串的定位操作</strong>其实已经实现了朴素模式的算法匹配，不过我们使用了两个字符串的基本操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为-1。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(HString S,HString T)</span>&#123;</span><br><span class="line">    HString a;</span><br><span class="line">    <span class="type">int</span> n = S.length;</span><br><span class="line">    <span class="type">int</span> m = T.length;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n-m+<span class="number">1</span>)&#123;   <span class="comment">//最多对⽐ n-m+1 个⼦串</span></span><br><span class="line">        <span class="comment">//取出从位置i开始，⻓度为m的⼦串</span></span><br><span class="line">        SubString(sub,S,i,n);</span><br><span class="line">        <span class="comment">//⼦串和模式串对⽐，若不匹配，则匹配下⼀个⼦串 </span></span><br><span class="line">        <span class="keyword">if</span>(StrCompare(sub,T)!=<span class="number">0</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们不使⽤字符串的基本操作，直接通过数组下标实现朴素模式匹配算法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(HString S,HString T)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;S.length &amp;&amp; j&lt;T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i]==T.ch[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i=i-j+<span class="number">1</span>;</span><br><span class="line">            j=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;=T.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> i-T.length+<span class="number">1</span>;     <span class="comment">//+1是因为返回的是位置而不是下标</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-KMP算法"><a href="#3-2-KMP算法" class="headerlink" title="3.2.KMP算法"></a>3.2.KMP算法</h3><p>KMP算法是由朴素模式匹配算法优化而来的。</p>
<p>由D.E.<strong>K</strong>nuth，J.H.<strong>M</strong>orris和V.R.<strong>P</strong>ratt提出，因此称为<strong>KMP</strong>算法。</p>
<p>根据模式串T，求出 next 数组，然后利⽤next数组进⾏匹配 （主串指针不回溯）。</p>
<p>【当模式串T(j)字符匹配失败时，令模式串的指针j&#x3D;next(j)，继续往后匹配】</p>
<h4 id="3-2-1-手算next数组"><a href="#3-2-1-手算next数组" class="headerlink" title="3.2.1 手算next数组"></a>3.2.1 手算next数组</h4><p>举例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模式串T（第一行数组下标j，第二行内容T(j)）</span></span><br><span class="line"><span class="number">0</span>	<span class="number">1</span>	<span class="number">2</span>	<span class="number">3</span>	<span class="number">4</span>	<span class="number">5</span>	<span class="number">6</span>	<span class="number">7</span></span><br><span class="line">A	B	A	B	A	A	A	B</span><br></pre></td></tr></table></figure>

<p>如果模式串T(0)不匹配，找前面公共前后缀（无字符），将模式串T(0)与主串的下一位进行匹配</p>
<p>如果模式串T(1)不匹配，找前面公共前后缀（A，长度0），将模式串T(0)与主串当前位置进行匹配</p>
<p>如果模式串T(2)不匹配，找前面公共前后缀（AB，长度0），将模式串T(0)与主串当前位置进行匹配</p>
<p>如果模式串T(3)不匹配，找前面公共前后缀（ABA，长度1），将模式串T(1)与主串当前位置进行匹配</p>
<p>如果模式串T(4)不匹配，找前面公共前后缀（ABAB，长度1），将模式串T(2)与主串当前位置进行匹配</p>
<p>如果模式串T(5)不匹配，找前面公共前后缀（ABABA，长度3），将模式串T(3)与主串当前位置进行匹配</p>
<p>如果模式串T(6)不匹配，找前面公共前后缀（ABABAA，长度1），将模式串T(1)与主串当前位置进行匹配</p>
<p>如果模式串T(7)不匹配，找前面公共前后缀（ABABAAA，长度1），将模式串T(1)与主串当前位置进行匹配</p>
<p>所以求出next数组的结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//next[]数组（第一行数组下标，第二行内容）</span></span><br><span class="line"><span class="number">0</span>	<span class="number">1</span>	<span class="number">2</span>	<span class="number">3</span>	<span class="number">4</span>	<span class="number">5</span>	<span class="number">6</span>	<span class="number">7</span>	</span><br><span class="line"><span class="number">-1</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">1</span>	<span class="number">2</span>	<span class="number">3</span>	<span class="number">1</span>	<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-完整代码"><a href="#3-2-2-完整代码" class="headerlink" title="3.2.2 完整代码"></a>3.2.2 完整代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由模式串t求出next值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetNext</span><span class="params">(HString t,<span class="type">int</span> next[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">-1</span>;</span><br><span class="line">	next[<span class="number">0</span>]=<span class="number">-1</span>;   <span class="comment">//第一个字符前无字符串，给值-1</span></span><br><span class="line">	<span class="keyword">while</span> (j&lt;t.length<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="comment">//因为next数组中j最大为t.length-1,而每一步next数组赋值都是在j++之后</span></span><br><span class="line">	<span class="comment">//所以最后一次经过while循环时j为t.length-2</span></span><br><span class="line">		<span class="keyword">if</span> (k==<span class="number">-1</span> || t.ch[j]==t.ch[k])&#123;	   <span class="comment">////k为-1或比较的字符相等时</span></span><br><span class="line">			j++;k++;</span><br><span class="line">			next[j]=k;</span><br><span class="line">       	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			k=next[k];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index_KMP</span><span class="params">(HString S,HString T,<span class="type">int</span> next[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;S.length &amp;&amp; j&lt;T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">-1</span>||S.ch[i]==T.ch[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];           <span class="comment">//匹配失败时，主串指针i不回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;=T.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> i-T.length+<span class="number">1</span>;     <span class="comment">//+1是因为返回的是位置而不是下标</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="第五章：树"><a href="#第五章：树" class="headerlink" title="第五章：树"></a>第五章：树</h1><h2 id="1-树"><a href="#1-树" class="headerlink" title="1.树"></a>1.树</h2><h3 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h3><p>树是n（n≥0）个<strong>结点</strong>的有限集合，n&#x3D; 0时，称为<strong>空树</strong>，这是一种特殊情况。</p>
<p>在任意一棵非空树中应满足：</p>
<p>①有且仅有一个特定的称为<strong>根</strong>的结点。</p>
<p>②当n&gt; 1时，其余结点可分为m（m&gt; 0）个<strong>互不相交的有限集合</strong>T1, T2,…, Tm，其中每个集合本身又是一棵树，并且称为根结点的<strong>子树</strong>。</p>
<h3 id="1-2-基本术语"><a href="#1-2-基本术语" class="headerlink" title="1.2 基本术语"></a>1.2 基本术语</h3><ul>
<li>结点之间的<strong>关系描述</strong></li>
</ul>
<p>祖先结点：从一个结点出发，一直往上走，直至根节点，这条路上所有的结点都是该结点的祖先结点。</p>
<p>子孙结点：从一个结点出发，它的所有分支都是该结点的子孙结点。</p>
<p>双亲结点（父节点）：一个结点的直接前驱就是双亲结点（父节点）。</p>
<p>孩子结点：一个结点的直接后继就是孩子结点。</p>
<p>兄弟结点：双亲结点（父节点）相同的结点互为兄弟结点。</p>
<p>堂兄弟结点：<strong>同一层</strong>的不是兄弟结点的结点。</p>
<p>两个结点之间的路径：路径是单向（自上往下）的。</p>
<p>路径长度：经过了几条边。</p>
<ul>
<li>结点、树的<strong>属性描述</strong></li>
</ul>
<p>结点的层次（深度）：从上往下数（默认从1开始，但也有些教材是从0开始）</p>
<p>结点的高度：从下往上数</p>
<p>树的高度（深度）：总共多少层</p>
<p><strong>结点的度</strong>：有几个孩子（分支）</p>
<p><strong>树的度</strong>：各结点的度的最大值</p>
<ul>
<li><strong>有序树</strong>、<strong>无序树</strong></li>
</ul>
<p>有序树：逻辑上看，树中结点的各子树从左至右是<strong>有次序</strong>的，<strong>不能互换</strong>。</p>
<p>无序树：逻辑上看，树中结点的各子树从左至右是<strong>无次序</strong>的，<strong>可以互换</strong>。</p>
<ul>
<li><strong>森林</strong></li>
</ul>
<p>森林：森林是m（m≥0）棵互不相交的树的集合</p>
<h3 id="1-3-树的性质"><a href="#1-3-树的性质" class="headerlink" title="1.3 树的性质"></a>1.3 树的性质</h3><p>①结点数&#x3D;总度数+1</p>
<p>结点的度：结点有几个孩子（分支）</p>
<p>②度为m的树、m叉树的区别</p>
<p>树的度：各结点的度的最大值</p>
<p>m叉树：每个结点最多只能有m个孩子的树</p>
<table>
<thead>
<tr>
<th align="center">度为m的树</th>
<th align="center">m叉树</th>
</tr>
</thead>
<tbody><tr>
<td align="center">任意结点的度≤m（最多m个孩子）</td>
<td align="center">任意结点的度≤m（最多m个孩子）</td>
</tr>
<tr>
<td align="center">至少有一个结点度&#x3D;m（有m个孩子）</td>
<td align="center">允许所有结点的度都 ＜m</td>
</tr>
<tr>
<td align="center">一定是非空树，至少有m+1个结点</td>
<td align="center">可以是空树</td>
</tr>
</tbody></table>
<p>③度为m的树第i层至多有m^(i-1)个结点（i≥1）;</p>
<p>​	m叉树第i层至多有m^(i-1)个结点（i≥1）。</p>
<p>④高度为h的m叉树至多有(m^h-1)&#x2F;(m-1)个结点</p>
<p>⑤高度为h的m叉树至少有h个结点；</p>
<p>​	高度为h、度为m的树至少有h+m-1个结点。</p>
<p>⑥具有n个结点的m叉树的最小高度为<br>$$<br>[log_m(n(m-1)+1)]<br>$$<br>​	高度最小的情况——所有结点都有m个孩子 </p>
<h2 id="2-二叉树"><a href="#2-二叉树" class="headerlink" title="2.二叉树"></a>2.二叉树</h2><h3 id="2-1-定义和基本术语"><a href="#2-1-定义和基本术语" class="headerlink" title="2.1 定义和基本术语"></a>2.1 定义和基本术语</h3><p>二叉树是n（n≥0）个结点的有限集合： </p>
<p>① 或者为空二叉树，即n&#x3D; 0。</p>
<p>② 或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树。 </p>
<p>特点：每个结点<strong>至多</strong>只有两棵子树；左右子树不能颠倒（二叉树是有序树）</p>
<p>二叉树的<strong>五种状态</strong>：空二叉树；只有左子树；只有右子树；左右子树都有；只有根结点。</p>
<p><strong>特殊的二叉树</strong>：</p>
<p><strong>满二叉树</strong>：一棵高度为h，且含有2^h - 1个结点的二叉树</p>
<blockquote>
<p>特点： </p>
<p>①只有最后一层有叶子结点</p>
<p>②不存在度为1的结点</p>
<p>③按层序从1开始编号，结点i的左孩子为2i，右孩 子为2i+1；结点i的父节点为𝑖&#x2F;2（如果有的话）</p>
</blockquote>
<p><strong>完全二叉树</strong>：当且仅当其每个结点都与高度为h的 满二叉树中编号为1～n的结点一一对应时，称为 完全二叉树</p>
<blockquote>
<p>特点： </p>
<p>①只有最后两层可能有叶子结点</p>
<p>②最多只有一个度为1的结点</p>
<p>③按层序从1开始编号，结点i的左孩子为2i，右孩 子为2i+1；结点i的父节点为𝑖&#x2F;2（如果有的话）</p>
<p>④i≤ 𝑛&#x2F;2为分支结点，i&gt;𝑛&#x2F;2为叶子结点</p>
</blockquote>
<p><strong>二叉排序树</strong>：一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树</p>
<blockquote>
<p>左子树上所有结点的关键字均小于根结点的关键字； </p>
<p>右子树上所有结点的关键字均大于根结点的关键字。 </p>
<p>左子树和右子树又各是一棵二叉排序树。</p>
</blockquote>
<p><strong>平衡二叉树</strong>：树上任一结点的左子树和右子树的深度之差不超过1。</p>
<blockquote>
<p>平衡二叉树能有更高的搜索效率</p>
</blockquote>
<h3 id="2-2-性质"><a href="#2-2-性质" class="headerlink" title="2.2 性质"></a>2.2 性质</h3><p><strong>二叉树</strong>：</p>
<p>①设非空二叉树中度为0、1和2的结点个数分别为n0、n1和n2， 则 n0 &#x3D; n2 + 1 </p>
<p>（叶子结点比二分支结点多一个）</p>
<p>②二叉树第i层至多有2^(i-1)个结点（i≥1）</p>
<p>​	m叉树第i层至多有m^(i-1)个结点（i≥1）</p>
<p>③高度为h的二叉树至多有2^h−1个结点（满二叉树）</p>
<p>​	高度为h的m叉树至多有(m^h-1)&#x2F;(m-1)个结点</p>
<p><strong>完全二叉树</strong>：</p>
<p>①具有n个（n &gt; 0）结点的完全二叉树的高度h为<br>$$<br>[log_2(n+1)] 或 [log_2n]+1<br>$$<br>②对于完全二叉树，可以由的结点数n推出度为0、1和2的结点个数为n0、n1和n2</p>
<p>【突破点：完全二叉树最多只会有一个度为1的结点】</p>
<p>若完全二叉树有2k个（偶数）个结点，则必有n1&#x3D;1，n0&#x3D;k，n2&#x3D;k-1</p>
<p>若完全二叉树有2k-1个（奇数）个结点，则必有n1&#x3D;0，n0&#x3D;k，n2&#x3D;k-1</p>
<h3 id="2-3-存储结构"><a href="#2-3-存储结构" class="headerlink" title="2.3 存储结构"></a>2.3 存储结构</h3><h4 id="2-3-1-顺序存储"><a href="#2-3-1-顺序存储" class="headerlink" title="2.3.1 顺序存储"></a>2.3.1 顺序存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> value;     <span class="comment">//结点的数据元素</span></span><br><span class="line">    <span class="type">bool</span> isEmpty;  <span class="comment">//结点是否为空</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode t[MaxSize];</span><br><span class="line"><span class="comment">//定义一个长度为MaxSize的数组t</span></span><br><span class="line"><span class="comment">//按照从上至下、从左至右的顺序依次存储完全二叉树中的各个结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MaxSize;i++)&#123;</span><br><span class="line">    t[i].isEmpty = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化时所有 结点标记为空</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-链式存储"><a href="#2-3-2-链式存储" class="headerlink" title="2.3.2 链式存储"></a>2.3.2 链式存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;                            <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>      <span class="comment">//左、右孩子指针</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一棵空树</span></span><br><span class="line">BiTree root = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入根节点</span></span><br><span class="line">root = (BiTree)<span class="built_in">malloc</span>(sizzeof(BiTNode))</span><br><span class="line">root-&gt;data=&#123;<span class="number">1</span>&#125;;</span><br><span class="line">root-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">root-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入新结点</span></span><br><span class="line">BiTNode *p=(BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">p-&gt;data=&#123;<span class="number">2</span>&#125;;</span><br><span class="line">p-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">root-&gt;lchild = p;  <span class="comment">//作为根节点的左孩子</span></span><br></pre></td></tr></table></figure>

<p>在这个链表中，找到指定结点的左&#x2F;右孩子很简单，但要找到指定结点的父结点就只能从根节点开始遍历。</p>
<p>为了方便查找父亲结点，我们可以在结构体中定义一个父节点指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BitNode</span> *<span class="title">parent</span>;</span>              <span class="comment">//父节点指针</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure>

<p>这个就被称为三叉链表。</p>
<h3 id="2-4-二叉树的先中后序遍历"><a href="#2-4-二叉树的先中后序遍历" class="headerlink" title="2.4 二叉树的先中后序遍历"></a>2.4 二叉树的先中后序遍历</h3><p><strong>先</strong>序遍历：<strong>根</strong> 左 右</p>
<p><strong>中</strong>序遍历：左 <strong>根</strong> 右</p>
<p><strong>后</strong>序遍历：左 右 <strong>根</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        visit(T);<span class="comment">//访问根节点</span></span><br><span class="line">        PreOrder(T-&gt;lchild);</span><br><span class="line">        PreOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        visit(T);</span><br><span class="line">        InOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        PostOrder(T-&gt;lchild);</span><br><span class="line">        PostOrder(T-&gt;rchild);</span><br><span class="line">        visit(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小应用</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求树的深度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">treeDepth</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> l = treeDepth(T-&gt;lchild);</span><br><span class="line">        <span class="type">int</span> r = treeDepth(T-&gt;rchild);</span><br><span class="line">        <span class="keyword">return</span> l&gt;r ? l+<span class="number">1</span> : r+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-二叉树的层次遍历"><a href="#2-5-二叉树的层次遍历" class="headerlink" title="2.5 二叉树的层次遍历"></a>2.5 二叉树的层次遍历</h3><p>算法思想：</p>
<ul>
<li><p>初始化一个辅助队列</p>
</li>
<li><p>根节点入队</p>
</li>
<li><p>若队列非空，则对头结点出队，访问该结点，并将其左、右孩子插入队尾（如果有）</p>
</li>
<li><p>重复上一步，直至队列为空</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式队列结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    BiTNode* data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    LinkNode *front,*rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层次遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    BiTree p;</span><br><span class="line">    EnQueue(Q,T);</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">        DeQueue(Q,P);</span><br><span class="line">        visit(p);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild!=<span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(Q,p-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(Q,p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-线索二叉树"><a href="#3-线索二叉树" class="headerlink" title="3.线索二叉树"></a>3.线索二叉树</h2><h3 id="3-1-二叉树的线索化"><a href="#3-1-二叉树的线索化" class="headerlink" title="3.1 二叉树的线索化"></a>3.1 二叉树的线索化</h3><p><strong>在二叉树的结点上加上线索</strong>的<strong>二叉树</strong>称为<strong>线索二叉树</strong>.</p>
<p>对二叉树以某种遍历方式（如先序、中序、后序或层次等）进行遍历，使其变为线索二叉树的过程称为对二叉树进行线索化。</p>
<p>线索链表解决了无法直接找到该结点在某种遍历序列中的前驱和后继结点的问题，解决了二叉链表找左、右孩子困难的问题。</p>
<p><strong>用土办法找到中序前驱</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//辅助全局变量，用于查找结点p的前驱</span></span><br><span class="line">BiTNode* p;                <span class="comment">//p指向目标结点</span></span><br><span class="line">BiTNode* pre = <span class="literal">NULL</span>;       <span class="comment">//pre指向当前访问结点的前驱</span></span><br><span class="line">BiTNode final = <span class="literal">NULL</span>;      <span class="comment">//用于记录最终结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        visit(T);</span><br><span class="line">        InOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问结点q</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(BiTNode* q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q==p)</span><br><span class="line">        final = pre;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pre = q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以<strong>中序线索化</strong>为例，先序后序过程类似，不一一赘述。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量pre，指向当前访问结点的前驱</span></span><br><span class="line">ThreadNode* pre = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线索二叉树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="type">int</span> ltag,rtag;   <span class="comment">//左、右线索标志</span></span><br><span class="line">&#125;ThreadNode,*ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历二叉树，一边遍历，一边线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;lchild == <span class="literal">NULL</span>)&#123;   <span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">        q-&gt;lchild = pre;</span><br><span class="line">        q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        pre-&gt;child = q;   <span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InThread</span><span class="params">(Thread T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        InThread(T-&gt;lchild);</span><br><span class="line">        visit(T);    <span class="comment">//在visit()中完成线索化</span></span><br><span class="line">        InThread(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序线索化二叉树T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    pre = <span class="literal">NULL</span>;                  <span class="comment">//pre初始为NULL</span></span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;               <span class="comment">//非空二叉树才能线索化</span></span><br><span class="line">        InThread(T);             <span class="comment">//中序线索化二叉树</span></span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">            pre-&gt;rtag=<span class="number">1</span>;         <span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-2-在线索二叉树中找前驱后继"><a href="#3-2-在线索二叉树中找前驱后继" class="headerlink" title="3.2 在线索二叉树中找前驱后继"></a>3.2 在线索二叉树中找前驱后继</h3><h4 id="3-2-1-中序线索二叉树"><a href="#3-2-1-中序线索二叉树" class="headerlink" title="3.2.1 中序线索二叉树"></a>3.2.1 中序线索二叉树</h4><ul>
<li>中序<strong>后继</strong></li>
</ul>
<p>在中序线索二叉树中找到指定结点 *p 的中序后继 next</p>
<p>①若 p-&gt;rtag &#x3D;&#x3D; 1，则 next &#x3D; p-&gt;rchild</p>
<p>②若 p-&gt;rtag &#x3D;&#x3D; 0，则 next &#x3D; p的右子树中最左下角结点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到以P为根的子树中，第一个被中序遍历的结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Firstnode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">   <span class="comment">//循环找到最左下的结点（不一定是叶结点）</span></span><br><span class="line">   <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">      p=p-&gt;lchild;</span><br><span class="line">   <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在中序线索二叉树中找到结点p的后继结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Nextnode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">   <span class="comment">//右子树最左下结点</span></span><br><span class="line">   <span class="keyword">if</span>(p-&gt;rtag==<span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> Firstnode(p-&gt;rchild);</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> p-&gt;rchild; <span class="comment">//rtag==1，直接返回后继线索</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对中序线索二叉树进行中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Inorder</span><span class="params">(ThreadNode *T)</span>&#123;            <span class="comment">//T为根节点指针</span></span><br><span class="line">   <span class="keyword">for</span>(ThreadNode *p = Firstnode(T); p!=<span class="literal">NULL</span>; p = Nextnode(p))</span><br><span class="line">      visit(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>中序<strong>前驱</strong></li>
</ul>
<p>在中序线索二叉树中找到指定结点 *p 的中序前驱 pre</p>
<p>①若 p-&gt;ltag &#x3D;&#x3D; 1，则 pre &#x3D; p-&gt;lchild</p>
<p>②若 p-&gt;ltag &#x3D;&#x3D; 0，则 next &#x3D; p的左子树中最右下角结点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到以P为根的子树中，最后一个被中序遍历的结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Lastnode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">   <span class="comment">//循环找到最右下的结点（不一定是叶结点）</span></span><br><span class="line">   <span class="keyword">while</span>(p-&gt;rtag == <span class="number">0</span>)</span><br><span class="line">      p=p-&gt;rchild;</span><br><span class="line">   <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在中序线索二叉树中找到结点p的前驱结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Prenode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">   <span class="comment">//左子树最右下结点</span></span><br><span class="line">   <span class="keyword">if</span>(p-&gt;ltag==<span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> Lastnode(p-&gt;lchild);</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> p-&gt;lchild; <span class="comment">//ltag==1，直接返回前驱线索</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对中序线索二叉树进行逆向中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Revorder</span><span class="params">(ThreadNode *T)</span>&#123;            <span class="comment">//T为根节点指针</span></span><br><span class="line">   <span class="keyword">for</span>(ThreadNode *p = Lastnode(T); p!=<span class="literal">NULL</span>; p = Prenode(p))</span><br><span class="line">      visit(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-2-2-先序线索二叉树"><a href="#3-2-2-先序线索二叉树" class="headerlink" title="3.2.2 先序线索二叉树"></a>3.2.2 先序线索二叉树</h4><ul>
<li>先序<strong>后继</strong></li>
</ul>
<p>在先序线索二叉树中找到指定结点 *p 的先序后继 next</p>
<p>①若 p-&gt;rtag &#x3D;&#x3D; 1，则 next &#x3D; p-&gt;rchild</p>
<p>②若 p-&gt;rtag &#x3D;&#x3D; 0，则 next &#x3D; 左孩子(有左孩子) &#x2F; 右孩子(没有左孩子)</p>
<ul>
<li>先驱<strong>前驱</strong></li>
</ul>
<p>在先序线索二叉树中找到指定结点 *p 的先序前驱 pre</p>
<p>①若 p-&gt;ltag &#x3D;&#x3D; 1, 则 next &#x3D; p-&gt;lchild;</p>
<p>②若 p-&gt;ltag &#x3D;&#x3D; 0, 则 p必有左孩子，但是先序遍历中，左右子树的结点只可能是根的后继，不可能是前驱，所以不能从左右孩子里寻找p的先序前驱，（除非<strong>从头开始遍历 &#x2F; 三叉链表</strong>）</p>
<p>case1: 如果能够找到p的父节点，且p是左孩子 —— p的父节点就是p的前驱；</p>
<p>case2: 如果能够找到p的父节点，且p是右孩子，且其左兄弟为空 —— p的父节点就是p的前驱；</p>
<p>case3: 如果能够找到p的父节点，且p是右孩子，且其左兄弟非空 ——p的前驱为左兄弟子树中最后一个被先序遍历到的结点（根节点出发，先往右，右没有往左，找到最下一层的结点）；</p>
<p>case4: p没有父节点，即p为根节点，则p没有先序前驱</p>
<h4 id="3-2-3-后序线索二叉树"><a href="#3-2-3-后序线索二叉树" class="headerlink" title="3.2.3 后序线索二叉树"></a>3.2.3 后序线索二叉树</h4><ul>
<li>后序<strong>前驱</strong></li>
</ul>
<p>在后序线索二叉树中找到指定节点 *p 的后序前驱 pre</p>
<p>①若 p-&gt;ltag &#x3D;&#x3D; 1, 则 next &#x3D; p-&gt;lchild;</p>
<p>②若 p-&gt;ltag &#x3D;&#x3D; 0, 则 p 必有左孩子（不知道有没有右孩子）</p>
<p>case1: 若p有右孩子 ——— 后序前驱：右孩子</p>
<p>case2: 若p没有右孩子 ——— 后序前驱：左孩子</p>
<ul>
<li>后序<strong>后继</strong></li>
</ul>
<p>在后序线索二叉树中找到指定节点 *p 的后序后继 next</p>
<p>①若 p-&gt;rtag &#x3D;&#x3D; 1, 则 next &#x3D; p-&gt;rchild;</p>
<p>②若 p-&gt;rtag &#x3D;&#x3D; 0, 则 p 必有右孩子, 左孩子不知道, 但是在后序遍历中，左右子树中的结点只有可能是根的前驱，而不可能是根的后继，所以找不到后继，（除非<strong>从头开始遍历 &#x2F; 三叉链表</strong>）</p>
<p>case1: 如果能找到p的父节点，且p是右孩子 —— p的父节点即为其后继</p>
<p>case2: 如果能找到p的父节点，且p是左孩子，其右兄弟为空 —— p的父节点即为其后继</p>
<p>case3: 如果能找到p的父节点，且p是左孩子，其右兄弟非空 —— p的后继为其右兄弟子树中第一个被后序遍历的结点；</p>
<p>case4: p没有父节点，即p为根节点，则p没有后序后继；</p>
<h2 id="4-树的存储"><a href="#4-树的存储" class="headerlink" title="4.树的存储"></a>4.树的存储</h2><h3 id="4-1-双亲表示法（顺序存储）"><a href="#4-1-双亲表示法（顺序存储）" class="headerlink" title="4.1 双亲表示法（顺序存储）"></a>4.1 双亲表示法（顺序存储）</h3><p>双亲表示法：每个结点中保存指向双亲的“指针”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100         <span class="comment">//树中最多结点数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>                   <span class="comment">//树的结点定义</span></span><br><span class="line">   ElemType data;                 <span class="comment">//数据存储</span></span><br><span class="line">   <span class="type">int</span> parent;                    <span class="comment">//双亲位置域</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>                   <span class="comment">//树的类型定义</span></span><br><span class="line">   PTNode nodes[MAX_TREE_SIZE];   <span class="comment">//双亲表示</span></span><br><span class="line">   <span class="type">int</span> n;                         <span class="comment">//结点数</span></span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure>

<p>增：新增数据元素，无需按逻辑上的次序存储；（需要更改结点数n）</p>
<p>删（叶子结点）：将伪指针域设置为-1；或者 用后面的数据填补；（需要更改结点数n）</p>
<p>删（非叶子结点）：还需要删除该结点的子孙结点统统删除</p>
<p>查询：<strong>优点</strong>-查指定结点的双亲很方便；<strong>缺点</strong>-查指定结点的孩子只能从头遍历，空数据导致遍历更慢；</p>
<h3 id="4-2-孩子表示法（顺序-链式存储）"><a href="#4-2-孩子表示法（顺序-链式存储）" class="headerlink" title="4.2 孩子表示法（顺序+链式存储）"></a>4.2 孩子表示法（顺序+链式存储）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> child;              <span class="comment">//孩子结点在数组中的位置</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span>    <span class="comment">// 下一个孩子</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   ElemType data;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">firstChild</span>;</span>    <span class="comment">// 第一个孩子</span></span><br><span class="line">&#125;CTBox;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">   <span class="type">int</span> n, r;   <span class="comment">// 结点数和根的位置</span></span><br><span class="line">&#125;CTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-3-孩子兄弟表示法（链式存储）"><a href="#4-3-孩子兄弟表示法（链式存储）" class="headerlink" title="4.3 孩子兄弟表示法（链式存储）"></a>4.3 孩子兄弟表示法（链式存储）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//数据域</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="comment">//第一个孩子和右兄弟指针, *firstchild 看作左指针，*nextsibling看作右指针</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>, *<span class="title">nextsibling</span>;</span></span><br><span class="line">&#125;CSNode. *CSTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>孩子兄弟表示法</strong>也可以相当于<strong>把树转化成二叉树</strong></p>
<p><strong>森林和二叉树的转换</strong>：把各个树的根节点视为兄弟关系</p>
<h2 id="5-树和森林的遍历"><a href="#5-树和森林的遍历" class="headerlink" title="5.树和森林的遍历"></a>5.树和森林的遍历</h2><h3 id="5-1-树的遍历"><a href="#5-1-树的遍历" class="headerlink" title="5.1 树的遍历"></a>5.1 树的遍历</h3><ul>
<li>先根遍历：若树非空，先访问根结点，再依次对每棵子树进行先根遍历；（与对应二叉树的先序遍历序列相同）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(TreeNode *R)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(R!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      visit(R);            <span class="comment">//访问根节点</span></span><br><span class="line">      <span class="keyword">while</span>(R还有下一个子树T)</span><br><span class="line">         PreOrder(T);      <span class="comment">//先跟遍历下一个子树</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>后根遍历：若树非空，先依次对每棵子树进行后根遍历，最后再返回根节点；（与对应二叉树的中序遍历序列相同）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(TreeNode *R)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(R!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="keyword">while</span>(R还有下一个子树T)</span><br><span class="line">         PostOrder(T);      <span class="comment">//后跟遍历下一个子树</span></span><br><span class="line">      visit(R);             <span class="comment">//访问根节点</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>层序遍历（队列实现）（广度优先遍历）</li>
</ul>
<p>若树非空，则根结点入队；</p>
<p>若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队；</p>
<p>重复以上操作直至队尾为空；</p>
<h3 id="5-2-森林的遍历"><a href="#5-2-森林的遍历" class="headerlink" title="5.2 森林的遍历"></a>5.2 森林的遍历</h3><ul>
<li>先序遍历：等同于依次对各个树进行<strong>先根遍历</strong>；也可以先转换成与之对应的二叉树，对二叉树进行先序遍历；</li>
<li>中序遍历：等同于依次对各个树进行<strong>后根遍历</strong>；也可以先转换成与之对应的二叉树，对二叉树进行中序遍历；</li>
</ul>
<h2 id="6-树与二叉树的应用"><a href="#6-树与二叉树的应用" class="headerlink" title="6.树与二叉树的应用"></a>6.树与二叉树的应用</h2><h3 id="6-1二叉排序树-BST"><a href="#6-1二叉排序树-BST" class="headerlink" title="6.1二叉排序树(BST)"></a>6.1二叉排序树(BST)</h3><p><strong>二叉排序树</strong>：左子树结点值 &lt; 根结点值 &lt; 右子树结点值（左子树、右子树同样是二叉排序树）</p>
<h4 id="6-1-1-查找"><a href="#6-1-1-查找" class="headerlink" title="6.1.1 查找"></a>6.1.1 查找</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> key;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BSTNode, *BSTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在二叉排序树中查找值为key的结点（非递归）</span></span><br><span class="line"><span class="comment">//最坏空间复杂度：O(1)</span></span><br><span class="line">BSTNode *<span class="title function_">BST_Search</span><span class="params">(BSTree T, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">   <span class="keyword">while</span>(T!=<span class="literal">NULL</span> &amp;&amp; key!=T-&gt;key)&#123;        <span class="comment">//若树空或等于跟结点值，则结束循环</span></span><br><span class="line">      <span class="keyword">if</span>(key&lt;T-&gt;key)       <span class="comment">//值小于根结点值，在左子树上查找</span></span><br><span class="line">         T = T-&gt;lchild;</span><br><span class="line">      <span class="keyword">else</span>                  <span class="comment">//值大于根结点值，在右子树上查找</span></span><br><span class="line">         T = T-&gt;rchild;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在二叉排序树中查找值为key的结点（递归）</span></span><br><span class="line"><span class="comment">//最坏空间复杂度：O(n)</span></span><br><span class="line">BSTNode *<span class="title function_">BSTSearch</span><span class="params">(BSTree T, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">if</span>(Key == T-&gt;key)</span><br><span class="line">      <span class="keyword">return</span> T;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; T-&gt;key)</span><br><span class="line">      <span class="keyword">return</span> BSTSearch(T-&gt;lchild, key);</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> BSTSearch(T-&gt;rchild, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-1-2-插入"><a href="#6-1-2-插入" class="headerlink" title="6.1.2 插入"></a>6.1.2 插入</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在二叉排序树中插入关键字为k的新结点（递归）</span></span><br><span class="line"><span class="comment">//最坏空间复杂度：O(n)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BST_Insert</span><span class="params">(BSTree &amp;T, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;           <span class="comment">//原树为空，新插入的结点为根结点</span></span><br><span class="line">      T = (BSTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">      T-&gt;key = k;</span><br><span class="line">      T-&gt;lchild = T-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;                       <span class="comment">//插入成功</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(K == T-&gt;key)               <span class="comment">//树中存在相同关键字的结点，插入失败</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(k &lt; T-&gt;key)                 </span><br><span class="line">      <span class="keyword">return</span> BST_Insert(T-&gt;lchild,k);</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> BST_Insert(T-&gt;rchild,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新插入的结点一定是叶子结点</span></span><br></pre></td></tr></table></figure>

<h4 id="6-1-3-二叉排序树的构造"><a href="#6-1-3-二叉排序树的构造" class="headerlink" title="6.1.3 二叉排序树的构造"></a>6.1.3 二叉排序树的构造</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照str[]中的关键字序列建立二叉排序树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Crear_BST</span><span class="params">(BSTree &amp;T, <span class="type">int</span> str[], <span class="type">int</span> n)</span>&#123;</span><br><span class="line">   T = <span class="literal">NULL</span>;                     <span class="comment">//初始时T为空树</span></span><br><span class="line">   <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">      BST_Insert(T,str[i]);     <span class="comment">//依次将每个关键字插入到二叉排序树中</span></span><br><span class="line">      i++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-1-4-删除"><a href="#6-1-4-删除" class="headerlink" title="6.1.4 删除"></a>6.1.4 删除</h4><p>①若被删除结点z是叶子结点，则直接删除</p>
<p>②若被删除结点z不是叶子结点只有一棵左子树或右子树，则让z的子树替代z的位置即可</p>
<p>③若被删除结点z有左、右两棵子树，则令z的直接后继（或直接前驱）替代z，然后从二叉排序树中删除这个直接后继（或直接前驱），这样就转换成了第一或第二种情况。</p>
<p>z的直接后继：z的右子树中最左下的结点（该结点一定没有左子树）</p>
<p>z的直接前驱：z的左子树中最右下的结点（该结点一定没有右子树）</p>
<h4 id="6-1-5-查找效率分析"><a href="#6-1-5-查找效率分析" class="headerlink" title="6.1.5 查找效率分析"></a>6.1.5 查找效率分析</h4><p>查找长度：查找运算中，需要对比关键字的次数，反映了查找操作时间复杂度；</p>
<p>查找成功的平均查找长度ASL</p>
<p>查找失败的平均查找长度ASL</p>
<h3 id="6-2-平衡二叉树-AVL"><a href="#6-2-平衡二叉树-AVL" class="headerlink" title="6.2 平衡二叉树(AVL)"></a>6.2 平衡二叉树(AVL)</h3><p><strong>平衡二叉树</strong>：树上任一结点的左子树和右子树的高度之差不超过1。</p>
<blockquote>
<p><strong>结点的平衡因子</strong> &#x3D; 左子树高度 - 右子树高</p>
<p>平衡二叉树<strong>平衡因子</strong>绝对值不大于1</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//平衡二叉树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> key;         <span class="comment">//数据域</span></span><br><span class="line">   <span class="type">int</span> balance;     <span class="comment">//平衡因子</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> *<span class="title">lchild</span>;</span> *rchild; </span><br><span class="line">&#125;AVLNode, *AVLTree;</span><br></pre></td></tr></table></figure>

<p>在<strong>二叉排序树</strong>中插入新结点后，如何保持平衡？</p>
<blockquote>
<p>从插入点往回找到第一个不平衡结点，调整以该结点为根的子树。</p>
<p>在插入操作中，只要<strong>将最小不平衡子树调整平衡</strong>，则其他祖先结点都会恢复平衡</p>
</blockquote>
<h4 id="6-2-1-调整最小不平衡子树"><a href="#6-2-1-调整最小不平衡子树" class="headerlink" title="6.2.1 调整最小不平衡子树"></a>6.2.1 调整最小不平衡子树</h4><p><strong>LL</strong>——在A的左孩子的左子树中插入导致不平衡</p>
<p>调整： A的<strong>左孩子</strong>结点<strong>右上旋</strong>代替A成为根结点</p>
<p><strong>RR</strong>——在A的右孩子的右子树中插入导致不平衡</p>
<p>调整： A的<strong>右孩子</strong>结点<strong>左上旋</strong>代替A成为根结点</p>
<p><strong>LR</strong>——在A的左孩子的右子树中插入导致不平衡</p>
<p>调整： A的<strong>左孩子的右孩子</strong>，<strong>先左上旋</strong>替代A的左孩子，<strong>再右上旋</strong>替代A结点</p>
<p><strong>RL</strong>——在A的右孩子的左子树中插入导致不平衡</p>
<p>调整： A的<strong>右孩子的左孩子</strong>，<strong>先右上旋</strong>替代A的右孩子，<strong>再左上旋</strong>替代A结点</p>
<h4 id="6-2-2-平衡二叉树的查找与效率分析"><a href="#6-2-2-平衡二叉树的查找与效率分析" class="headerlink" title="6.2.2 平衡二叉树的查找与效率分析"></a>6.2.2 平衡二叉树的查找与效率分析</h4><p>若树高为h，则最坏情况下，查找一个关键字最多需要对比h次，即查找操作的时间复杂度不可能超过O(h);</p>
<p>平衡二叉树的最大深度为O(log₂n)，平衡二叉树的平均查找长度为O(log₂n)</p>
<h3 id="6-3-哈夫曼树"><a href="#6-3-哈夫曼树" class="headerlink" title="6.3 哈夫曼树"></a>6.3 哈夫曼树</h3><h4 id="6-3-1-带权路径长度"><a href="#6-3-1-带权路径长度" class="headerlink" title="6.3.1 带权路径长度"></a>6.3.1 带权路径长度</h4><p>结点的权：有某种现实含义的数值（如：表示结点的重要性等）</p>
<p><strong>结点的带权路径长度</strong>：从树的根到该结点的路径长度（经过的边数）与该结点上权值的乘积</p>
<p><strong>树的带权路径长度</strong>：树中所有叶结点的带权路径长度之和（WPL）</p>
<h4 id="6-3-2-哈夫曼树的定义"><a href="#6-3-2-哈夫曼树的定义" class="headerlink" title="6.3.2 哈夫曼树的定义"></a>6.3.2 哈夫曼树的定义</h4><p>在含有n个带权叶结点的二叉树中，其中<strong>带权路径最小（WPL）的二叉树</strong>成为<strong>哈夫曼树</strong>，也称<strong>最优二叉树</strong></p>
<h4 id="6-3-3-哈夫曼树的构造"><a href="#6-3-3-哈夫曼树的构造" class="headerlink" title="6.3.3 哈夫曼树的构造"></a>6.3.3 哈夫曼树的构造</h4><p>给定n个权值分别为w₁,w₂,…,wn的结点，构造哈夫曼树的算法描述如下：</p>
<p>① 将n个结点作为n棵仅含有一个根结点的二叉树，构成森林F；</p>
<p>② 生成一个新结点，并从森林F中找出根结点权值最小的两棵树作为新结点的左右子树，且令新结点的权值为两棵子树的根结点的权值之和；</p>
<p>③ 从森林F中删除选择的这两棵树，并将新生成的树加入到F中；</p>
<p>④ 重复②和③的步骤，直到F中只有一棵树为止，此时即为哈夫曼树。</p>
<p><strong>哈夫曼树的性质</strong>：</p>
<p>①每个初始结点都会成为叶结点，双支结点都为新生成的结点；</p>
<p>②权值越大离根结点越近，权值越小离根结点越远；</p>
<p>③ 哈夫曼树中没有度为1的结点；</p>
<p>④n个叶子结点的哈夫曼树的结点总数为2n-1，其中度为2的结点数为n-1，这n-1个结点都是新结点。</p>
<h4 id="6-3-4-哈夫曼编码"><a href="#6-3-4-哈夫曼编码" class="headerlink" title="6.3.4 哈夫曼编码"></a>6.3.4 哈夫曼编码</h4><p>在数据通信中，若对每个字符用<strong>相等长度的二进制位</strong>表示，称这种编码方式为<strong>固定长度编码</strong>。</p>
<p>若允许对不同字符用<strong>不等长的二进制位</strong>表示，则这种编码方式称为<strong>可变长度编码</strong>。</p>
<p>若编码中没有一个编码是其他编码的前缀，则称这样的编码为<strong>前缀编码</strong>。</p>
<p><strong>可变长度编码比固定长度编码要好得多</strong>，其特点是对频率高的字符赋以短编码，而对频率较低的字符则赋以较长一些的编码，从而可以使字符的平均编码长度减短，起到<strong>压缩数据</strong>的效果。</p>
<p><strong>哈夫曼编码是一种被广泛应用而且非常有效的数据压缩编码。</strong></p>
<p>将字符集中的每个字符作为一个叶子结点，各个字符出现的频率作为结点的权值，构造哈夫曼树（哈夫曼树不唯一，哈夫曼编码不唯一）。</p>
<h1 id="第六章：图"><a href="#第六章：图" class="headerlink" title="第六章：图"></a>第六章：图</h1><h2 id="1-图的基本概念"><a href="#1-图的基本概念" class="headerlink" title="1.图的基本概念"></a>1.图的基本概念</h2><p>图G由顶点集V和边集E组成，记为G &#x3D; (V, E)。</p>
<p>其中V(G)表示图G中顶点的有限非空集；E(G)表示图G中顶点之间的关系（边）集合。</p>
<p>若V &#x3D; {v1, v2, … , vn}，则用|V|表示图G中顶点的个数，也称图G的阶，E &#x3D; {(u, v) | u∈V, v∈V}，用|E|表示图G中边的条数。  </p>
<p>注意：线性表可以是空表，树可以是空树，但图不可以是空，即<strong>V一定是非空集</strong>。</p>
<p>若E是无向边（简称 边）的有限集合时，则图G为<strong>无向图</strong>；边是顶点的无序对，记为(v, w)或(w, v)。</p>
<p>若E是有向边（也称 弧）的有限集合时，则图G为<strong>有向图</strong>；弧是顶点的有序对，记为&lt;v, w&gt;。</p>
<p><strong>简单图</strong>：</p>
<blockquote>
<p>① 不存在重复边；</p>
<p>② 不存在顶点到自身的边  </p>
<p>（本章只讨论简单图）</p>
</blockquote>
<p><strong>多重图</strong>：</p>
<blockquote>
<p>图G中某两个结点之间的边数多于一条，又允许顶点通过同一条边和自己关联，则G为多重图  </p>
</blockquote>
<p><strong>顶点的度、入度、出度</strong>：</p>
<p>对于<strong>无向图</strong>：</p>
<blockquote>
<p>顶点v的度是指依附于该顶点的边的条数，记为TD(v)。  </p>
<p>所有顶点的度之和等于 2|E|</p>
</blockquote>
<p>对于<strong>有向图</strong>：</p>
<blockquote>
<p>入度是以顶点v为终点的有向边的数目，记为ID(v)；</p>
<p>出度是以顶点v为起点的有向边的数目，记为OD(v)。</p>
<p>顶点v的度等于其入度和出度之和，即TD(v) &#x3D; ID(v) + OD(v)。  </p>
<p>所有顶点的入度之和 &#x3D; 所有顶点的出度之和 &#x3D; |E|</p>
</blockquote>
<p><strong>顶点- 顶点的关系描述</strong>：</p>
<blockquote>
<ul>
<li><p>路径——顶点Vp到顶点Vq之间的一条路径是指顶点序列</p>
</li>
<li><p>回路——第一个顶点和最后一个顶点相同的路径称为回路或环</p>
</li>
<li><p>简单路径——在路径序列中，顶点不重复出现的路径称为简单路径。</p>
</li>
<li><p>简单回路——除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。</p>
</li>
<li><p>路径长度——路径上边的数目</p>
</li>
<li><p>点到点的距离——从顶点u出发到顶点v的最短路径若存在，则此路径的长度称为从u到v的距离。若从u到v根本不存在路径，则记该距离为无穷（∞）。</p>
</li>
<li><p>无向图中，若从顶点v到顶点w有路径存在，则称v和w是<strong>连通</strong>的</p>
</li>
<li><p>有向图中，若从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是<strong>强连通</strong>的</p>
</li>
</ul>
</blockquote>
<p><strong>连通图、强连通图</strong></p>
<p>若图G中任意两个顶点都是连通的，则称图G为连通图，否则称为非连通图</p>
<blockquote>
<p>对于n个顶点的无向图G，</p>
<p>若G是连通图，则最少有 n-1 条边，</p>
<p>若G是非连通图，则最多可能有 (n-1)(n-2)&#x2F;2 条边  </p>
</blockquote>
<p>若图中任何一对顶点都是强连通的，则称此图为强连通图</p>
<blockquote>
<p>对于n个顶点的有向图G，若G是强连通图，则最少有 n 条边（形成回路）  </p>
</blockquote>
<p><strong>子图、生成子图</strong></p>
<blockquote>
<p>设有两个图G &#x3D; (V, E)和G‘ &#x3D; (V’, E‘)，若V¢是V的子集，且E’是E的子集，则称G‘是G的<strong>子图</strong>。<br>若有满足V(G’) &#x3D; V(G)的子图G‘，则称其为G的生成<strong>子图</strong>。</p>
</blockquote>
<p><strong>连通分量、强连通分量</strong></p>
<blockquote>
<p>极大连通子图：子图必须连通，且包含尽可能多的顶点和边</p>
<p>极大强连通子图：子图必须强连通，同时保留尽可能多的边</p>
<p>无向图中的<strong>极大连通子图</strong>称为<strong>连通分量</strong>,  有向图中的<strong>极大强连通子图</strong>称为有向图的<strong>强连通分量</strong>  </p>
</blockquote>
<p><strong>生成树</strong></p>
<blockquote>
<p><strong>连通图</strong>的<strong>生成树</strong>是<strong>包含图中全部顶点</strong>的一个<strong>极小连通子图</strong>（边要在连通的前提下尽可能少）。<br>若图中顶点数为n，则它的生成树含有 n-1 条边。对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。  </p>
</blockquote>
<p><strong>生成森林</strong></p>
<blockquote>
<p>在<strong>非连通图</strong>中，<strong>连通分量的生成树</strong>构成了非连通图的生成森林。  </p>
</blockquote>
<p><strong>边的权、带权图&#x2F;网</strong></p>
<blockquote>
<p>边的权——在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值。</p>
<p>带权图&#x2F;网——边上带有权值的图称为带权图，也称网。</p>
<p>带权路径长度——当图是带权图时，一条路径上所有边的权值之和，称为该路径的带权路径长度  </p>
</blockquote>
<p><strong>几种特殊的图</strong></p>
<blockquote>
<p><strong>无向完全图</strong>——无向图中任意两个顶点之间都存在边  </p>
<p><strong>有向完全图</strong>——有向图中任意两个顶点之间都存在方向相反的两条弧  </p>
<p><strong>稀疏图</strong>——边数很少的图  </p>
<p><strong>稠密图</strong>——边数很多的图</p>
<p>（没有绝对的界限，一般来说，|E| &lt; |V|log|V|时，可以将G视为稀疏图  ）  </p>
<p><strong>树</strong>——不存在回路，且连通的无向图</p>
<p><strong>有向树</strong>——一个顶点的入度为0、其余顶点的入度均为1的有向图，称为有向树。  </p>
</blockquote>
<h2 id="2-图的存储"><a href="#2-图的存储" class="headerlink" title="2.图的存储"></a>2.图的存储</h2><h3 id="2-1-邻接矩阵"><a href="#2-1-邻接矩阵" class="headerlink" title="2.1 邻接矩阵"></a>2.1 邻接矩阵</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>A</strong></td>
<td align="center">0</td>
<td align="center">1（A和B之间存在边）</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><strong>B</strong></td>
<td align="center">1（B和A之间存在边）</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center"><strong>C</strong></td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  MaxVertexNum 100                   <span class="comment">//顶点数目的最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> Vex[MaxVertexNum];                 <span class="comment">//顶点表</span></span><br><span class="line">    <span class="comment">//也可以用bool或枚举类型来表示边</span></span><br><span class="line">    <span class="type">int</span> Edge[MaxVertexNum][MaxVertexNum];   <span class="comment">//邻接矩阵，边表</span></span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;                      <span class="comment">//图的当前顶点数和边数/弧数</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure>

<p><strong>邻接矩阵的空间复杂度只和顶点数相关，适合用于存储稠密图。</strong></p>
<p><strong>无向图</strong>：</p>
<blockquote>
<p>第i个结点的度 &#x3D; 第i行（或第i列）的非零元素个数  </p>
</blockquote>
<p><strong>有向图</strong>：</p>
<blockquote>
<p>第i个结点的出度 &#x3D; 第i行的非零元素个数</p>
<p>第i个结点的入度 &#x3D; 第i列的非零元素个数</p>
<p>第i个结点的度 &#x3D; 第i行、第i列的非零元素个数之和  </p>
</blockquote>
<p><strong>邻接矩阵法存储带权图（网）</strong>  </p>
<blockquote>
<p>存在边——边上的权值。</p>
<p>不存在边——用∞来表示，在代码中，可以用int的上限来表示“无穷”。</p>
</blockquote>
<p><strong>邻接矩阵的性质</strong></p>
<blockquote>
<p>设图G的邻接矩阵为A（矩阵元素为0&#x2F;1），则 A^n 的元素 A^n[i][j] 等于由顶点 i 到顶点 j 的长度为 n 的路径的数目（说明i）</p>
</blockquote>
<h3 id="2-2-邻接表"><a href="#2-2-邻接表" class="headerlink" title="2.2 邻接表"></a>2.2 邻接表</h3><p>（顺序+链式存储）</p>
<table>
<thead>
<tr>
<th align="center">data</th>
<th align="center">first</th>
</tr>
</thead>
<tbody><tr>
<td align="center">(0)A</td>
<td align="center">-&gt;(1)B  -&gt;(2)C  [存在A指向B与A指向C的边]</td>
</tr>
<tr>
<td align="center">(1)B</td>
<td align="center">-&gt;(0)A</td>
</tr>
<tr>
<td align="center">(2)C</td>
<td align="center">-&gt;(0)A</td>
</tr>
</tbody></table>
<p>边的先后顺序可以改变，所以邻接表表示方法并不唯一。</p>
<p><strong>邻接表适合用于稀疏图</strong>。</p>
<h3 id="2-3-十字链表"><a href="#2-3-十字链表" class="headerlink" title="2.3 十字链表"></a>2.3 十字链表</h3><p>（<strong>存储有向图</strong>）</p>
<p>①画邻接表</p>
<p>②增加弧结点的域</p>
<p>③自己指向自己</p>
<table>
<thead>
<tr>
<th>顶点结点</th>
<th>data</th>
<th>firstin</th>
<th>firstout</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>数据域</td>
<td>该顶点作为弧头的第一条弧</td>
<td>该顶点作为弧尾的第一条弧</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>弧结点</th>
<th>尾</th>
<th>头</th>
<th>同头</th>
<th>同尾</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>弧尾顶点编号</td>
<td>弧头顶点编号</td>
<td>弧头相同的下一条弧</td>
<td>弧尾相同的下一跳弧</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>用箭头指（没有就空^）</td>
<td>用箭头指（没有就空^）</td>
</tr>
</tbody></table>
<h3 id="2-4-邻接多重表"><a href="#2-4-邻接多重表" class="headerlink" title="2.4 邻接多重表"></a>2.4 邻接多重表</h3><p>（<strong>存储无向图</strong>）</p>
<table>
<thead>
<tr>
<th>顶点结点</th>
<th>data</th>
<th>firstedge</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>数据域</td>
<td>与该顶点相连的第一条边（用箭头指）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>弧结点</th>
<th>i</th>
<th>iLink</th>
<th>j</th>
<th>jLink</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>边的顶点编号</td>
<td>依附于顶点 i 的下一条边</td>
<td>边的顶点编号</td>
<td>依附于顶点 j 的下一条边</td>
</tr>
<tr>
<td></td>
<td></td>
<td>用箭头连线（没有就空^）</td>
<td></td>
<td>用箭头连线（没有就空^）</td>
</tr>
</tbody></table>
<h2 id="3-图的基本操作"><a href="#3-图的基本操作" class="headerlink" title="3.图的基本操作"></a>3.图的基本操作</h2><p><strong>Adjacent(G,x,y)</strong>：判断图G是否存在边&lt;x, y&gt;或(x, y)。</p>
<p><strong>Neighbors(G,x)</strong>：列出图G中与结点x邻接的边。</p>
<p><strong>InsertVertex(G,x)</strong>：在图G中插入顶点x。</p>
<p><strong>DeleteVertex(G,x)</strong>：从图G中删除顶点x。</p>
<p><strong>AddEdge(G,x,y)</strong>：若无向边(x, y)或有向边&lt;x, y&gt;不存在，则向图G中添加该边。</p>
<p><strong>RemoveEdge(G,x,y)</strong>：若无向边(x, y)或有向边&lt;x, y&gt;存在，则从图G中删除该边。</p>
<p><strong>FirstNeighbor(G,x)</strong>：求图G中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点或图中不存在x，则返回-1。</p>
<p><strong>NextNeighbor(G,x,y)</strong>：假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1。</p>
<p><strong>Get_edge_value(G,x,y)</strong>：获取图G中边(x, y)或&lt;x, y&gt;对应的权值。</p>
<p><strong>Set_edge_value(G,x,y,v)</strong>：设置图G中边(x, y)或&lt;x, y&gt;对应的权值为v。  </p>
<h2 id="4-图的遍历算法"><a href="#4-图的遍历算法" class="headerlink" title="4.图的遍历算法"></a>4.图的遍历算法</h2><h3 id="4-1-广度优先遍历（BFS）"><a href="#4-1-广度优先遍历（BFS）" class="headerlink" title="4.1 广度优先遍历（BFS）"></a>4.1 广度优先遍历（BFS）</h3><p> 广度优先搜索（BFS）类似于二叉树的层序遍历算法。</p>
<p>它的基本思想是：首项访问起始顶点v，接着由v出发，依次访问v的各个未访问过的邻接顶点w1,w2,w3,…,wi，然后依次访问它们所有未被访问过的邻接顶点……以此类推，知道所有顶点都被访问过位置。</p>
<p>类似的思想还将应用于Dijkstra单源最短路径算法和prime最小生成树算法。</p>
<p>广度优先搜索生成的树为广度优先生成树</p>
<p><strong>要点</strong>：</p>
<p>①找到与⼀个顶点相邻的所有顶点</p>
<p>②标记哪些顶点被访问过</p>
<p>③需要⼀个辅助队列  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="type">bool</span> visited[MaxVertexNum];    <span class="comment">//标记访问数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFSTraverse</span><span class="params">(Graph G)</span>      <span class="comment">//对图G进行广度优先遍历</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">// 遍历一下所有的顶点</span></span><br><span class="line">        visited[i] = <span class="literal">false</span>;    <span class="comment">// 将所有的顶点都设为未访问标志。</span></span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">// 从0号顶点开始遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[i])        <span class="comment">// 对每个连通分量调用一次BFS</span></span><br><span class="line">            BFS(G,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//广度优先遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span>        <span class="comment">//从顶点v出发</span></span><br><span class="line">&#123;</span><br><span class="line">    visit(v);                  <span class="comment">//访问初始顶点</span></span><br><span class="line">    visited[V]=<span class="literal">true</span>;           <span class="comment">//对v做已访问标记</span></span><br><span class="line">    EnQueue(Q,v);              <span class="comment">//顶点v入队列Q</span></span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        Dequeue(Q,v);          <span class="comment">//顶点v出队列</span></span><br><span class="line">        <span class="keyword">for</span>(w=FirstNeighbor(G,v);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,v,w))</span><br><span class="line">            <span class="comment">//检测v所有邻接点</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[w])        <span class="comment">//w为v的尚未访问的邻接顶点</span></span><br><span class="line">            &#123;</span><br><span class="line">                visit(w);          <span class="comment">//访问顶点w</span></span><br><span class="line">                visited[w]=<span class="literal">true</span>;   <span class="comment">//对w做已访问标记</span></span><br><span class="line">                EnQueue(Q,w);      <span class="comment">//顶点w入队列</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-深度优先遍历（DFS）"><a href="#4-2-深度优先遍历（DFS）" class="headerlink" title="4.2 深度优先遍历（DFS）"></a>4.2 深度优先遍历（DFS）</h3><p>与广度优先搜索不同，深度优先搜索(DFS)(DFS)类似于树的先序遍历。正如其名称中所暗含的意思一样，这种搜索算法所遵循的策略是尽可能“深”的搜索一个图。</p>
<p>它的基本思想如下：首先访问图中某一起始顶点v，然后从v出发，访问与v邻接且未被访问的任一定点w1，再访问与w1邻接且未被访问的任意顶点w2，……重复上述过程。当不能再继续向下访问时，一次退回到最近被访问的顶点，若他还有邻接顶点未被访问过，则从该点开始继续上述搜索过程，知道搜索顶点均被访问过为止。</p>
<p>深度优先搜索生成的树为深度优先生成树</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 100</span></span><br><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];   <span class="comment">//访问标记数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSTraverse</span><span class="params">(Graph G)</span>       <span class="comment">//对图G进行深度优先遍历</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;i++)</span><br><span class="line">        visited[v]=<span class="literal">false</span>;       <span class="comment">//初始化已访问标记数据</span></span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;i++)     <span class="comment">//从v=0开始遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[v])</span><br><span class="line">            DFS(G,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span>         <span class="comment">//从顶点v出发，深度优先遍历图G</span></span><br><span class="line">&#123;</span><br><span class="line">    visit(v);                   <span class="comment">//访问顶点v</span></span><br><span class="line">    visited[v]=<span class="literal">true</span>;            <span class="comment">//设已访问标记</span></span><br><span class="line">    <span class="keyword">for</span>(w=FirstNeighbor(G,v);w&gt;=<span class="number">0</span>;w=NextNeighor(G,v,w))</span><br><span class="line">        <span class="keyword">if</span>(!visited[w])         <span class="comment">//w为u的尚未访问的邻接顶点</span></span><br><span class="line">            DFS(G,w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-最小生成树"><a href="#5-最小生成树" class="headerlink" title="5.最小生成树"></a>5.最小生成树</h2><h3 id="5-1-最小生成树的概念"><a href="#5-1-最小生成树的概念" class="headerlink" title="5.1 最小生成树的概念"></a>5.1 最小生成树的概念</h3><p>对于⼀个带权连通⽆向图G &#x3D; (V, E)，⽣成树不同，每棵树的权（即树中所有边上的权值之和）也可能不同。设R为G的所有⽣成树的集合，若T为R中边的权值之和最⼩的⽣成树，则T称为G的最⼩⽣成树（Minimum-Spanning-Tree, MST）   </p>
<ul>
<li><p>最⼩⽣成树可能有多个，但边的权值之和总是唯⼀且最⼩的</p>
</li>
<li><p>最⼩⽣成树的边数 &#x3D; 顶点数 - 1。砍掉⼀条则不连通，增加⼀条边则会出现回路  </p>
</li>
<li><p>如果⼀个连通图本身就是⼀棵树，则其最⼩⽣成树就是它本身 </p>
</li>
<li><p>只有连通图才有⽣成树，⾮连通图只有⽣成森林</p>
</li>
</ul>
<h3 id="5-2-Prim算法"><a href="#5-2-Prim算法" class="headerlink" title="5.2 Prim算法"></a>5.2 Prim算法</h3><p>Prim 算法（普⾥姆）：</p>
<p>从某⼀个顶点开始构建⽣成树；</p>
<p>每次将代价最⼩的新顶点纳⼊⽣成树，直到所有顶点都纳⼊为⽌。  </p>
<p>时间复杂度：O(|V|²)，适用于边稠密图</p>
<h3 id="5-3-Kruskal算法"><a href="#5-3-Kruskal算法" class="headerlink" title="5.3 Kruskal算法"></a>5.3 Kruskal算法</h3><p>Kruskal 算法（克鲁斯卡尔）：</p>
<p>每次选择⼀条权值最⼩的边，使这条边的两头连通（原本已经连通的就不选），直到所有结点都连通。</p>
<p>时间复杂度：O(|E|log₂|E|)，适用于边稀疏图</p>
<h2 id="6-最短路径算法"><a href="#6-最短路径算法" class="headerlink" title="6.最短路径算法"></a>6.最短路径算法</h2><h3 id="6-1-BFS算法"><a href="#6-1-BFS算法" class="headerlink" title="6.1 BFS算法"></a>6.1 BFS算法</h3><p>（无权图的<strong>单源最短路径</strong>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求顶点u到其他顶点的最短路径</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS_MIN_Ditance</span><span class="params">(Graph G,<span class="type">int</span> u)</span>&#123;</span><br><span class="line">    <span class="comment">//d[i]表示从u到i结点的最短路径</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)&#123;</span><br><span class="line">        d[i]=∞;          <span class="comment">//初始化路径长度（∞可以用int最大值代替）</span></span><br><span class="line">        path[i]=<span class="number">-1</span>;      <span class="comment">//最短路径从哪个顶点过来</span></span><br><span class="line">    &#125;</span><br><span class="line">    d[u]=<span class="number">0</span>;              <span class="comment">//把顶点u设为0</span></span><br><span class="line">    visited[u]=TRUE;</span><br><span class="line">    EnQueue(Q,u);</span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q))&#123;</span><br><span class="line">        DeQueue(Q,v);              <span class="comment">//顶点u出队列</span></span><br><span class="line">        <span class="keyword">for</span>(w=FirstNeighbor(G,v);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,v,w))</span><br><span class="line">            <span class="keyword">if</span>(!visited[w])        <span class="comment">//w为u的尚未访问的邻接顶点</span></span><br><span class="line">            &#123;</span><br><span class="line">                d[w]=d[u]+<span class="number">1</span>;       <span class="comment">//路径长度+1</span></span><br><span class="line">                path[w]=u;         <span class="comment">//最短路径应从u到w</span></span><br><span class="line">                visited[w]=TRUE;   <span class="comment">//设已访问标记</span></span><br><span class="line">                EnQueue(Q,w);      <span class="comment">//顶点w入队</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-Dijkstra算法"><a href="#6-2-Dijkstra算法" class="headerlink" title="6.2 Dijkstra算法"></a>6.2 Dijkstra算法</h3><p>迪杰斯特拉（1972年图灵奖得主）</p>
<p>（无权图、带权图的<strong>单源最短路径</strong>）</p>
<p>和Prime是一样的，不过Prime是最小生成树，计算的是将这些点连起来花费的最小代价。而Dijkstra计算的是，从某点开始到其他点花费的最小代价。</p>
<p>但是<strong>Dijkstra算法不适用于有负权值的带权图</strong></p>
<p>①<strong>从V₀开始，初始化三个数组信息</strong>。</p>
<p>令 final[0]&#x3D;ture; dist[0]&#x3D;0; path[0]&#x3D;-1；</p>
<p>其余顶点final[k]&#x3D;false; dist[k]&#x3D;arcs[0][k]; path[k]&#x3D; (arcs[0][k]&#x3D;&#x3D;∞) ? -1 : 0  </p>
<blockquote>
<p><strong>final[]</strong> ：标记各顶点是否已找到最短路径</p>
<p><strong>dist[]</strong>  ：最短路径长度</p>
<p><strong>path[]</strong> ：路径上的前驱</p>
</blockquote>
<p>②<strong>循环遍历所有结点，找到还没确定最短路径，且dist 最⼩的顶点Vi，令final[i]&#x3D;ture</strong>。  </p>
<p>③<strong>检查所有邻接⾃ Vi 的顶点，若其 final 值为false，则更新 dist 和 path 信息</strong> 。</p>
<blockquote>
<p>若 final[j]&#x3D;&#x3D;false 且 dist[i]+arcs[i][j] &lt; dist[j]，</p>
<p>则令 dist[j]&#x3D;dist[i]+arcs[i][j] ; path[j]&#x3D;i。</p>
<p>（注： arcs[i][j]表示 Vi 到 Vj 的弧的权值）  </p>
</blockquote>
<p>④<strong>重复②③直至final全为true</strong></p>
<h3 id="6-3-Floyd算法"><a href="#6-3-Floyd算法" class="headerlink" title="6.3 Floyd算法"></a>6.3 Floyd算法</h3><p>弗洛伊德（1978年图灵奖得主）</p>
<p>（无权图、带权图的<strong>各顶点间的最短路径</strong>）</p>
<p>Floyd<strong>可以用于有负权值的带权图</strong>。</p>
<p>Floyd<strong>不能解决带有“负权回路”（有负权值的边组成回路）的图</strong>，这种图可能没有最短路径。</p>
<p>对于n个顶点的图G，求任意⼀对顶点 Vi —&gt; Vj 之间的最短路径可分为如下⼏个阶段：</p>
<blockquote>
<p><strong>#初始</strong>：不允许在其他顶点中转，最短路径是？</p>
<p>A(-1)——目前来看，各顶点间的最短路径长度</p>
<p>path(-1)——两个顶点之间的中转点</p>
<p><strong>#0</strong>：若允许在 V0 中转，最短路径是？</p>
<p>检查所有元素</p>
<p>若 A(k−1)[i][j] &gt; A(k−1)[i][k] + A(k−1)[k][j]</p>
<p>则 A(k)[i][j] &#x3D; A(k−1)[i][k] + A(k−1)[k][j]；path(k)[i][j] &#x3D; k</p>
<p>否则 A(k) 和 path(k) 保持原值</p>
<p><strong>#1</strong>：若允许在 V0、 V1 中转，最短路径是？</p>
<p><strong>#2</strong>：若允许在 V0、 V1、 V2 中转，最短路径是？</p>
<p>…</p>
<p><strong>#n-1</strong>：若允许在 V0、 V1、 V2 …… Vn-1 中转，最短路径是？  </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Floyd核心算法</span></span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">&#123;             </span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)       <span class="comment">//所有的路都让k加进去试试  </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)   <span class="comment">//如果从i到j的路上有k走的会更轻松的话,那就让k去吧 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(A[i][j]&gt;A[i][k]+A[k][j])    <span class="comment">//判断是否会更加轻松       </span></span><br><span class="line">			&#123;</span><br><span class="line">				A[i][j] = A[i][k]+A[k][j]; <span class="comment">//更新最短路径长度</span></span><br><span class="line">				path[i][j] = k;            <span class="comment">//中转点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7-有向无环图"><a href="#7-有向无环图" class="headerlink" title="7.有向无环图"></a>7.有向无环图</h2><p><strong>有向无环图</strong>：若一个<strong>有向图</strong>中<strong>不存在环</strong>，则称为有向无环图，简称<strong>DAG图</strong></p>
<p><strong>有向无环图可以用来描述表达式</strong></p>
<h2 id="8-拓扑排序"><a href="#8-拓扑排序" class="headerlink" title="8.拓扑排序"></a>8.拓扑排序</h2><p> <strong>AOV网</strong></p>
<blockquote>
<p>用顶点表示活动的网</p>
<p>用DAG表示一个工程；顶点表示活动；有向边 &lt;Vi，Vj&gt;表示活动Vi必须先于活动Vj进行</p>
</blockquote>
<h3 id="8-1-拓扑排序"><a href="#8-1-拓扑排序" class="headerlink" title="8.1 拓扑排序"></a>8.1 拓扑排序</h3><blockquote>
<p>在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序。</p>
<p>①每个顶点出现且只出现一次</p>
<p>②若顶点A在序列中排在顶点B的前面，则在图中不存在从顶点B到顶点A的路径。</p>
</blockquote>
<p><strong>拓扑排序的实现：</strong></p>
<blockquote>
<p>①从DAG图中选择一个没有前驱的顶点并输出。</p>
<p>②从图中删除该顶点和所有以它为为起点的有向边。</p>
<p>③重复①和②直到<strong>当前的DAG图为空</strong>或<strong>当前图中不存在无前驱的顶点</strong>为止。（而后一种情况则说明有向图中必然存在环）</p>
<p>注意：有回路的图不适合用拓扑排序</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拓扑排序</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">TopologicalSort</span><span class="params">(Graph G)</span>&#123;</span><br><span class="line">	InitStack(S); 			<span class="comment">//初始化栈，存储入度为0的顶点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">		<span class="keyword">if</span>(indegree[i]==<span class="number">0</span>)</span><br><span class="line">			Push(S,i);		<span class="comment">//将所有入度为0的顶点进栈</span></span><br><span class="line">	<span class="type">int</span> count=<span class="number">0</span>;			<span class="comment">//计数，记录当前已经输出的顶点数</span></span><br><span class="line">	<span class="keyword">while</span>(!IsEmpty(S))&#123;		<span class="comment">//栈不空，则存在入度为0的顶点</span></span><br><span class="line">		Pop(S,i);			<span class="comment">//栈顶元素出栈</span></span><br><span class="line">		print[count++]=i;	<span class="comment">//输出顶点i;</span></span><br><span class="line">		<span class="keyword">for</span>(p=G.vertices[i].firstarc;p;p=p-&gt;nextrac)&#123;</span><br><span class="line">			<span class="comment">//将所有i指向的顶点的入度减1，并将入度减为0的顶点压入栈S</span></span><br><span class="line">			v=p-&gt;adjvex;</span><br><span class="line">			<span class="keyword">if</span>(!(--indegree[v]))</span><br><span class="line">				Push(S,v);  <span class="comment">//入度为0，则入栈</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(count&lt;G.vexnum)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;		<span class="comment">//排序失败，有向图中有回路</span></span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;		<span class="comment">//拓扑排序成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-2-逆拓扑排序"><a href="#8-2-逆拓扑排序" class="headerlink" title="8.2 逆拓扑排序"></a>8.2 逆拓扑排序</h3><p><strong>逆拓扑排序的实现</strong></p>
<blockquote>
<p>①从AOV网中选择一个没有后继（出度为O)的顶点并输出。</p>
<p>②从网中删除该顶点和所有以它为终点的有向边。</p>
<p>③重复①和②直到当前的AOV网为空。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逆拓扑排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSTraverse</span><span class="params">(Graph G)</span>&#123; 	<span class="comment">//对图G进行深度优先遍历</span></span><br><span class="line">	<span class="keyword">for</span>(v=<span class="number">0</span>; v&lt;G.vexnum; ++v)</span><br><span class="line">		visited[v]=FALSE;   <span class="comment">//初始化已访问标记数据</span></span><br><span class="line">	<span class="keyword">for</span>(v=<span class="number">0</span>; v&lt;G.vexnum; ++v)<span class="comment">//本代码中是从v=0开始遍历</span></span><br><span class="line">		<span class="keyword">if</span>(!visited[v])</span><br><span class="line">			DFS(G,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span>&#123;	<span class="comment">//从顶点v出发，深度优先遍历图G</span></span><br><span class="line">	visited[v]=TRUE;		<span class="comment">//设已访问标记</span></span><br><span class="line">	<span class="keyword">for</span>(w=FirstNeighbor(G,v);w&gt;=<span class="number">0</span>; w=NextNeighor(G,v,w))</span><br><span class="line">		<span class="keyword">if</span>(!visited[w])&#123;	<span class="comment">// w为u的尚未访问的邻接顶点</span></span><br><span class="line">			DFS(G,w);</span><br><span class="line">		&#125;</span><br><span class="line">	print(v );		        <span class="comment">//输出顶点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="9-关键路径"><a href="#9-关键路径" class="headerlink" title="9.关键路径"></a>9.关键路径</h2><p><strong>AOE网</strong></p>
<blockquote>
<p>在带权有向图中，以<strong>顶点表示事件</strong>，以<strong>有向边表示活动</strong>，以<strong>边上的权值表示完成该活动的开销</strong>（如完成活动所需的时间)，称之为用边表示活动的网络，简称<strong>AOE网</strong>(Activity On Edge NetWork)</p>
</blockquote>
<p><strong>AOE网的两个性质</strong></p>
<blockquote>
<p>①只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始;</p>
<p>②只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生。另外，有些活动是可以并行进行的。</p>
</blockquote>
<p>在AOE网中<strong>仅有一个</strong>入度为0的顶点，称为<strong>开始顶点〈源点)</strong>，它表示整个工程的开始;<br>也<strong>仅有一个</strong>出度为0的顶点，称为<strong>结束顶点（汇点)</strong>，它表示整个工程的结束。</p>
<p>从源点到汇点的有向路径可能有多条，所有路径中，具有最大路径长度的路径称为<strong>关键路径</strong>，而把关键路径上的活动称为<strong>关键活动</strong>。</p>
<p>完成整个工程的<strong>最短时间</strong>就是<strong>关键路径的长度</strong>，若关键活动不能按时完成，则整个工程的完成时间就会延长。</p>
<blockquote>
<ul>
<li><p>事件vk的最早发生时间ve(k)——决定了所有从vk开始的活动能够开工的最早时间。</p>
</li>
<li><p>事件vk的最迟发生时间vl(k)——它是指在不推迟整个工程完成的前提下，该事件最迟必须发生的时间。</p>
</li>
<li><p>活动ai的最早开始时间e(i)——指该活动弧的起点所表示的事件的最早发生时间。</p>
</li>
<li><p>活动ai的最迟开始时间l(i)——它是指该活动弧的终点所表示事件的最迟发生时间与该活动所需时间之差。</p>
</li>
<li><p>活动ai的<strong>时间余量d(i)&#x3D;l(i)-e(i)</strong>——是指在不增加完成整个工程所需总时间的情况下，活动ai可以拖延的时间。</p>
</li>
</ul>
<p>【若一个活动的时间余量为零，则说明该活动必须要如期完成，d(i)&#x3D;0即l(i) &#x3D;e(i)的活动ai是关键活动，由关键活动组成的路径就是关键路径】</p>
</blockquote>
<h1 id="第七章：查找"><a href="#第七章：查找" class="headerlink" title="第七章：查找"></a>第七章：查找</h1><h2 id="1-查找的基本概念"><a href="#1-查找的基本概念" class="headerlink" title="1.查找的基本概念"></a>1.查找的基本概念</h2><p><strong>查找</strong> —— 在数据集合中寻找满⾜某种条件的数据元素的过程称为查找<br><strong>查找表（查找结构）</strong>—— ⽤于查找的数据集合称为查找表，它由同⼀类型的数据元素（或记录）组成<br><strong>关键字</strong> —— 数据元素中**唯⼀**标识该元素的某个数据项的值，使⽤基于关键字的查找，查找结果应该是唯⼀的。  </p>
<p><strong>对查找表的常见操作</strong></p>
<blockquote>
<p>①查找符合条件的数据元素</p>
<p>②插⼊、删除某个数据元素  </p>
</blockquote>
<p><strong>查找算法的评价指标</strong>  </p>
<blockquote>
<p>①查找⻓度——在查找运算中，需要对⽐关键字的次数称为查找⻓度<br>②平均查找⻓度（ASL, Average Search Length）—— 所有查找过程中进⾏关键字的⽐较次数的平均值  </p>
</blockquote>
<h2 id="2-顺序查找"><a href="#2-顺序查找" class="headerlink" title="2.顺序查找"></a>2.顺序查找</h2><h3 id="2-1-算法思想"><a href="#2-1-算法思想" class="headerlink" title="2.1 算法思想"></a>2.1 算法思想</h3><p>顺序查找，⼜叫“线性查找”，通常⽤于线性表。</p>
<p>算法思想：从头到 jio 挨个找（或者反过来也OK）  </p>
<h3 id="2-2-算法实现"><a href="#2-2-算法实现" class="headerlink" title="2.2 算法实现"></a>2.2 算法实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>        <span class="comment">//查找表的数据结构（顺序表）</span></span><br><span class="line">    Elemtype *elem;    <span class="comment">//动态数组基址</span></span><br><span class="line">    <span class="type">int</span> TableLen;      <span class="comment">//表的长度</span></span><br><span class="line">&#125;SSTable;</span><br><span class="line"><span class="comment">//顺序查找</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Search_Seq</span><span class="params">(SSTable ST, ElemType key)</span>&#123;</span><br><span class="line">    <span class="comment">// 引入哨兵元素，在创建查找表时，0号单元留空，预留给带查找元素关键字</span></span><br><span class="line">	<span class="comment">// 引入哨兵元素的目的是使得循环不必判断数组是否越界，可以避免很多不必要的判断语句，提高效率 </span></span><br><span class="line">	ST.elem[<span class="number">0</span>] = key;                               <span class="comment">//“哨兵”  </span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = ST.TableLen; ST.elem[i] != key; --i);   <span class="comment">//从后往前找</span></span><br><span class="line">	<span class="keyword">return</span> i;    <span class="comment">//查找成功，返回元素下标；查找失败，则返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h2 id="3-折半查找"><a href="#3-折半查找" class="headerlink" title="3.折半查找"></a>3.折半查找</h2><h3 id="3-1-算法思想"><a href="#3-1-算法思想" class="headerlink" title="3.1 算法思想"></a>3.1 算法思想</h3><p><strong>折半查找</strong>，又称“二分查找”，仅适用于<strong>有序</strong>的<strong>顺序表</strong></p>
<p><strong>基本思想</strong>：</p>
<blockquote>
<p>首先将给定值key于表<strong>中间位置</strong>的元素进行比较，若相等，则查找成功，返回元素位置；若不等，则目标元素只能在中间元素以外的前半部分或后半部分，然后在缩小的范围内继续同样的查找。</p>
</blockquote>
<h3 id="3-2-算法实现"><a href="#3-2-算法实现" class="headerlink" title="3.2 算法实现"></a>3.2 算法实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>        <span class="comment">//查找表的数据结构（顺序表）</span></span><br><span class="line">    Elemtype *elem;    <span class="comment">//动态数组基址</span></span><br><span class="line">    <span class="type">int</span> TableLen;      <span class="comment">//表的长度</span></span><br><span class="line">&#125;SSTable;</span><br><span class="line"><span class="comment">//折半查找（以升序为例）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">binnarySearch</span><span class="params">(SSTable L, ElemType key)</span>&#123;</span><br><span class="line">	<span class="type">int</span> low = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> high = L.TableLen - <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> mid;</span><br><span class="line">	<span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">		mid = (low + high) / <span class="number">2</span>;      <span class="comment">//取中间位置（向下取整）</span></span><br><span class="line">		<span class="keyword">if</span>(L.elem[mid] == key)       <span class="comment">//查找成功直接返回</span></span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(L.elem[mid] &lt; key)</span><br><span class="line">			low = mid + <span class="number">1</span>;           <span class="comment">//从后半部分开始查找</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			high = mid - <span class="number">1</span>;          <span class="comment">//从前半部分开始查找</span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 查找失败，返回-1    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(log₂n)</p>
<h3 id="3-3-折半查找判定树"><a href="#3-3-折半查找判定树" class="headerlink" title="3.3 折半查找判定树"></a>3.3 折半查找判定树</h3><p><strong>构造：</strong></p>
<blockquote>
<p>由mid所指元素将原有元素分割到左右子树中</p>
<p>key：右子树结点数 - 左子树结点树 的绝对值小于等于1</p>
</blockquote>
<p><strong>特性：</strong></p>
<blockquote>
<p>折半查找判定树是平衡的二叉排序树</p>
<p>折半查找判定树，只有最下面一层是不满的</p>
<p>若查找表有n个关键字，则失败结点有 n+1 个</p>
<p>树高h&#x3D;[log₂(n+1)] （不包含失败结点）</p>
</blockquote>
<h2 id="4-分块查找"><a href="#4-分块查找" class="headerlink" title="4.分块查找"></a>4.分块查找</h2><h3 id="4-1-算法思想"><a href="#4-1-算法思想" class="headerlink" title="4.1 算法思想"></a>4.1 算法思想</h3><p><strong>基本思想</strong>：</p>
<blockquote>
<p>将查找表分为若干子块，块内元素可以无序，但块之间是有序的，即前一块中的最大关键字小于后一块中的最小关键字。再建立一个索引表，索引表中的每个元素含有各块中的最大关键字和各块中的第一个元素的地址，索引表按关键字有序排序。</p>
<p>分块查找吸取了顺序查找和折半查找各自的优点，既有动态结构，又适合于快速查找。</p>
<p>查找分为两步，第一步是在索引表中确定待查记录所在的块，可以使用顺序查找或折半查找；第二部是在块内顺序查找。</p>
</blockquote>
<h2 id="5-B树"><a href="#5-B树" class="headerlink" title="5.B树"></a>5.B树</h2><p>B树，又称<strong>多路平衡查找树</strong>，所有结点的最大孩子数称为<strong>阶</strong>。一般用m来指代</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5叉查找树的结点定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    Elemtype keys[<span class="number">4</span>];       <span class="comment">//最多四个关键字</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">child</span>[5];</span>  <span class="comment">//最多5个孩子</span></span><br><span class="line">    <span class="type">int</span> num;                <span class="comment">//结点中有几个关键字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-1-B树的性质"><a href="#5-1-B树的性质" class="headerlink" title="5.1 B树的性质"></a>5.1 B树的性质</h3><p><strong>对于m阶的B树</strong>：</p>
<blockquote>
<ul>
<li><p>根节点的⼦树数∈[2, m]，关键字数∈[1, m-1]。</p>
<p>其他结点的⼦树数∈[ , m]；关键字数∈[ -1, m-1]  </p>
</li>
<li><p>对任⼀结点，其所有⼦树⾼度都相同  </p>
</li>
<li><p>关键字的值：⼦树0&lt;关键字1&lt;⼦树1&lt;关键字2&lt;⼦树2&lt;…. (类⽐⼆叉查找树 左&lt;中&lt;右)  </p>
</li>
<li><p>所有叶节点都位于同一层，并且是不带信息的</p>
</li>
</ul>
</blockquote>
<h3 id="5-2-B树的查找"><a href="#5-2-B树的查找" class="headerlink" title="5.2 B树的查找"></a>5.2 B树的查找</h3><p>B树的查找可分为两步</p>
<blockquote>
<p>1.在B树中找结点(磁盘上进行)</p>
<p>2.在结点内找关键字(内存上进行)，可采用顺序查找法或折半查找法。</p>
</blockquote>
<h3 id="5-3-B树的插入"><a href="#5-3-B树的插入" class="headerlink" title="5.3 B树的插入"></a>5.3 B树的插入</h3><p>通过B树的查找算法确定查找失败的位置，这个位置就是应该插入的位置。</p>
<p>开始进行插入，如果要插入结点的关键字数量小于m，直接插入即可。如果大于等于m，那就不符合B树的特性了，那就要进行分裂。</p>
<p>分裂的方法是：位置为”向上取整m&#x2F;2”的关键字，给到父节点，这个关键字的左部分保持在原来结点，右部分放到一个新节点。</p>
<p>如果给到父节点关键字后，父节点的关键字数量也大于等于m了，那么就要进行二次分裂。</p>
<h3 id="5-4-B树的删除"><a href="#5-4-B树的删除" class="headerlink" title="5.4 B树的删除"></a>5.4 B树的删除</h3><p>删除可分为两种情况，被删的关键字在与不在终端结点中。</p>
<ul>
<li>不在终端结点中</li>
</ul>
<blockquote>
<p>如果要删关键字k，找到k的直接前驱（左侧指针所指⼦树中“最右下”的元素  ）或直接后继（右侧指针所指⼦树中“最左下”的元素  ）来替代被删除的关键字。</p>
</blockquote>
<ul>
<li>在终端结点中，又分为三种情况</li>
</ul>
<blockquote>
<p>①直接删除。 当将要被删除关键字所在结点的关键字数量大于等于“向上取整m&#x2F;2”，代表删掉之后就是“向上取整m&#x2F;2”-1，依旧符合B树特性，可以直接删掉。<br>借兄弟一手。 顾名思义，为啥要借，就是自身不符合前面直接删除的条件(删掉之后不符合B树特性了)，所以要借兄弟的，那兄弟够借嘛？所以又可以分为两种</p>
<p>②兄弟够借。若被删除关键字所在结点删除前的关键字个数低于下限，且与此结点右（或左）兄弟结点的关键字个数还很宽裕，则需要调整该结点、右（或左）兄弟结点及其双亲结点（⽗⼦换位法）  </p>
<p>③兄弟不够借。若被删除关键字所在结点删除前的关键字个数低于下限，且此时与该结点相邻的左、右兄弟结点的关键字个数均&#x3D;⌈m&#x2F;2⌉ - 1，则将关键字删除后<strong>与左（或右）兄弟结点及双亲结点中的关键字进⾏合并</strong></p>
<p>在合并过程中，双亲结点中的关键字个数会减1。若其双亲结点是根结点且关键字个数减少⾄0（根结点关键字个数为1时，有2棵⼦树），则直接将根结点删除，合并后的新结点成为根；若双亲结点不是根结点，且关键字个数减少到 ，则⼜要与它⾃⼰的兄弟结点进⾏调整或合并操作，并重复上述步骤，直⾄符合B树的要求为⽌</p>
</blockquote>
<h2 id="6-B-树"><a href="#6-B-树" class="headerlink" title="6.B+树"></a>6.B+树</h2><p>B+树是专门为数据库设计的。</p>
<p>B+树的查找、插入、删除与B树类似，但是B+树查找到关键字后，并不终止，而是继续向下查找，直到叶节点上的关键字为止。</p>
<h3 id="6-1-B-树的性质"><a href="#6-1-B-树的性质" class="headerlink" title="6.1 B+树的性质"></a>6.1 B+树的性质</h3><p><strong>⼀棵m阶的B+树需满⾜下列条件</strong>：</p>
<blockquote>
<ul>
<li><p>每个分⽀结点最多有m棵⼦树（孩⼦结点）。</p>
</li>
<li><p>⾮叶根结点⾄少有两棵⼦树，其他每个分⽀结点⾄少有 棵⼦树。</p>
</li>
<li><p><strong>结点的⼦树个数与关键字个数相等。</strong></p>
</li>
<li><p><strong>所有叶结点包含全部关键字</strong>及指向相应记录的指针，叶结点中将关键字按⼤⼩顺序排列，并且相邻叶结点按⼤⼩顺序相互链接起来。</p>
</li>
<li><p>所有分⽀结点中仅包含它的各个⼦结点中关键字的最⼤值及指向其⼦结点的指针。</p>
</li>
</ul>
</blockquote>
<h3 id="6-2-B-树-vs-B树"><a href="#6-2-B-树-vs-B树" class="headerlink" title="6.2 B+树 vs B树"></a>6.2 B+树 vs B树</h3><p><strong>相同点</strong>：</p>
<ul>
<li><p>除根节点外，最少 [m&#x2F;2] 个分叉（确保结点不要太“空”）</p>
</li>
<li><p>任何⼀个结点的⼦树都要⼀样⾼（确保“绝对平衡”）</p>
</li>
</ul>
<p><strong>不同点</strong>：</p>
<table>
<thead>
<tr>
<th></th>
<th>m阶B树</th>
<th>m阶B+树</th>
</tr>
</thead>
<tbody><tr>
<td>类比</td>
<td>⼆叉查找树的进化——&gt;m叉查找树</td>
<td>分块查找的进化——&gt;多级分块查找</td>
</tr>
<tr>
<td>关键字与分叉</td>
<td>n个关键字对应n+1个分叉（⼦树）</td>
<td>n个关键字对应n个分叉</td>
</tr>
<tr>
<td>节点包含的信息</td>
<td>所有结点中都包含记录的信息</td>
<td>只有最下层叶⼦结点才包含记录的信息 （可使树更矮）</td>
</tr>
<tr>
<td>查找方式</td>
<td>不⽀持顺序查找。查找成功时，可能停在 任何⼀层结点，查找速度“不稳定”</td>
<td>⽀持顺序查找。查找成功或失败都会到达 最下⼀层结点，查找速度“稳定</td>
</tr>
</tbody></table>
<h2 id="7-散列查找"><a href="#7-散列查找" class="headerlink" title="7.散列查找"></a>7.散列查找</h2><h3 id="7-1-概念"><a href="#7-1-概念" class="headerlink" title="7.1 概念"></a>7.1 概念</h3><p><strong>散列表</strong>（Hash Table），⼜称<strong>哈希表</strong>。是⼀种数据结构，特点是：<strong>数据元素的关键字与其存储地址直接相关</strong>  。</p>
<p><strong>散列函数</strong>：把查找表中的关键字映射成该关键字对应地址的函数，记为Addr&#x3D;Hash（key）。这里的地址可以是数组下标、索引或内存地址等。</p>
<p>若不同的关键字通过散列函数映射到同⼀个值，则称它们为**“同义词”**  </p>
<p>通过散列函数确定的位置已经存放了其他元素，则称这种情况为**“冲突”**   </p>
<p><strong>理想</strong>情况下，散列表的<strong>查找时间复杂度为O(1)</strong>，即与表中元素的个数无关。</p>
<h3 id="7-2-构造散列函数"><a href="#7-2-构造散列函数" class="headerlink" title="7.2 构造散列函数"></a>7.2 构造散列函数</h3><p>①<strong>除留余数法</strong></p>
<blockquote>
<p><strong>H(key) &#x3D; key % p</strong></p>
<p>假定散列表表长为m，取一个不大于m但最接近m的<strong>质数</strong>p</p>
<p>(取质数的话大多数情况下能让冲突发生得更少，分布得更均匀，参见《数论》)</p>
</blockquote>
<p>②<strong>直接定址法</strong>  </p>
<blockquote>
<p><strong>H(key) &#x3D; key 或 H(key) &#x3D; a*key + b</strong>  </p>
<p>其中，a和b是常数。这种⽅法计算最简单，且不会产⽣冲突。它<strong>适合关键字的分布基本连续的情况</strong>，若关键字分布不连续，空位较多，则会造成存储空间的浪费。  </p>
</blockquote>
<p>③<strong>数字分析法</strong></p>
<blockquote>
<p><strong>选取数码分布较为均匀的若⼲位作为散列地址</strong>  </p>
<p>设关键字是r进制数（如⼗进制数），⽽<strong>r个数码在各位上出现的频率不⼀定相同</strong>，可能在某些位上分布均匀⼀些，每种数码出现的机会均等；⽽在某些位上分布不均匀，只有某⼏种数码经常出现。</p>
<p>此时可选取数码分布较为均匀的若⼲位作为散列地址。这种⽅法适合于已知的关键字集合，若更换了关键字，则需要重新构造新的散列函数。  </p>
</blockquote>
<p>④<strong>平⽅取中法</strong></p>
<blockquote>
<p><strong>取关键字的平⽅值的中间⼏位作为散列地址。</strong>  </p>
<p>具体取多少位要视实际情况⽽定。</p>
<p><strong>这种⽅法得到的散列地址与关键字的每位都有关系</strong>。</p>
<p>因此使得散列地址分布⽐较均匀，<strong>适⽤于关键字的每位取值都不够均匀或均⼩于散列地址所需的位数</strong>。  </p>
<p>例：存储学生的身份证号</p>
</blockquote>
<h3 id="7-3-处理冲突的办法"><a href="#7-3-处理冲突的办法" class="headerlink" title="7.3 处理冲突的办法"></a>7.3 处理冲突的办法</h3><h4 id="7-3-1-拉链法"><a href="#7-3-1-拉链法" class="headerlink" title="7.3.1 拉链法"></a>7.3.1 拉链法</h4><p>⽤<strong>拉链法</strong>（⼜称链接法、链地址法）处理“冲突”： <strong>把所有“同义词”存储在⼀个链表中</strong></p>
<p>散列表的查找过程于构造散列表的过程基本一致。根</p>
<p>据散列函数和关键字可以计算出记录的散列地址。</p>
<p>若散列地址上：</p>
<p>①无记录，说明查找失败；</p>
<p>②若有记录且关键字相同，则查找成功；</p>
<p>③若有记录但关键字不同，使用给定的处理冲突方法计算下一个散列地址，再次进行比较。</p>
<p><strong>装填因子</strong>：定义一个表的装满程度，即α &#x3D; 表中记录数&#x2F;散列表长度</p>
<h4 id="7-3-2-开放定址法"><a href="#7-3-2-开放定址法" class="headerlink" title="7.3.2 开放定址法"></a>7.3.2 开放定址法</h4><p>开放定址法，是指可存放新表项的空闲地址既向它的同义词表项开放，⼜向它的⾮同义词表项开放。  </p>
<p>数学递推公式：</p>
<p><strong>Hi &#x3D; (H(key) + di) % m</strong></p>
<p>i &#x3D; 0, 1, 2,…, k（k≤m - 1）， m表示散列表表⻓； <strong>di为增量序列</strong>； i 可理解为“第i次发⽣冲突”  </p>
<p>取定某一增量序列di后，对应的处理方法就是确定的。通常有以下4种取法</p>
<p>①<strong>线性探测法</strong>（线性探测再散列法）</p>
<p><strong>di &#x3D; 0，1，2，···，m-1</strong></p>
<blockquote>
<ul>
<li><p>冲突发生时，顺序查看表中下一个单元，直到找出一个空单元或查遍全表（此时表已满）。</p>
</li>
<li><p>线性探查法可能使第 i 个散列地址的同义词存入第 i+1 个散列地址，这样本应存入第 i+1 个散列地址的元素就要争夺 i+2 个散列地址。<strong>造成大量元素在相邻的散列地址上聚集（堆积）起来，大大降低了查找效率。</strong></p>
</li>
<li><p>采⽤“开放定址法”时，删除结点<strong>不能简单地将被删结点的空间置为空</strong>，否则将截断在它之后填⼊散列表的同义词结点的查找路径，可以做⼀个“删除标记”，进⾏逻辑删除</p>
</li>
</ul>
</blockquote>
<p>②<strong>平方探测法</strong>（二次探测再散列法）</p>
<p><strong>di &#x3D; 0²，1²，-1²，2²，-2²，···，k²，-k²（k≤m&#x2F;2）</strong></p>
<blockquote>
<ul>
<li>散列表长度m必须是一个可以表示为4k+3的素数。</li>
<li>是一种处理冲突的较好方法，可以避免出现堆积问题。</li>
<li>⼩坑：散列表⻓度m必须是⼀个可以表示成4j + 3的素数，才能探测到所有位置，参加《数论》</li>
</ul>
</blockquote>
<p>③<strong>再散列法</strong>（双散列法）</p>
<p><strong>Hi &#x3D; RHi(Key)      i&#x3D;1,2,3….,k</strong>  </p>
<blockquote>
<ul>
<li>除了原始的散列函数 H(key) 之外，多准备⼏个散列函数，当散列函数冲突时，⽤下⼀个散列函数计算⼀个新地址，直到不冲突为⽌</li>
</ul>
</blockquote>
<p>④<strong>伪随机序列法</strong>：</p>
<p><strong>di为伪随机数序列</strong></p>
<h1 id="第八章：排序"><a href="#第八章：排序" class="headerlink" title="第八章：排序"></a>第八章：排序</h1><h2 id="1-排序的基本概念"><a href="#1-排序的基本概念" class="headerlink" title="1.排序的基本概念"></a>1.排序的基本概念</h2><p><strong>排序（Sort）</strong> ，就是重新排列表中的元素，使表中的元素满⾜<strong>按关键字有序</strong>的过程。  </p>
<p><strong>排序算法的评价指标</strong> </p>
<blockquote>
<p>算法的<strong>稳定性</strong>。 </p>
<p>若待排序表中有两个元素Ri和Rj，其对应的关键字相同即keyi &#x3D; keyj，且在排序前Ri在Rj的前⾯，若使⽤某⼀排序算法排序后， Ri仍然在Rj的前⾯，则称这个排序算法是稳定的，否则称排序算法是不稳定的。  </p>
</blockquote>
<p><strong>排序算法的分类</strong></p>
<blockquote>
<ul>
<li>内部排序——数据都在内存中</li>
</ul>
<p>关注如何使算法时间、空间复杂度更低</p>
<ul>
<li>外部排序——数据太多，无法全部放入内存</li>
</ul>
<p>还要关注如何使读&#x2F;写磁盘次数更少</p>
</blockquote>
<h2 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2.插入排序"></a>2.插入排序</h2><h3 id="2-1-算法思想-1"><a href="#2-1-算法思想-1" class="headerlink" title="2.1 算法思想"></a>2.1 算法思想</h3><p>每次将⼀个待排序的记录按其关键字⼤⼩插⼊到前⾯已排好序的⼦序列中，直到全部记录插⼊完成。  </p>
<h3 id="2-2-算法实现-1"><a href="#2-2-算法实现-1" class="headerlink" title="2.2 算法实现"></a>2.2 算法实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不带“哨兵”</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span>&#123;   <span class="comment">//A中共n个数据元素</span></span><br><span class="line">    <span class="type">int</span> i,j,temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>])&#123;           <span class="comment">//A[i]关键字小于前驱</span></span><br><span class="line">            temp = A[i];  </span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>; j&gt;=<span class="number">0</span> &amp;&amp; A[j]&gt;temp; --j)</span><br><span class="line">                A[j+<span class="number">1</span>] = A[j];     <span class="comment">//所有大于temp的元素都向后挪</span></span><br><span class="line">            A[j+<span class="number">1</span>] = temp;         <span class="comment">//复制到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带“哨兵”</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span>&#123;          <span class="comment">//A中从1开始存储，0放哨兵</span></span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>])&#123;    </span><br><span class="line">            A[<span class="number">0</span>] = A[i];                  <span class="comment">//复制为哨兵</span></span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>; A[<span class="number">0</span>] &lt; A[j]; --j)  <span class="comment">//从后往前查找待插入位置</span></span><br><span class="line">                A[j+<span class="number">1</span>] = A[j];            <span class="comment">//向后挪动</span></span><br><span class="line">            A[j+<span class="number">1</span>] = A[<span class="number">0</span>];                <span class="comment">//复制到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空间效率：空间复杂度&#x3D;O(1)</p>
<p>时间效率: 平均时间复杂度&#x3D;O(n²)</p>
<p>稳定性：插入排序是一种稳定的排序方法</p>
<h3 id="2-3-算法优化"><a href="#2-3-算法优化" class="headerlink" title="2.3 算法优化"></a>2.3 算法优化</h3><p><strong>折半插入排序</strong>：先⽤折半查找找到应该插⼊的位置，再移动元素  </p>
<p>当 <strong>low&gt;high</strong> 时折半查找停⽌，应将 [low, i-1] 内的元素全部右移，并将 A[0] 复制到 low 所指位置 （即high+1）</p>
<p>当 <strong>A[mid]&#x3D;&#x3D;A[0]</strong> 时，为了保证算法的“稳定性”，应继续在 mid 所指位置右边寻找插⼊位置  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span>&#123; </span><br><span class="line">    <span class="type">int</span> i,j,low,high,mid;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        A[<span class="number">0</span>] = A[i];                    <span class="comment">//将A[i]暂存到A[0]</span></span><br><span class="line">        low = <span class="number">1</span>; high = i<span class="number">-1</span>;            <span class="comment">//折半查找的范围</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;               <span class="comment">//折半查找</span></span><br><span class="line">            mid = (low + high)/<span class="number">2</span>;       <span class="comment">//取中间点</span></span><br><span class="line">            <span class="keyword">if</span>(A[mid]&gt;A[<span class="number">0</span>])             <span class="comment">//查找左半子表</span></span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>                        <span class="comment">//查找右半子表</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>; j&gt;high+<span class="number">1</span>;--j)        <span class="comment">//统一后移元素，空出插入位置</span></span><br><span class="line">            A[j+<span class="number">1</span>] = A[j];</span><br><span class="line">        A[high+<span class="number">1</span>] = A[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-希尔排序"><a href="#3-希尔排序" class="headerlink" title="3.希尔排序"></a>3.希尔排序</h2><h3 id="3-1-算法思想-1"><a href="#3-1-算法思想-1" class="headerlink" title="3.1 算法思想"></a>3.1 算法思想</h3><p>先追求表中元素部分有序，再逐渐逼近全局有序。</p>
<p>先将待排序表分割成若⼲形如 L[i, i + d, i + 2d,…, i + kd] 的“特殊”⼦表，对各个⼦表分别进⾏直接插⼊排序。<strong>缩⼩增量d</strong>，重复上述过程，直到d&#x3D;1为⽌。  </p>
<h3 id="3-2-算法实现-1"><a href="#3-2-算法实现-1" class="headerlink" title="3.2 算法实现"></a>3.2 算法实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="comment">//A[0]为暂存单元，不是哨兵</span></span><br><span class="line">    <span class="keyword">for</span>(d=n/<span class="number">2</span>; d&gt;=<span class="number">1</span>; d=d/<span class="number">2</span>)&#123;   <span class="comment">//步长递减（看具体要求，一般是1/2）</span></span><br><span class="line">        <span class="keyword">for</span>(i=d+<span class="number">1</span>; i&lt;=n; ++i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(A[i]&lt;A[i-d])&#123;             <span class="comment">//需将A[i]插入有序增量子表</span></span><br><span class="line">                A[<span class="number">0</span>]=A[i];</span><br><span class="line">                <span class="keyword">for</span>(j=i-d; j&gt;<span class="number">0</span> &amp;&amp; A[<span class="number">0</span>]&lt;A[j];j-=d)</span><br><span class="line">                    A[j+d]=A[j];         <span class="comment">//记录后移，查找插入的位置</span></span><br><span class="line">                A[j+d]=A[<span class="number">0</span>;]             <span class="comment">//插入</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空间效率：空间复杂度&#x3D;O(1)</p>
<p>时间效率: 平均时间复杂度&#x3D;O(n²)</p>
<p>稳定性：希尔排序是一种不稳定的排序方法</p>
<h2 id="4-冒泡排序"><a href="#4-冒泡排序" class="headerlink" title="4.冒泡排序"></a>4.冒泡排序</h2><p>冒泡排序是基于交换的排序</p>
<h3 id="4-1-算法思想-1"><a href="#4-1-算法思想-1" class="headerlink" title="4.1 算法思想"></a>4.1 算法思想</h3><ul>
<li><p>第一趟排序使关键字值最小的一个元素“冒”到最前面（其最终位置）</p>
</li>
<li><p>每趟冒泡的结果是把序列中最小（或最大）元素放到序列的最终位置，这样最多做n-1趟冒泡就能把所有元素排好序；</p>
</li>
<li><p>为保证稳定性，关键字相同的元素不交换；</p>
</li>
</ul>
<h3 id="4-2-算法实现"><a href="#4-2-算法实现" class="headerlink" title="4.2 算法实现"></a>4.2 算法实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span>&#123;   <span class="comment">//从0开始存放</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;         <span class="comment">// 表示本趟冒泡是否发生交换的标志</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=n<span class="number">-1</span>; j&gt;i; j--)&#123;  <span class="comment">//一趟冒泡过程</span></span><br><span class="line">            <span class="keyword">if</span>(A[j<span class="number">-1</span>]&gt;A[j])&#123;       <span class="comment">//若为逆序</span></span><br><span class="line">                swap(A[j<span class="number">-1</span>],A[j]); <span class="comment">//交换</span></span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//本趟遍历后没有发生交换，说明表已经有序，可以结束算法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空间效率：空间复杂度&#x3D;O(1)</p>
<p>时间效率: 平均时间复杂度&#x3D;O(n²)</p>
<p>稳定性：冒泡排序是一种稳定的排序方法</p>
<h2 id="5-快速排序"><a href="#5-快速排序" class="headerlink" title="5.快速排序"></a>5.快速排序</h2><p>快速排序也是基于交换的排序</p>
<h3 id="5-1-算法思想"><a href="#5-1-算法思想" class="headerlink" title="5.1 算法思想"></a>5.1 算法思想</h3><p>在待排序表L[1…n]中任取⼀个元素pivot作为枢轴（或基准，通常取⾸元素），</p>
<p>通过⼀趟排序将待排序表划分为独⽴的两部分L[1…k-1]和L[k+1…n]，使得L[1…k-1]中的所有元素⼩于pivot，L[k+1…n]中的所有元素⼤于等于pivot，则pivot放在了其最终位置L(k)上， 这个过程称为⼀次“划分”。</p>
<p>然后分别递归地对两个⼦表重复上述过程，直⾄每部分内只有⼀个元素或空为⽌，即所有元素放在了其最终位置上。  </p>
<h3 id="5-2-算法实现"><a href="#5-2-算法实现" class="headerlink" title="5.2 算法实现"></a>5.2 算法实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用第一个元素将待排序序列划分为左右两个部分</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Partition</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = A[low];     <span class="comment">//用第一个元素作为枢轴</span></span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; A[high]&gt;=pivot) --high; <span class="comment">//high所指元素大于枢轴，high左移</span></span><br><span class="line">        A[low] = A[high];   <span class="comment">//high所指元素小于枢轴，移动到左侧</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; A[low]&lt;=pivot)  ++low;  <span class="comment">//low所指元素小于枢轴，low右移</span></span><br><span class="line">        A[high] = A[low];   <span class="comment">//low所指元素大于枢轴，移动到右侧</span></span><br><span class="line">    &#125;</span><br><span class="line">    A[low] = pivot   <span class="comment">//枢轴元素存放到最终位置</span></span><br><span class="line">    <span class="keyword">return</span> low；     <span class="comment">//返回存放枢轴的最终位置</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="type">void</span> QuickSort(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high) &#123;    <span class="comment">//递归跳出条件</span></span><br><span class="line">        <span class="type">int</span> pivotpos = Partition(A, low, high);   <span class="comment">//划分</span></span><br><span class="line">    	QuickSort（A, low, pivotpos - <span class="number">1</span>);         <span class="comment">//划分左子表</span></span><br><span class="line">    	QuickSort（A, pivotpos + <span class="number">1</span>, high);        <span class="comment">//划分右子表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空间效率：最好空间复杂度&#x3D;O(log₂n)，最坏空间复杂度&#x3D;O(n)</p>
<p>时间效率: 平均时间复杂度&#x3D;O(nlog₂n)</p>
<p>稳定性：快速排序是一种不稳定的排序方法</p>
<p>快速排序是所有内部排序算法中平均性能最优的排序算法</p>
<h2 id="6-简单选择排序"><a href="#6-简单选择排序" class="headerlink" title="6.简单选择排序"></a>6.简单选择排序</h2><p><strong>简单选择排序</strong> 和 <strong>堆排序</strong> 都属于<strong>选择排序</strong></p>
<p><strong>选择排序</strong>：每⼀趟在待排序元素中选取关键字最⼩（或最⼤）的元素加⼊有序⼦序列 </p>
<h3 id="6-1-算法思想"><a href="#6-1-算法思想" class="headerlink" title="6.1 算法思想"></a>6.1 算法思想</h3><p>每⼀趟在待排序元素中选取关键字最⼩的元素加⼊有序⼦序列。</p>
<h3 id="6-2-算法实现"><a href="#6-2-算法实现" class="headerlink" title="6.2 算法实现"></a>6.2 算法实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简单选择排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span>&#123;       <span class="comment">//A从0开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;          <span class="comment">//一共进行n-1趟，i指向待排序序列中第一个元素</span></span><br><span class="line">        <span class="type">int</span> min = i;                   <span class="comment">//记录最小元素位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;n; j++)&#123;      <span class="comment">//在A[i...n-1]中选择最小的元素</span></span><br><span class="line">            <span class="keyword">if</span>(A[j]&lt;A[min])&#123;</span><br><span class="line">                min = j;               <span class="comment">//更新最小元素位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min!=i)                     </span><br><span class="line">            swap(A[i],A[min]);         <span class="comment">//交换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空间效率：空间复杂度&#x3D;O(1)</p>
<p>时间效率：时间复杂度&#x3D;O(n²)</p>
<p>稳定性：简单选择排序是一种不稳定的排序方法</p>
<h2 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7.堆排序"></a>7.堆排序</h2><p><strong>堆排序</strong>是<strong>选择排序</strong>中的一种</p>
<p><strong>什么是堆？</strong></p>
<blockquote>
<p>若n个关键字序列L[1…n] 满⾜下⾯某⼀条性质，则称为堆（Heap） ：</p>
<p>① 若满⾜：L(i)≥L(2i) 且 L(i)≥L(2i+1) （1 ≤ i ≤n&#x2F;2 ） —— ⼤根堆（⼤顶堆）</p>
<p>② 若满⾜：L(i)≤L(2i) 且 L(i)≤L(2i+1) （1 ≤ i ≤n&#x2F;2 ） —— ⼩根堆（⼩顶堆）  </p>
<p>堆从逻辑上来看，就是一棵顺序存储的完全二叉树</p>
<p>大根堆：完全二叉树中，根≥左、右</p>
<p>大根堆：完全二叉树中，根≤左、右</p>
<p>注意：<strong>在顺序存储的完全⼆叉树中， ⾮终端结点编号 i≤⌊n&#x2F;2⌋</strong>  </p>
<p>​			i 的左孩子 2i ；i 的右孩子 2i+1 ；i 的父节点 [i&#x2F;2] ；</p>
</blockquote>
<h3 id="7-1-算法思想"><a href="#7-1-算法思想" class="headerlink" title="7.1 算法思想"></a>7.1 算法思想</h3><p>每一趟在待排序元素中选取关键字最小（或最大）的元素加入有序子序列，堆顶元素的关键字最大或最小 （以下以大根堆为例）</p>
<p>① 将给定初始序列(n个元素)，<strong>建立初始大根堆</strong>：把所有非终端结点 从后往前都检查一遍，是否满足大根堆的要求——根 ≥ 左、右，若不满足，则将当前结点与更大的孩子互换</p>
<p>② <strong>基于大根堆进行排序</strong>：每一趟将堆顶元素加入有序子序列中，堆顶元素与待排序序列中最后一个元素交换后，即最大元素换到末尾，之后该位置就不用改变，即移出完全二叉树(len&#x3D;len-1)，把剩下的待排序元素序列再调整为大根堆；————“一趟处理”</p>
<p>③ 剩下最后一个元素则不需要再调整；</p>
<h3 id="7-2-算法实现"><a href="#7-2-算法实现" class="headerlink" title="7.2 算法实现"></a>7.2 算法实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对初始序列建立大根堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BuildMaxHeap</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len/<span class="number">2</span>; i&gt;<span class="number">0</span>; i--)        <span class="comment">//从后往前调整所有非终端结点</span></span><br><span class="line">        HeadAdjust(A, i, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将以k为根的子树调整为大根堆</span></span><br><span class="line"><span class="comment">从最底层的分支结点开始调整*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeadAdjust</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> k, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    A[<span class="number">0</span>] = A[k];                      <span class="comment">//A[0]暂存子树的根结点</span></span><br><span class="line">    <span class="comment">//i为当前所选根结点的左孩子，i*=2是为了判断调整后再下一层是否满足大根堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>*k; i&lt;=len; i*=<span class="number">2</span>)&#123;     <span class="comment">//沿key较大的子结点向下筛选</span></span><br><span class="line">        <span class="comment">//i&lt;len是为了保证i是有右兄弟的</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;len &amp;&amp; A[i]&lt;A[i+<span class="number">1</span>])      <span class="comment">//判断：当前所选根结点的左、右结点哪个更大</span></span><br><span class="line">            i++;                      <span class="comment">//取key较大的子结点的下标</span></span><br><span class="line">        <span class="keyword">if</span>(A[<span class="number">0</span>] &gt;= A[i]) </span><br><span class="line">            <span class="keyword">break</span>;                    <span class="comment">//筛选结束：i指向更大的子结点</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            A[k] = A[i];              <span class="comment">//将A[i]调整至双亲结点上</span></span><br><span class="line">            k=i;                      <span class="comment">//修改k值，以便继续向下筛选</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k] = A[<span class="number">0</span>]                       <span class="comment">//被筛选的结点的值放入最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="type">void</span> swap(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基于大根堆进行排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    BuildMaxHeap(A, len);          <span class="comment">//初始建堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len; i&gt;<span class="number">1</span>; i--)&#123;      <span class="comment">//n-1趟的交换和建堆过程</span></span><br><span class="line">        swap(A[i], A[<span class="number">1</span>]);          <span class="comment">//堆顶元素和堆底元素交换</span></span><br><span class="line">        HeadAdjust(A,<span class="number">1</span>,i<span class="number">-1</span>);       <span class="comment">//把剩余的待排序元素整理成堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空间效率：空间复杂度&#x3D;O(1)</p>
<p>时间效率: 平均时间复杂度&#x3D;O(nlog₂n)</p>
<p>稳定性：堆排序是一种不稳定的排序方法</p>
<h2 id="8-归并排序"><a href="#8-归并排序" class="headerlink" title="8.归并排序"></a>8.归并排序</h2><p>归并：把两个或多个已经有序的序列合并成一个</p>
<h3 id="8-1-算法思想"><a href="#8-1-算法思想" class="headerlink" title="8.1 算法思想"></a>8.1 算法思想</h3><p>k路归并：每选出一个元素，需对比关键字k-1次；</p>
<p>外部排序通常采用归并排序，内部排序一般采用2路归并；</p>
<h3 id="8-2-算法实现"><a href="#8-2-算法实现" class="headerlink" title="8.2 算法实现"></a>8.2 算法实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建辅助数组B</span></span><br><span class="line"><span class="type">int</span> *B=(<span class="type">int</span> *)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//A[low,...,mid],A[mid+1,...,high] 各自有序，将这两个部分归并</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(k=low; k&lt;=high; k++)&#123;</span><br><span class="line">        B[k] = A[k];     <span class="comment">//将A中所有元素复制到B中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=low, j=mid+<span class="number">1</span>, k=i; i&lt;=mid &amp;&amp; j&lt;= high; k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(B[i]&lt;=B[j])   <span class="comment">//为保证稳定性两个元素相等，优先使用靠前的那个</span></span><br><span class="line">            A[k]=B[i++]; <span class="comment">//将较小值复制到A中</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            A[k]=B[j++];</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">//没有归并完的部分复制到尾部，while只会执行一个 </span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)  A[k++]=B[i++];     <span class="comment">//若第一个表未检测完，复制</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;=high) A[k++]=B[j++];     <span class="comment">//若第二个表未检测完，复制</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (low+high)/<span class="number">2</span>;    <span class="comment">//从中间划分</span></span><br><span class="line">        MergeSort(A, low, mid);    <span class="comment">//对左半部分归并排序</span></span><br><span class="line">        MergeSort(A, mid+<span class="number">1</span>, high); <span class="comment">//对右半部分归并排序</span></span><br><span class="line">        Merge(A,low,mid,high);     <span class="comment">//归并</span></span><br><span class="line">    &#125;<span class="keyword">if</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空间效率：空间复杂度&#x3D;O(n)</p>
<p>时间效率: 平均时间复杂度&#x3D;O(nlog₂n)</p>
<p>稳定性：堆排序是一种稳定的排序方法</p>
<h2 id="9-基数排序"><a href="#9-基数排序" class="headerlink" title="9.基数排序"></a>9.基数排序</h2><h3 id="9-1-算法思想"><a href="#9-1-算法思想" class="headerlink" title="9.1 算法思想"></a>9.1 算法思想</h3><p>基数排序是一种<strong>非比较</strong>的<strong>稳定</strong>的算法，其原理是将整数<strong>按每个位数分别比较</strong>。它利用了桶的思想。</p>
<h3 id="9-2-算法实现"><a href="#9-2-算法实现" class="headerlink" title="9.2 算法实现"></a>9.2 算法实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10	<span class="comment">//数组长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> D 10	<span class="comment">//最大位数</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetDigit</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> i)</span> <span class="comment">//取整数M的第i位数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(i &gt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		M /= <span class="number">10</span>;</span><br><span class="line">		i--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> M % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RadixSort</span><span class="params">(<span class="type">int</span> num[], <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, j, k, l, digit;</span><br><span class="line">	<span class="type">int</span> allot[<span class="number">10</span>][N];<span class="comment">//《分配数组》</span></span><br><span class="line">	<span class="built_in">memset</span>(allot, <span class="number">0</span>, <span class="keyword">sizeof</span>(allot));<span class="comment">//初始化《分配数组》</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= D; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//分配相应位数的数据，并存入《分配数组》</span></span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; len; j++)	</span><br><span class="line">		&#123;			</span><br><span class="line">			digit = GetDigit(num[j], i);</span><br><span class="line">			k = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(allot[digit][k])</span><br><span class="line">				k++;</span><br><span class="line">			allot[digit][k] = num[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//将《分配数组》的数据依次收集到原数组中</span></span><br><span class="line">		l = <span class="number">0</span>; </span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)	</span><br><span class="line">		&#123;	</span><br><span class="line">			k = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(allot[j][k] &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				num[l++] = allot[j][k];</span><br><span class="line">				k++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//每次分配，收集后初始化“分配数组”，用于下一位数的分配和收集</span></span><br><span class="line">		<span class="built_in">memset</span>(allot, <span class="number">0</span>, <span class="keyword">sizeof</span>(allot));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> num[N] = &#123;<span class="number">52</span>, <span class="number">20</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">17</span>, <span class="number">39</span>, <span class="number">8</span>, <span class="number">300</span>, <span class="number">60</span>, <span class="number">81</span>&#125;;</span><br><span class="line">	RadixSort(num, N);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, num[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="10-外部排序"><a href="#10-外部排序" class="headerlink" title="10.外部排序"></a>10.外部排序</h2><h3 id="10-1-外部排序的原理"><a href="#10-1-外部排序的原理" class="headerlink" title="10.1 外部排序的原理"></a>10.1 外部排序的原理</h3><p><strong>外部排序</strong>指的是大文件的排序，即待排序的记录存储在外存储器上，待排序的文件<strong>无法一次装入内存</strong>，需要在内存和外部存储器之间<strong>进行多次数据交换</strong>，以达到<strong>排序整个文件</strong>的目的。</p>
<h3 id="10-2-影响外部排序效率的因素"><a href="#10-2-影响外部排序效率的因素" class="headerlink" title="10.2 影响外部排序效率的因素"></a>10.2 影响外部排序效率的因素</h3><p>外部排序时间开销 &#x3D; 读写外存时间 + 内部排序时间 + 内部归并时间</p>
<p>可以尝试用<strong>多路归并</strong>，减少归并的趟数，减少读写外村时间。</p>
<p>如果采用k路平衡归并的策略，，选出一个最小的元素需要对比关键字（k-1）次，同样也会导致内部归并时间的增加。</p>
<p>①可以用<strong>败者树</strong>，使得k路平衡归并所需要对比关键字次数减少</p>
<p><strong>败者树</strong>（类似比赛）（k路归并）</p>
<blockquote>
<ul>
<li>可以视为一棵完全二叉树，k个叶子结点分别是当前比较的元素，非叶子结点用来记忆左右子树中的“失败者”，而让胜者往上继续比较，直到根结点。</li>
<li>构造完败者树后，选出最小（最大）元素，只需要对比关键字[log₂k]次</li>
</ul>
</blockquote>
<p>②也可以用<strong>置换-选择排序</strong>，从而让归并段的总数变少</p>
<p>③同样可以用<strong>最佳归并树</strong>减少读&#x2F;写次数</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://pudding1108.github.io">Pudding</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://pudding1108.github.io/2025/06/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89%E7%AC%94%E8%AE%B0/">https://pudding1108.github.io/2025/06/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://pudding1108.github.io" target="_blank">普通博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post-share"><div class="social-share" data-image="/image/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/06/01/C%E8%AF%AD%E8%A8%80%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89%E7%AC%94%E8%AE%B0/" title="C语言（进阶）笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">C语言（进阶）笔记</div></div><div class="info-2"><div class="info-item-1">第一章、数据的存储1.整型在内存中的存储1.1 原码、反码和补码1int a = 10;  计算机中的整数有三种表示方法，即原码、反码和补码。 三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位负整数的三种表示方法各不相同。  原码—直接将二进制按照正负数的形式翻译成二进制就可以。 反码—将原码的符号位不变，其他位依次按位取反就可以得到了。 补码—反码+1即为补码  数值位正整数的原码、反码、补码都相同。 对于整型来说，数据存放内存中其实存放的是补码。 原因：在计算机系统中，数值一律用补码来表示和存储。原因在于使用补码可以将符号位和数值域统 一处理； 同时，加法和减法也可以统一处理（CPU只有加法器），另一方面，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。 1.2 大端和小端1234567int a = -10;//原码：10000000 00000000 00000000 00001010//反码：11111111 11111111 11111111 11110101//补码：11111111 11111111...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/06/01/C%E8%AF%AD%E8%A8%80%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89%E7%AC%94%E8%AE%B0/" title="C语言（基础）笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-01</div><div class="info-item-2">C语言（基础）笔记</div></div><div class="info-2"><div class="info-item-1">第一章、初识C语言先快速了解一下C语言的大概内容，点到为止，以后会具体介绍。 1.什么是C语言C语言是一门面向过程的、抽象化的通用程序设计语言，广泛应用于底层开发。 2.第一个C语言123456#include&lt;stdio.h&gt;int main()&#123;    printf(&quot;Hello,world!\n&quot;);    return 0;&#125;//Ctrl+F5  VS运行代码快捷键    3.数据类型123456789char          //字符数据类型short         //短整型int           //整型long          //长整型long long     //更长的整形float         //单精度浮点数double        //双精度浮点数//C语言中没有字符串类型//在不同的系统上，这些类型占据的字节长度不同，具体可以用sizeof测试    4.常量与变量常量—不变的量 变量—可变的量 4.1 定义变量的方法123int age = 150;float weight =...</div></div></div></a><a class="pagination-related" href="/2025/06/01/C%E8%AF%AD%E8%A8%80%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89%E7%AC%94%E8%AE%B0/" title="C语言（进阶）笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-01</div><div class="info-item-2">C语言（进阶）笔记</div></div><div class="info-2"><div class="info-item-1">第一章、数据的存储1.整型在内存中的存储1.1 原码、反码和补码1int a = 10;  计算机中的整数有三种表示方法，即原码、反码和补码。 三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位负整数的三种表示方法各不相同。  原码—直接将二进制按照正负数的形式翻译成二进制就可以。 反码—将原码的符号位不变，其他位依次按位取反就可以得到了。 补码—反码+1即为补码  数值位正整数的原码、反码、补码都相同。 对于整型来说，数据存放内存中其实存放的是补码。 原因：在计算机系统中，数值一律用补码来表示和存储。原因在于使用补码可以将符号位和数值域统 一处理； 同时，加法和减法也可以统一处理（CPU只有加法器），另一方面，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。 1.2 大端和小端1234567int a = -10;//原码：10000000 00000000 00000000 00001010//反码：11111111 11111111 11111111 11110101//补码：11111111 11111111...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/image/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Pudding</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Pudding1108" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:epiphany1108@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E7%BB%AA%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">第一章：绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">1.基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.2.</span> <span class="toc-text">2.算法的时间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%AE%97%E6%B3%95%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.3.</span> <span class="toc-text">3.算法的空间复杂度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">2.</span> <span class="toc-text">第二章：线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">2.1.</span> <span class="toc-text">1.线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1 线性表的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.2 基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-InitList-L"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">1.2.1 InitList(&amp;L)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-DestroyList-L"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">1.2.2 DestroyList(&amp;L)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-ListInsert-L-i-e"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">1.2.3 ListInsert(&amp;L,i,e)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-4-ListDelete-L-i-e"><span class="toc-number">2.1.2.4.</span> <span class="toc-text">1.2.4 ListDelete(&amp;L,i,&amp;e)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-5-LocateElem-L-e"><span class="toc-number">2.1.2.5.</span> <span class="toc-text">1.2.5 LocateElem(L,e)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-6-GetElem-L-i"><span class="toc-number">2.1.2.6.</span> <span class="toc-text">1.2.6 GetElem(L,i)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-7-%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">2.1.2.7.</span> <span class="toc-text">1.2.7 其他常用操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="toc-number">2.2.</span> <span class="toc-text">2.顺序表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1 顺序表的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2 顺序表的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.3 顺序表的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.4.</span> <span class="toc-text">2.4 顺序表的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E6%8F%92%E5%85%A5"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">2.4.1 插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-%E5%88%A0%E9%99%A4"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">2.4.2 删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-%E6%8C%89%E5%80%BC%E6%9F%A5%E6%89%BE"><span class="toc-number">2.2.4.3.</span> <span class="toc-text">2.4.3 按值查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-4-%E6%8C%89%E4%BD%8D%E6%9F%A5%E6%89%BE"><span class="toc-number">2.2.4.4.</span> <span class="toc-text">2.4.4 按位查找</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">2.3.</span> <span class="toc-text">3.单链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.3.1.</span> <span class="toc-text">3.1单链表的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.2.</span> <span class="toc-text">3.2单链表的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E6%8F%92%E5%85%A5"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">3.2.1 插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E5%88%A0%E9%99%A4"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">3.2.2 删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-%E6%9F%A5%E6%89%BE"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">3.2.3 查找</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="toc-number">2.3.3.</span> <span class="toc-text">3.3 单链表的建立</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E5%B0%BE%E6%8F%92%E6%B3%95"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">3.3.1 尾插法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-%E5%A4%B4%E6%8F%92%E6%B3%95"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">3.3.2 头插法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">2.4.</span> <span class="toc-text">4.双链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">2.5.</span> <span class="toc-text">5.循环链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%BE%AA%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">2.5.1.</span> <span class="toc-text">5.1 循环单链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%BE%AA%E7%8E%AF%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">2.5.2.</span> <span class="toc-text">5.2 循环双链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8"><span class="toc-number">2.6.</span> <span class="toc-text">6.静态链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">2.7.</span> <span class="toc-text">7.顺序表和链表的比较</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">3.</span> <span class="toc-text">第三章：栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A0%88"><span class="toc-number">3.1.</span> <span class="toc-text">1.栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.1.</span> <span class="toc-text">1.1 栈的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">3.1.2.</span> <span class="toc-text">1.2 栈的基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.1.3.</span> <span class="toc-text">1.3 栈的顺序存储实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.1.4.</span> <span class="toc-text">1.4 栈的链式存储实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%98%9F%E5%88%97"><span class="toc-number">3.2.</span> <span class="toc-text">2.队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.2.1.</span> <span class="toc-text">2.1 队列的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.2 队列的基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.3.</span> <span class="toc-text">2.3 队列的顺序存储实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.4.</span> <span class="toc-text">2.4 队列的链式存储实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="toc-number">3.2.5.</span> <span class="toc-text">2.5 双端队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.3.</span> <span class="toc-text">3.栈的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%A0%88%E5%9C%A8%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.1 栈在括号匹配中的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%A0%88%E5%9C%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.2 栈在表达式求值中的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">3.2.1 后缀表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E4%B8%AD%E7%BC%80%E8%BD%AC%E5%90%8E%E7%BC%80"><span class="toc-number">3.3.2.1.1.</span> <span class="toc-text">（1）中缀转后缀</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">3.3.2.1.2.</span> <span class="toc-text">（2）后缀表达式的计算</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E5%89%8D%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">3.2.2 前缀表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89-%E4%B8%AD%E7%BC%80%E8%BD%AC%E5%89%8D%E7%BC%80"><span class="toc-number">3.3.2.2.1.</span> <span class="toc-text">（1） 中缀转前缀</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89-%E5%89%8D%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">3.3.2.2.2.</span> <span class="toc-text">（2） 前缀表达式的计算</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.3.2.3.</span> <span class="toc-text">3.2.3 中缀表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89-%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">3.3.2.3.1.</span> <span class="toc-text">（1） 中缀表达式的计算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%A0%88%E5%9C%A8%E9%80%92%E5%BD%92%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.3.3.</span> <span class="toc-text">3.3 栈在递归中的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.4.</span> <span class="toc-text">4.队列的应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-number">3.5.</span> <span class="toc-text">5.特殊矩阵的压缩存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.5.1.</span> <span class="toc-text">5.1 数据的存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5"><span class="toc-number">3.5.2.</span> <span class="toc-text">5.2 特殊矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1-%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5"><span class="toc-number">3.5.2.1.</span> <span class="toc-text">5.2.1 对称矩阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2-%E4%B8%89%E8%A7%92%E7%9F%A9%E9%98%B5"><span class="toc-number">3.5.2.2.</span> <span class="toc-text">5.2.2 三角矩阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-3-%E4%B8%89%E5%AF%B9%E8%A7%92%E7%9F%A9%E9%98%B5"><span class="toc-number">3.5.2.3.</span> <span class="toc-text">5.2.3 三对角矩阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-4-%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5"><span class="toc-number">3.5.2.4.</span> <span class="toc-text">5.2.4 稀疏矩阵</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E4%B8%B2"><span class="toc-number">4.</span> <span class="toc-text">第四章：串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%B2%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.</span> <span class="toc-text">1.串的定义和基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%B8%B2%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">4.1.1.</span> <span class="toc-text">1.1 串的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.2.</span> <span class="toc-text">1.2 串的基本操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.</span> <span class="toc-text">2.串的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E4%B8%B2%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">4.2.1.</span> <span class="toc-text">2.1 串的顺序存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E4%B8%B2%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">4.2.2.</span> <span class="toc-text">2.2 串的链式存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.3.</span> <span class="toc-text">2.3 基本操作的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">4.3.</span> <span class="toc-text">3.字符串模式匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%9C%B4%E7%B4%A0%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.1.</span> <span class="toc-text">3.1 朴素模式匹配算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-KMP%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.2.</span> <span class="toc-text">3.2.KMP算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E6%89%8B%E7%AE%97next%E6%95%B0%E7%BB%84"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">3.2.1 手算next数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">3.2.2 完整代码</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E6%A0%91"><span class="toc-number">5.</span> <span class="toc-text">第五章：树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A0%91"><span class="toc-number">5.1.</span> <span class="toc-text">1.树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.1.</span> <span class="toc-text">1.1 基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="toc-number">5.1.2.</span> <span class="toc-text">1.2 基本术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">5.1.3.</span> <span class="toc-text">1.3 树的性质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.2.</span> <span class="toc-text">2.二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="toc-number">5.2.1.</span> <span class="toc-text">2.1 定义和基本术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%80%A7%E8%B4%A8"><span class="toc-number">5.2.2.</span> <span class="toc-text">2.2 性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.3.</span> <span class="toc-text">2.3 存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">5.2.3.1.</span> <span class="toc-text">2.3.1 顺序存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">5.2.3.2.</span> <span class="toc-text">2.3.2 链式存储</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%88%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">5.2.4.</span> <span class="toc-text">2.4 二叉树的先中后序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-number">5.2.5.</span> <span class="toc-text">2.5 二叉树的层次遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.3.</span> <span class="toc-text">3.线索二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BA%BF%E7%B4%A2%E5%8C%96"><span class="toc-number">5.3.1.</span> <span class="toc-text">3.1 二叉树的线索化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%9C%A8%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%89%8D%E9%A9%B1%E5%90%8E%E7%BB%A7"><span class="toc-number">5.3.2.</span> <span class="toc-text">3.2 在线索二叉树中找前驱后继</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.3.2.1.</span> <span class="toc-text">3.2.1 中序线索二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E5%85%88%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.3.2.2.</span> <span class="toc-text">3.2.2 先序线索二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-%E5%90%8E%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.3.2.3.</span> <span class="toc-text">3.2.3 后序线索二叉树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">5.4.</span> <span class="toc-text">4.树的存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%88%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%EF%BC%89"><span class="toc-number">5.4.1.</span> <span class="toc-text">4.1 双亲表示法（顺序存储）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%88%E9%A1%BA%E5%BA%8F-%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%EF%BC%89"><span class="toc-number">5.4.2.</span> <span class="toc-text">4.2 孩子表示法（顺序+链式存储）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%88%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%EF%BC%89"><span class="toc-number">5.4.3.</span> <span class="toc-text">4.3 孩子兄弟表示法（链式存储）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">5.5.</span> <span class="toc-text">5.树和森林的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">5.5.1.</span> <span class="toc-text">5.1 树的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">5.5.2.</span> <span class="toc-text">5.2 森林的遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">5.6.</span> <span class="toc-text">6.树与二叉树的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91-BST"><span class="toc-number">5.6.1.</span> <span class="toc-text">6.1二叉排序树(BST)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-%E6%9F%A5%E6%89%BE"><span class="toc-number">5.6.1.1.</span> <span class="toc-text">6.1.1 查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2-%E6%8F%92%E5%85%A5"><span class="toc-number">5.6.1.2.</span> <span class="toc-text">6.1.2 插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-3-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">5.6.1.3.</span> <span class="toc-text">6.1.3 二叉排序树的构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-4-%E5%88%A0%E9%99%A4"><span class="toc-number">5.6.1.4.</span> <span class="toc-text">6.1.4 删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-5-%E6%9F%A5%E6%89%BE%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90"><span class="toc-number">5.6.1.5.</span> <span class="toc-text">6.1.5 查找效率分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-AVL"><span class="toc-number">5.6.2.</span> <span class="toc-text">6.2 平衡二叉树(AVL)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1-%E8%B0%83%E6%95%B4%E6%9C%80%E5%B0%8F%E4%B8%8D%E5%B9%B3%E8%A1%A1%E5%AD%90%E6%A0%91"><span class="toc-number">5.6.2.1.</span> <span class="toc-text">6.2.1 调整最小不平衡子树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90"><span class="toc-number">5.6.2.2.</span> <span class="toc-text">6.2.2 平衡二叉树的查找与效率分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">5.6.3.</span> <span class="toc-text">6.3 哈夫曼树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-1-%E5%B8%A6%E6%9D%83%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6"><span class="toc-number">5.6.3.1.</span> <span class="toc-text">6.3.1 带权路径长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-2-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">5.6.3.2.</span> <span class="toc-text">6.3.2 哈夫曼树的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-3-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">5.6.3.3.</span> <span class="toc-text">6.3.3 哈夫曼树的构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-4-%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">5.6.3.4.</span> <span class="toc-text">6.3.4 哈夫曼编码</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%9B%BE"><span class="toc-number">6.</span> <span class="toc-text">第六章：图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.</span> <span class="toc-text">1.图的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">6.2.</span> <span class="toc-text">2.图的存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">6.2.1.</span> <span class="toc-text">2.1 邻接矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">6.2.2.</span> <span class="toc-text">2.2 邻接表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8"><span class="toc-number">6.2.3.</span> <span class="toc-text">2.3 十字链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8"><span class="toc-number">6.2.4.</span> <span class="toc-text">2.4 邻接多重表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">6.3.</span> <span class="toc-text">3.图的基本操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="toc-number">6.4.</span> <span class="toc-text">4.图的遍历算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%88BFS%EF%BC%89"><span class="toc-number">6.4.1.</span> <span class="toc-text">4.1 广度优先遍历（BFS）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%88DFS%EF%BC%89"><span class="toc-number">6.4.2.</span> <span class="toc-text">4.2 深度优先遍历（DFS）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">6.5.</span> <span class="toc-text">5.最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">6.5.1.</span> <span class="toc-text">5.1 最小生成树的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-Prim%E7%AE%97%E6%B3%95"><span class="toc-number">6.5.2.</span> <span class="toc-text">5.2 Prim算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-Kruskal%E7%AE%97%E6%B3%95"><span class="toc-number">6.5.3.</span> <span class="toc-text">5.3 Kruskal算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95"><span class="toc-number">6.6.</span> <span class="toc-text">6.最短路径算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-BFS%E7%AE%97%E6%B3%95"><span class="toc-number">6.6.1.</span> <span class="toc-text">6.1 BFS算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-Dijkstra%E7%AE%97%E6%B3%95"><span class="toc-number">6.6.2.</span> <span class="toc-text">6.2 Dijkstra算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-Floyd%E7%AE%97%E6%B3%95"><span class="toc-number">6.6.3.</span> <span class="toc-text">6.3 Floyd算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE"><span class="toc-number">6.7.</span> <span class="toc-text">7.有向无环图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">6.8.</span> <span class="toc-text">8.拓扑排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">6.8.1.</span> <span class="toc-text">8.1 拓扑排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E9%80%86%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">6.8.2.</span> <span class="toc-text">8.2 逆拓扑排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="toc-number">6.9.</span> <span class="toc-text">9.关键路径</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E6%9F%A5%E6%89%BE"><span class="toc-number">7.</span> <span class="toc-text">第七章：查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%9F%A5%E6%89%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">7.1.</span> <span class="toc-text">1.查找的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="toc-number">7.2.</span> <span class="toc-text">2.顺序查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-number">7.2.1.</span> <span class="toc-text">2.1 算法思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.2.2.</span> <span class="toc-text">2.2 算法实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span class="toc-number">7.3.</span> <span class="toc-text">3.折半查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-number">7.3.1.</span> <span class="toc-text">3.1 算法思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.3.2.</span> <span class="toc-text">3.2 算法实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%E5%88%A4%E5%AE%9A%E6%A0%91"><span class="toc-number">7.3.3.</span> <span class="toc-text">3.3 折半查找判定树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE"><span class="toc-number">7.4.</span> <span class="toc-text">4.分块查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-number">7.4.1.</span> <span class="toc-text">4.1 算法思想</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-B%E6%A0%91"><span class="toc-number">7.5.</span> <span class="toc-text">5.B树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-B%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">7.5.1.</span> <span class="toc-text">5.1 B树的性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-B%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">7.5.2.</span> <span class="toc-text">5.2 B树的查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-B%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-number">7.5.3.</span> <span class="toc-text">5.3 B树的插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-B%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">7.5.4.</span> <span class="toc-text">5.4 B树的删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-B-%E6%A0%91"><span class="toc-number">7.6.</span> <span class="toc-text">6.B+树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-B-%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">7.6.1.</span> <span class="toc-text">6.1 B+树的性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-B-%E6%A0%91-vs-B%E6%A0%91"><span class="toc-number">7.6.2.</span> <span class="toc-text">6.2 B+树 vs B树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE"><span class="toc-number">7.7.</span> <span class="toc-text">7.散列查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E6%A6%82%E5%BF%B5"><span class="toc-number">7.7.1.</span> <span class="toc-text">7.1 概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E6%9E%84%E9%80%A0%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0"><span class="toc-number">7.7.2.</span> <span class="toc-text">7.2 构造散列函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E5%A4%84%E7%90%86%E5%86%B2%E7%AA%81%E7%9A%84%E5%8A%9E%E6%B3%95"><span class="toc-number">7.7.3.</span> <span class="toc-text">7.3 处理冲突的办法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-1-%E6%8B%89%E9%93%BE%E6%B3%95"><span class="toc-number">7.7.3.1.</span> <span class="toc-text">7.3.1 拉链法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-2-%E5%BC%80%E6%94%BE%E5%AE%9A%E5%9D%80%E6%B3%95"><span class="toc-number">7.7.3.2.</span> <span class="toc-text">7.3.2 开放定址法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E6%8E%92%E5%BA%8F"><span class="toc-number">8.</span> <span class="toc-text">第八章：排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">8.1.</span> <span class="toc-text">1.排序的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">8.2.</span> <span class="toc-text">2.插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-1"><span class="toc-number">8.2.1.</span> <span class="toc-text">2.1 算法思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">8.2.2.</span> <span class="toc-text">2.2 算法实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96"><span class="toc-number">8.2.3.</span> <span class="toc-text">2.3 算法优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">8.3.</span> <span class="toc-text">3.希尔排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-1"><span class="toc-number">8.3.1.</span> <span class="toc-text">3.1 算法思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">8.3.2.</span> <span class="toc-text">3.2 算法实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">8.4.</span> <span class="toc-text">4.冒泡排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-1"><span class="toc-number">8.4.1.</span> <span class="toc-text">4.1 算法思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.4.2.</span> <span class="toc-text">4.2 算法实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">8.5.</span> <span class="toc-text">5.快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-number">8.5.1.</span> <span class="toc-text">5.1 算法思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.5.2.</span> <span class="toc-text">5.2 算法实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">8.6.</span> <span class="toc-text">6.简单选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-number">8.6.1.</span> <span class="toc-text">6.1 算法思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.6.2.</span> <span class="toc-text">6.2 算法实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">8.7.</span> <span class="toc-text">7.堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-number">8.7.1.</span> <span class="toc-text">7.1 算法思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.7.2.</span> <span class="toc-text">7.2 算法实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">8.8.</span> <span class="toc-text">8.归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-number">8.8.1.</span> <span class="toc-text">8.1 算法思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.8.2.</span> <span class="toc-text">8.2 算法实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">8.9.</span> <span class="toc-text">9.基数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-number">8.9.1.</span> <span class="toc-text">9.1 算法思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.9.2.</span> <span class="toc-text">9.2 算法实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">8.10.</span> <span class="toc-text">10.外部排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">8.10.1.</span> <span class="toc-text">10.1 外部排序的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E5%BD%B1%E5%93%8D%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F%E6%95%88%E7%8E%87%E7%9A%84%E5%9B%A0%E7%B4%A0"><span class="toc-number">8.10.2.</span> <span class="toc-text">10.2 影响外部排序效率的因素</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89%E7%AC%94%E8%AE%B0/" title="数据结构（基础）笔记">数据结构（基础）笔记</a><time datetime="2025-06-01T04:10:00.000Z" title="发表于 2025-06-01 12:10:00">2025-06-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/01/C%E8%AF%AD%E8%A8%80%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89%E7%AC%94%E8%AE%B0/" title="C语言（进阶）笔记">C语言（进阶）笔记</a><time datetime="2025-06-01T04:05:00.000Z" title="发表于 2025-06-01 12:05:00">2025-06-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/01/C%E8%AF%AD%E8%A8%80%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89%E7%AC%94%E8%AE%B0/" title="C语言（基础）笔记">C语言（基础）笔记</a><time datetime="2025-06-01T04:00:00.000Z" title="发表于 2025-06-01 12:00:00">2025-06-01</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/image/background.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2025 By Pudding</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>